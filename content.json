{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"每日总结-1月12日","slug":"1-12","date":"2022-01-12T12:47:08.000Z","updated":"2022-01-12T13:49:16.208Z","comments":true,"path":"2022/01/12/1-12/","link":"","permalink":"http://example.com/2022/01/12/1-12/","excerpt":"","text":"搜索进阶dfs&amp;bfs&amp;迭代加深&amp;A*算法 剪枝优化 优化搜索顺序 排除等效冗余 可行性剪枝 最优性剪枝 记忆化搜索 常数优化 今日战况 前言我个人感觉我的搜索应该还是差不多的，但是今天的题目让我觉得我的剪枝方面的水平还有待提升，以及自己的构造能力不强，有时候在脑子里面能想出来一些东西，但是无法马上构思出代码，还得想亿会才能(也可能想不出来)。 部分题目题解C题: Soduku (最简单版本的)题目传送门 题目 Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task. Input The input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0. Output For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them. Sample Input 123456789101103000509002109400000704000300502006060000050700803004000401000009205800804000107 Sample Output 123456789143628579572139468986754231391542786468917352725863914237481695619275843854396127 题目大意有t个测试样例，每个样例都有一个9*9的数独，里面的0表示未确定的数，编程写这个数独，输出写好之后的数独。 思路暴力的话就是用搜索遍历每一行每一个位置，枚举每一个可能的结果，直到得到结果。 此题数据比较水，暴力就直接能AC。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;int a[10][10],belong[10][10];bool r[10][10],c[10][10],d[10][10],can;void output()&#123; for(int i=1;i&lt;=9;++i)&#123; for(int j=1;j&lt;=9;++j) printf(&quot;%d&quot;,a[i][j]); printf(&quot;\\n&quot;); &#125;&#125;void dfs(int jj,int kk)&#123; if(can) return; if(a[jj][kk])&#123; if(kk&lt;9) dfs(jj,kk+1); else if(jj&lt;9) dfs(jj+1,1); else&#123; output(); can=true; &#125; return; &#125; for(int i=1;i&lt;=9;++i)&#123; if(r[jj][i]||c[kk][i]||d[belong[jj][kk]][i]) continue; a[jj][kk]=i; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=true; if(kk&lt;9) dfs(jj,kk+1); else if(jj&lt;9) dfs(jj+1,1); else&#123; output(); can=true; return; &#125; if(can) return; a[jj][kk]=0; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=false; &#125;&#125;void solve_it()&#123; for(int i=1;i&lt;=9;++i)&#123; char jj; getchar(); for(int j=1;j&lt;=9;++j)&#123; scanf(&quot;%c&quot;,&amp;jj); a[i][j]=jj-&#x27;0&#x27;; if(a[i][j]!=0)&#123; r[i][a[i][j]]=true; c[j][a[i][j]]=true; d[belong[i][j]][a[i][j]]=true; &#125; &#125; &#125; can=false; dfs(1,1); for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j)&#123; a[i][j]=0; r[i][j]=c[i][j]=d[i][j]=false; &#125;&#125;int main()&#123; for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j) belong[i][j]=(i-1)/3*3+(j-1)/3+1; int t;scanf(&quot;%d&quot;,&amp;t); while(t--) solve_it(); return 0;&#125; D题: Soduku (变态数据版本的)(未做出来)题目传送门 题目 In the game of Sudoku, you are given a large 9 × 9 grid divided into smaller 3 × 3 subgrids. For example, Given some of the numbers in the grid, your goal is to determine the remaining numbers such that the numbers 1 through 9 appear exactly once in (1) each of nine 3 × 3 subgrids, (2) each of the nine rows, and (3) each of the nine columns. Input The input test file will contain multiple cases. Each test case consists of a single line containing 81 characters, which represent the 81 squares of the Sudoku grid, given one row at a time. Each character is either a digit (from 1 to 9) or a period (used to indicate an unfilled square). You may assume that each puzzle in the input will have exactly one solution. The end-of-file is denoted by a single line containing the word “end”. Output For each test case, print a line representing the completed Sudoku puzzle. Sample Input 123.2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.end Sample Output 12527389416819426735436751829375692184194538267268174593643217958951843672782965341416837529982465371735129468571298643293746185864351297647913852359682714128574936 题目大意和上道题大意一样，输入一个数独，输出填充完整的数独。但是测试数据要比C题离谱的多。 思路各种优化 我目前的代码只进行了搜索顺序的优化，常熟优化还没学会。 附上进行了搜索顺序优化的代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;struct row&#123; int id,num;&#125;cnt[10];int a[10][10],belong[10][10],rate[10];string s;bool r[10][10],c[10][10],d[10][10],can;bool cmp(row jj,row kk)&#123;return jj.num&lt;kk.num;&#125;void output()&#123; for(int i=1;i&lt;=9;++i)&#123; for(int j=1;j&lt;=9;++j) printf(&quot;%d&quot;,a[i][j]); &#125; printf(&quot;\\n&quot;);&#125;void dfs(int jj,int kk)&#123;// printf(&quot;%d %d\\n&quot;,jj,rate[jj]); if(can) return; if(a[jj][kk])&#123; if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else&#123; output(); can=true; &#125; return; &#125; for(int i=1;i&lt;=9;++i)&#123; if(r[jj][i]||c[kk][i]||d[belong[jj][kk]][i]) continue; a[jj][kk]=i; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=true; if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else&#123; output(); can=true; return; &#125; if(can) return; a[jj][kk]=0; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=false; &#125;&#125;void solve_it()&#123; int p=-1; for(int i=1;i&lt;=9;++i)&#123; cnt[i].id=i; cnt[i].num=0; for(int j=1;j&lt;=9;++j)&#123; if(s[++p]==&#x27;.&#x27;)&#123; a[i][j]=0; ++cnt[i].num; continue; &#125; a[i][j]=s[p]-&#x27;0&#x27;; r[i][a[i][j]]=true; c[j][a[i][j]]=true; d[belong[i][j]][a[i][j]]=true; &#125; &#125; sort(cnt+1,cnt+10,cmp); for(int i=1;i&lt;=9;++i) rate[cnt[i].id]=i; can=false; dfs(cnt[1].id,1); for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j)&#123; a[i][j]=0; r[i][j]=c[i][j]=d[i][j]=false; &#125;&#125;int main()&#123; for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j) belong[i][j]=(i-1)/3*3+(j-1)/3+1; // int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) while(true)&#123; cin&gt;&gt;s; if(s==&quot;end&quot;) break; solve_it(); &#125; return 0;&#125; F题: 靶形数独题目传送门 这里就不放题目了，思路和上面的数独的题一样，通过优化搜索顺序即可AC 枚举出每种可能的最终结果，取最大值即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;struct row&#123; int id,num;&#125;cnt[10];int a[10][10],belong[10][10],rate[10],ans;bool r[10][10],c[10][10],d[10][10];bool cmp(row jj,row kk)&#123;return jj.num&lt;kk.num;&#125;void output()&#123; for(int i=1;i&lt;=9;++i)&#123; for(int j=1;j&lt;=9;++j) printf(&quot;%d &quot;,a[i][j]); &#125; printf(&quot;\\n&quot;);&#125;int getans()&#123; int re=10*a[5][5]; for(int i=1;i&lt;=4;++i)&#123; int st=5-i,en=5+i; int fen=10-i; for(int j=st;j&lt;=en;++j)&#123; re+=a[st][j]*fen; re+=a[en][j]*fen; &#125; for(int j=st+1;j&lt;en;++j)&#123; re+=a[j][st]*fen; re+=a[j][en]*fen; &#125; &#125; return re;&#125;void dfs(int jj,int kk)&#123; if(a[jj][kk])&#123; if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else&#123;// output(); ans=max(ans,getans()); &#125; return; &#125; for(int i=1;i&lt;=9;++i)&#123; if(r[jj][i]||c[kk][i]||d[belong[jj][kk]][i]) continue; a[jj][kk]=i; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=true; if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else&#123;// output(); ans=max(ans,getans()); &#125; a[jj][kk]=0; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=false; &#125;&#125;void solve_it()&#123; for(int i=1;i&lt;=9;++i)&#123; cnt[i].id=i; cnt[i].num=0; for(int j=1;j&lt;=9;++j)&#123; scanf(&quot;%d&quot;,&amp;a[i][j]); if(a[i][j]==0)&#123; ++cnt[i].num; continue; &#125; r[i][a[i][j]]=true; c[j][a[i][j]]=true; d[belong[i][j]][a[i][j]]=true; &#125; &#125; sort(cnt+1,cnt+10,cmp); for(int i=1;i&lt;=9;++i) rate[cnt[i].id]=i; ans=-1; dfs(cnt[1].id,1); printf(&quot;%d\\n&quot;,ans); &#125;int main()&#123; for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j) belong[i][j]=(i-1)/3*3+(j-1)/3+1; // int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) solve_it(); return 0;&#125; 总结今天的搜索进阶听课和写题都挺有收获，知道了搜索的各种优化思路，以及了解到了迭代加深的思路，并成功依此A题。 今天先总结这三道题，明天再总结其他题目","categories":[],"tags":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"cfRound#764(Div.3)Summary","slug":"cfRound-764-Div-3-Summary","date":"2022-01-11T13:36:07.000Z","updated":"2022-01-11T16:49:05.829Z","comments":true,"path":"2022/01/11/cfRound-764-Div-3-Summary/","link":"","permalink":"http://example.com/2022/01/11/cfRound-764-Div-3-Summary/","excerpt":"","text":"Codeforces Round #764(Div. 3)CONTEST传送门 战况Standing Rating 补题D - Palindromes Coloring题目 time limit per test: 2 seconds memory limit per test: 256 megabytes input: standard input output: standard output You have a string s consisting of lowercase Latin alphabet letters. You can color some letters in colors from 1 to k. It is not necessary to paint all the letters. But for each color, there must be a letter painted in that color. Then you can swap any two symbols painted in the same color as many times as you want. After that, k strings will be created, i-th of them will contain all the characters colored in the color i, written in the order of their sequence in the string s. Your task is to color the characters of the string so that all the resulting k strings are palindromes, and the length of the shortest of these k strings is as large as possible. Read the note for the first test case of the example if you need a clarification. Recall that a string is a palindrome if it reads the same way both from left to right and from right to left. For example, the strings abacaba, cccc, z and dxd are palindromes, but the strings abab and aaabaa — are not. Input The first line of input data contains a single integer t (1 ≤ t ≤ 10⁴ ) — the number of input data sets in the test. The descriptions of the input data sets follow. The first line of the description of each input data set contains two integers n and k ( 1 ≤ k ≤ n ≤ 2⋅10⁵ ) — the length of the string and the number of colors in which its letters can be painted. The second line of the description of each input data set contains a string s of length n consisting of lowercase letters of the Latin alphabet. It is guaranteed that the sum of n over all test cases does not exceed 2⋅10⁵ . Output For each set of input data, output a single integer — the maximum length of the shortest palindrome string that can be obtained. Example input 108 2bxyaxzay6 3aaaaaa6 1abcdef6 6abcdef3 2dxd11 2abcabcabcac6 6sipkic7 2eatoohd3 1llw6 2bfvfbv output 3211151133 Note In the first test case, s =”bxyaxzay”, k=2. We use indices in the string from 1 to 8. The following coloring will work: bxyaxzaybxyaxzay (the letter z remained uncolored). After painting: swap two red characters (with the indices 1 and 4), we get axybxzay; swap two blue characters (with the indices 5 and 8), we get axybyzax. Now, for each of the two colors we write out the corresponding characters from left to right, we get two strings aba and xyyx. Both of them are palindromes, the length of the shortest is 3. It can be shown that the greatest length of the shortest palindrome cannot be achieved. In the second set of input data, the following coloring is suitable: [1,1,2,2,3,3]. There is no need to swap characters. Both received strings are equal to aa, they are palindromes and their length is 2. In the third set of input data, you can color any character and take it into a string. In the fourth set of input data, you can color the i-th character in the color i. In the fifth set of input data can be colored in each of the colors of one character. In the sixth set of input data, the following coloring is suitable: [1,1,1,1,1,2,2,2,2,2,0]. Rearrange the characters so as to get the palindromes abcba and acbca. 大概意思输入一个长度为 n 的由小写字母组成的字符串，取其中的字母组成 k 个回文字符串，每个字母(位置不同的每个字母)最多只能属于一个字符串。问怎样取能使得取得的 k 个回文字符串中的最短的那一个尽量长。输出这个长度。 我当时的思路在一个回文串中，若该回文串的长度为偶数，则每个字母出现的次数都是偶数(即成对出现)，若该回文串的长度为奇数，则有且只有一个字母出现的次数为奇数，且其他字母出现的次数为偶数(成对出现)。 记录下原字符串中每个字母出现的次数，接着，记录下成对出现的字母有几组(记两个相同的字母为一组)和单个出现的字母有几个。 接着，就是对每一种情况的分析及枚举(详见代码)。 当时的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=200005;const double eps=0.0000001;int n,k,num[200];char a[MAXX];void solve_it()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); getchar(); scanf(&quot;%s&quot;,a+1); int len=strlen(a+1); for(int i=1;i&lt;=len;++i)&#123; ++num[a[i]]; &#125; int sum=0,dan=0; for(int i=&#x27;a&#x27;;i&lt;=&#x27;z&#x27;;++i)&#123; if(num[i]%2==1)&#123; sum+=num[i]-1; ++dan; &#125; else sum+=num[i]; &#125; sum/=2; int ans; if(k&gt;n/2) ans=1; else if(sum&lt;k) ans=1; else&#123; ans=sum/k*2; if(sum%k==0)&#123; if(dan&gt;=k) ++ans; &#125; else&#123; int s=sum%k; dan+=s*2; if(dan&lt;k) ans=ans; else ++ans; &#125; &#125; printf(&quot;%d\\n&quot;,ans); for(int i=&#x27;a&#x27;;i&lt;=&#x27;z&#x27;;++i) num[i]=0;&#125;int main()&#123; int t;scanf(&quot;%d&quot;,&amp;t); while(t--) solve_it(); return 0;&#125; 现在想的思路最小值最大化，典型的二分。(但是当时我不会写二分😭,而且看着E题和F题都好像要用到二分) 现在的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=200005;const double eps=0.0000001;int n,k,num[200];int sum=0,dan=0,can;char a[MAXX];bool check(int jj)&#123; if(jj&lt;=sum/k*2+can) return true; else return false;&#125;void solve_it()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); getchar(); scanf(&quot;%s&quot;,a+1); int len=strlen(a+1); for(int i=1;i&lt;=len;++i)&#123; ++num[a[i]]; &#125; for(int i=&#x27;a&#x27;;i&lt;=&#x27;z&#x27;;++i)&#123; sum+=num[i]/2; dan+=num[i]%2; &#125; if(sum%k*2+dan&gt;=k) can=1; else can=0; int l=1,r=n,mid; while(l&lt;r)&#123; mid=(l+r+1)/2; if(check(mid)) l=mid; else r=mid-1; &#125; printf(&quot;%d\\n&quot;,r); for(int i=&#x27;a&#x27;;i&lt;=&#x27;z&#x27;;++i) num[i]=0; sum=dan=0;&#125;int main()&#123; int t;scanf(&quot;%d&quot;,&amp;t); while(t--) solve_it(); return 0;&#125; 总结二分杀我","categories":[],"tags":[{"name":"codeforces-practice","slug":"codeforces-practice","permalink":"http://example.com/tags/codeforces-practice/"}]},{"title":"每日总结-1月11日","slug":"1-11","date":"2022-01-11T13:17:05.000Z","updated":"2022-01-11T14:01:18.297Z","comments":true,"path":"2022/01/11/1-11/","link":"","permalink":"http://example.com/2022/01/11/1-11/","excerpt":"","text":"dp进阶区间dp&amp;树形dp&amp;概率dp&amp;数位dp 今日战况 前言vj上的题好难啊， 第一题我看着和昨天的那道”石子合并”挺像的，但就是不知道怎么类比过去，看了半天就是不知道该怎么写。其他题看着也都好难，思路也都想不出来。 关于昨晚的CFCF Round #764 (Div. 3)总结 总结进阶dp(还有基础dp)现在还是软肋，仍需大量练习理解。","categories":[],"tags":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"每日总结-1月10日","slug":"1-10","date":"2022-01-10T12:05:24.000Z","updated":"2022-01-11T13:51:12.251Z","comments":true,"path":"2022/01/10/1-10/","link":"","permalink":"http://example.com/2022/01/10/1-10/","excerpt":"","text":"dp进阶区间dp&amp;树形dp&amp;概率dp&amp;数位dp 前言今天没有弄题目，就在网上找资料学习和做题。 感觉这一部分好难，不太好理解，难以运用。需要大量的练习。 区间dp区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。 令状态 f(i,j) 表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 f(i,j)=max&#123;f(i,k)+f(k+1,j)+cost&#125; ， cost 为将这两组元素合并起来的代价。 特点 合并：将两个或多个部分进行整合，当然也可以反过来。 特征：能将问题分解为能两两合并的形式。 求解：对整个问题设最优质，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。 例题石子合并 题目将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。 请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算： 选择一种合并石子的方案，使得做 n-1 次合并得分总和最大。 选择一种合并石子的方案，使得做 n-1 次合并得分总和最小。 输入格式 输入第一行一个整数 n ，表示有 n 堆石子。 第二行 n 个整数，表示每堆石子的数量。 输出格式 输出共两行： 第一行为合并得分总和最小值， 第二行为合并得分总和最大值。 样例 输入 1244 5 9 4 输出 124354 数据范围与提示 对于 100% 的数据，有 1 ≤ n ≤ 200 。 思路状态转移方程 环的处理 将链延长至两倍，变成 2*n 堆，其中第 i 堆与第 n+i 堆相同，用动态规划求解后，取 f(1,n),f(2,n+1),…,f(i,n+i-1) 中的最优值，即为最后的答案。 时间复杂度 O(n³) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=210;const double eps=0.0000001;int n,a[2*MAXX],sum[2*MAXX],dpmax[2*MAXX][2*MAXX],dpmin[2*MAXX][2*MAXX];void solve_it()&#123; scanf(&quot;%d&quot;,&amp;n); int n2=n*2; for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;a[i]); a[n+i]=a[i]; &#125; for(int i=1;i&lt;=n2;++i) sum[i]=sum[i-1]+a[i]; memset(dpmin,Inf,sizeof(dpmin)); for(int i=1;i&lt;=n2;++i) dpmin[i][i]=0; for(int c=2;c&lt;=n;++c)&#123; for(int i=1;i&lt;n2;++i)&#123; int j=i+c-1; for(int k=i;k&lt;j&amp;&amp;k&lt;n2;++k)&#123; dpmax[i][j]=max(dpmax[i][j],dpmax[i][k]+dpmax[k+1][j]+sum[j]-sum[i-1]); dpmin[i][j]=min(dpmin[i][j],dpmin[i][k]+dpmin[k+1][j]+sum[j]-sum[i-1]); &#125; &#125; &#125; int ansmax=dpmax[1][n],ansmin=dpmin[1][n]; for(int i=2;i&lt;=n;++i)&#123; ansmax=max(ansmax,dpmax[i][i+n-1]); ansmin=min(ansmin,dpmin[i][i+n-1]); &#125; printf(&quot;%d\\n%d\\n&quot;,ansmin,ansmax); &#125;int main()&#123;// int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) solve_it(); return 0;&#125; 树形dp就是在树上进行的dp(确信) 一般为递归实现 例题没有上司的舞会 题目某大学有 n 个职员，编号为 1…n 。 他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。 现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 r_i，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。 所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 输入格式 输入的第一行是一个整数 n。 第 22 到第 (n + 1) 行，每行一个整数，第 (i + 1) 行的整数表示 ii 号职员的快乐指数 r_i 。 第 (n + 2) 到第 2n2n 行，每行输入一对整数 l , k ，代表 k 是 l 的直接上司。 输出格式 输出一行一个整数代表最大的快乐指数。 输入输出样例 输入 1234567891011121314711111111 32 36 47 44 53 5 输出 15 数据范围 对于 100% 的数据，保证 1 ≤ n ≤ 6 * 10³ , -128 ≤ r_i ≤ 127 , 1 ≤ l,k ≤ n，且给出的关系一定是一棵树。 思路用 f(i,0/1) 代表以 i 为根的子树的最优解 (0表示 i 不参加舞会，1表示 i 参加舞会)。 状态转移方程 f(i,0) = ∑max{f(x,1),f(x,0)} (上司不参加舞会，下属可参加可不参加) f(i,1) = ∑f(x,0) + a_i (上司参加舞会，下属不参加) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;int n,a[MAXX],ans[MAXX][2],in[MAXX];vector&lt;int&gt; son[MAXX];int dfs(int now,int flag)&#123; if(ans[now][flag]!=Inf) return ans[now][flag]; if(flag==1)&#123; int re=a[now]; int si=son[now].size(); for(int i=0;i&lt;si;++i) re+=dfs(son[now][i],0); return ans[now][flag]=re; &#125; else&#123; int re=0; int si=son[now].size(); for(int i=0;i&lt;si;++i) re+=max(dfs(son[now][i],1),dfs(son[now][i],0)); return ans[now][flag]=re; &#125;&#125;void solve_it()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;n;++i)&#123; int jj,kk;scanf(&quot;%d%d&quot;,&amp;jj,&amp;kk); son[kk].emplace_back(jj); in[jj]=1; &#125; memset(ans,Inf,sizeof(ans)); int ans=0; for(int i=1;i&lt;=n;++i)&#123; if(!in[i])&#123; ans=max(dfs(i,0),dfs(i,1)); &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125;int main()&#123;// int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) solve_it(); return 0;&#125;","categories":[],"tags":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"每日总结-1月8日","slug":"1-8","date":"2022-01-08T15:33:25.000Z","updated":"2022-01-10T12:55:12.676Z","comments":true,"path":"2022/01/08/1-8/","link":"","permalink":"http://example.com/2022/01/08/1-8/","excerpt":"","text":"高斯消元与线性基高斯消元与线性基(×) 疯狂查资料搭建博客(√) 使用的是hexo框架+github的方法搭建的博客 前言今天上午去做核酸，请了假，在做完核酸回来之后一直在搞博客，没有进行训练；下午也是大部分时间都在进行个人博客的一个搭建；晚上依然是搭建博客😭。 到了1点钟左右，终于是搭建好了自己的博客。 当然，十分感谢我的好朋友的帮助。不然不知道到什么时候才能搭建好。 慢的原因(其一)我刚开始是跟着我朋友给我发的链接进行一步一步操作的，但是，在进行了无数次的重复操作并且每次都是以失败告终后，我感觉，有问题。 之后去各种地方查找相关资料，最后，在(今晚🤔忘了几点了，总之就很晚，可能快12点吧)的时候，我终于在B站的这个视频中取到了真经。 具体原因就是我刚开始看的教程都是老版的教程，但是最近github有进行这方面的更新 在上传到github上时不能用密钥进行验证了 默认的分支进行修改了 解决方法(其一)(和原版教程相比) 将 _config.yml 文件中的 branch 选项改为 main (之前的教程中这里都是master) 在输入用户名密码验证的输入密码时，不能输入账户的密码，应该输入令牌(令牌设置在下一条)或者使用其他方法进行验证。 令牌的设置 在github中进入 settings 点击 Developer settings 点击 Personal access tokens 新建一个令牌 即可 慢的原因(其二)我在写昨天的那片博客的时候，需要在里面复制一张图片，但是，不管是使用绝对路径还是使用相对路径，在本地的.md文件中可以正常看到图片，但是到网页端就看不到图片。 解决方法(其二)我是看B站上的这个视频进行操作的。 具体的就是 将 _config.yml 文件中的 post_asset_folder 选项设置为 true 下载一个插件 在 \\source\\_posts 路径下进行 Git Bash 输入 npm add https://github.com/CodeFalling/hexo-asset-image 进行下载 之后在.md文件中需要使用图片时，使用相对路径即可 结语不管怎么样，也算是把博客搭建好了，之后会进行博客的美化工作。 如果遇到了类似的困难，可以将本篇博客转发。","categories":[],"tags":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"每日总结:1月7日","slug":"1-7","date":"2022-01-08T14:25:04.000Z","updated":"2022-01-10T12:08:38.040Z","comments":true,"path":"2022/01/08/1-7/","link":"","permalink":"http://example.com/2022/01/08/1-7/","excerpt":"","text":"高斯消元与线性基感觉就是线代里面的矩阵，还有线性相关，这两部分。 今日战况 今日总结A题快要写吐了，但是在写A题的时候把高斯消元理解了不少。甚至快把矩阵类(结构体)给封装好了(bushi)。 把差不多写好的浮点数的矩阵结构体代码放到这里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081struct Matrix&#123; vector&lt;vector&lt;double&gt; &gt; c; int nn,mm; Matrix()&#123; nn=0;mm=0; &#125; Matrix(int nnn,int mmm)&#123; nn=nnn;mm=mmm; c.resize(nnn+1); for(int i=1;i&lt;=nn;++i) c[i].resize(mm+1); &#125; friend Matrix operator*(const Matrix&amp; x,const Matrix&amp; y)&#123; Matrix re(x.nn,y.mm); for(int i=1;i&lt;=x.nn;++i)&#123; for(int j=1;j&lt;=y.mm;++j)&#123; for(int k=1;k&lt;=x.mm;++k)&#123; re.c[i][j]+=(double)((LL)(x.c[i][k]*y.c[k][j])%MOD)+x.c[i][k]*y.c[k][j]-(LL)(x.c[i][k]*y.c[k][j]); re.c[i][j]=(double)((LL)(re.c[i][j])%MOD)+re.c[i][j]-(LL)(re.c[i][j]); &#125; &#125; &#125; return re; &#125; void elimination()&#123; int nm=min(nn,mm); for(int cc=1,r=1;cc&lt;=nm;++cc)&#123; int t=r; for(int i=r+1;i&lt;=nn;++i) if(fabs(c[i][cc])&gt;fabs(c[t][cc])) t=i; if(fabs(c[t][cc])&lt;eps) continue; if(t!=r)&#123; for(int j=cc;j&lt;=mm;++j) swap(c[t][j],c[r][j]); &#125; for(int j=mm;j&gt;=cc;--j) c[r][j]/=c[r][cc]; for(int i=1;i&lt;=nn;++i)&#123; if(i==r) continue; if(fabs(c[i][cc])&gt;eps) for(int j=mm;j&gt;=cc;--j) c[i][j]=c[i][j]-c[i][cc]*c[r][j]; &#125; ++r; &#125; &#125; Matrix inverse() const&#123; Matrix re(this-&gt;nn,this-&gt;mm),temp=*this; temp.mm*=2; for(int i=1;i&lt;=temp.nn;++i)&#123; temp.c[i].resize(temp.mm+1,0); &#125; for(int i=1;i&lt;=temp.nn;++i)&#123; temp.c[i][temp.nn+i]=1; &#125; temp.elimination(); for(int i=1;i&lt;=re.nn;++i) for(int j=1;j&lt;=re.mm;++j)&#123; re.c[i][j]=temp.c[i][re.nn+j]; &#125; return re; &#125; void output()&#123; for(int i=1;i&lt;=nn;++i)&#123; for(int j=1;j&lt;mm;++j)&#123; printf(&quot;%lf &quot;,c[i][j]); &#125; printf(&quot;%lf\\n&quot;,c[i][mm]); &#125; &#125;&#125;; 在后面线性基的学习中，在网上查了不少，也理解的差不多了，感觉就跟线代里面的最大线性不相关向量组(好像叫这名)很像，只不过是变成了二进制的形式。 然后G题里有一个坑(可能并不算坑)，当线性基的元素个数等于n的时候，他们异或得不到0这个结果。 这部分感觉主要就是熟悉理解模板。但是C题实在是看不出来和高斯消元有什么关系，A题也是一直WA，用了两种方法，都是WA。现在也没想出比较好的解决方法。","categories":[],"tags":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-01-08T14:04:51.654Z","updated":"2022-01-08T14:04:51.654Z","comments":true,"path":"2022/01/08/hello-world/","link":"","permalink":"http://example.com/2022/01/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"},{"name":"codeforces-practice","slug":"codeforces-practice","permalink":"http://example.com/tags/codeforces-practice/"}]}