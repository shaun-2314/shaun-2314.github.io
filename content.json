{"meta":{"title":"Shaun","subtitle":"Shaun's blog","description":"welcome","author":"Shaun","url":"http://shaun-2314.github.io","root":"/"},"pages":[{"title":"404","date":"2022-04-15T06:31:56.000Z","updated":"2022-04-15T07:04:15.283Z","comments":true,"path":"404/index.html","permalink":"http://shaun-2314.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-04-15T06:24:29.000Z","updated":"2022-04-15T07:05:05.676Z","comments":true,"path":"categories/index.html","permalink":"http://shaun-2314.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-04-15T06:28:24.000Z","updated":"2022-04-15T07:04:38.191Z","comments":true,"path":"about/index.html","permalink":"http://shaun-2314.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-06-06T15:45:34.000Z","updated":"2022-06-06T15:46:50.860Z","comments":true,"path":"friends/index.html","permalink":"http://shaun-2314.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-04-15T06:29:28.000Z","updated":"2022-04-15T07:05:27.308Z","comments":true,"path":"contact/index.html","permalink":"http://shaun-2314.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-15T06:27:35.000Z","updated":"2022-04-15T07:05:42.401Z","comments":true,"path":"tags/index.html","permalink":"http://shaun-2314.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"redis学习","slug":"redis-learning","date":"2023-07-14T07:58:48.000Z","updated":"2023-07-14T07:59:26.846Z","comments":true,"path":"2023/07/14/redis-learning/","link":"","permalink":"http://shaun-2314.github.io/2023/07/14/redis-learning/","excerpt":"","text":"redis学习redis官网 学习的课程链接 redis是什么redis(==Re==mote ==Di==ctionary ==S==erver)，即远程字典服务 RedisThe open source, in-memory data store used by millions of developers as a database, cache, streaming engine, and message broker. redis是一种基于内存的数据存储程序，经常作为数据库、缓存、流引擎、消息代理等来进行使用。 作为数据库时，是一种典型的NoSQL数据库，NoSQL(Not Only SQL)非关系型数据库。 优点是效率特别高，速度特别快，可用于高速缓存等场景。 下载推荐在linux环境中进行下载使用 来自官网： 注：下面的|并不是表示管道，而是表示这两句都可以，任选其一进行执行即可 Install on Ubuntu/DebianYou can install recent stable versions of Redis from the official packages.redis.io APT repository. Prerequisites If you’re running a very minimal distribution (such as a Docker container) you may need to install lsb-release, curl and gpg first: 1sudo apt install lsb-release curl gpg Add the repository to the apt index, update it, and then install: 123456curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpgecho \"deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/redis.listsudo apt-get updatesudo apt-get install redis 压力测试下载自带的文件 redis-benchmark 可用于进行压力测试。 启用服务端12345# 直接启用，使用默认配置文件redis-server# 使用自定义的配置文件启动# redis-server [配置文件位置]redis-server ./redis.conf 默认的IP为本机，端口为6379，即127.0.0.1:6379 默认有16个数据库，为0 - 15 启用客户端1234567# 直接启用，即对话模式redis-cli# 仅使用一条命令# redis-cli [命令]redis-cli ping# 指定端口redis-cli -p 6379 一些基本命令ping判断是否与服务端连通 如果连通，则回返回一个PONG 12127.0.0.1:6379&gt; pingPONG flushall删除全部数据库中的所有内容 flushdb删除当前数据库中的所有内容 keys使用keys *可以查看所有的key 123127.0.0.1:6379&gt; keys *1) \"b\"2) \"a\" exists判断某个键是否存在 1234567127.0.0.1:6379&gt; keys *1) \"b\"2) \"a\"127.0.0.1:6379&gt; exists a(integer) 1127.0.0.1:6379&gt; exists c(integer) 0 move将一个键值对移动到另一个数据库中 123# move key db127.0.0.1:6379&gt; move a 1(integer) 1 expire对一个键设置过期时间，过了这段时间，这个键就会过期，消失 123# expire key seconds127.0.0.1:6379&gt; expire a 10(integer) 1 ttltime to leave，剩余过期时间 123456789101112131415161718# ttl key127.0.0.1:6379&gt; expire a 10(integer) 1127.0.0.1:6379&gt; ttl a(integer) 8127.0.0.1:6379&gt; ttl a(integer) 6127.0.0.1:6379&gt; ttl a(integer) 2127.0.0.1:6379&gt; ttl a(integer) 1127.0.0.1:6379&gt; ttl a(integer) -2127.0.0.1:6379&gt; keys *1) \"b\"127.0.0.1:6379&gt; ttl b(integer) -1 一个大于0的整数表示还剩几秒，-2表示这个键不存在，-1表示这个键没有设置过期时间。 type查询某个键的数据类型 123# type key127.0.0.1:6379&gt; type bstring del删除一个或一些键 1234567891011121314# del key [key ...]127.0.0.1:6379&gt; keys *1) \"c\"2) \"b\"3) \"a\"127.0.0.1:6379&gt; del a(integer) 1127.0.0.1:6379&gt; keys *1) \"c\"2) \"b\"127.0.0.1:6379&gt; del b c(integer) 2127.0.0.1:6379&gt; keys *(empty array) String字符串类型就是字面意义上的字符串类型 字符串下标是从0开始的 下标-1表示最后一个 set设置一个键的值 12127.0.0.1:6379&gt; set name shaunOK get查询一个键的值 1234127.0.0.1:6379&gt; get name\"shaun\"127.0.0.1:6379&gt; get age(nil) (nil)表示这个键不存在 append字符串拼接，在一个字符串后面拼接上一段字符串，返回值为拼接之后的字符串的长度 1234567# append key value127.0.0.1:6379&gt; get name\"shaun\"127.0.0.1:6379&gt; append name 2314(integer) 9127.0.0.1:6379&gt; get name\"shaun2314\" strlen查询字符串的长度 123# strlen key127.0.0.1:6379&gt; strlen name(integer) 9 incr &amp; decr对于字符串是整数的值，可以使用该命令进行类似于num++或num--的操作 123456789101112127.0.0.1:6379&gt; set num 5OK# incr key127.0.0.1:6379&gt; incr num(integer) 6127.0.0.1:6379&gt; incr num(integer) 7# decr key127.0.0.1:6379&gt; decr num(integer) 6127.0.0.1:6379&gt; decr num(integer) 5 incrby &amp; decrby进行类似于num += i或num -= i的操作 123456789101112127.0.0.1:6379&gt; get num\"5\"# incrby key increment127.0.0.1:6379&gt; incrby num 10(integer) 15127.0.0.1:6379&gt; incrby num 10(integer) 25# decrby key increment127.0.0.1:6379&gt; decrby num 10(integer) 15127.0.0.1:6379&gt; decrby num 10(integer) 5 getrange功能为substring，获取一个字符串的子串 1234567# getrange key start end127.0.0.1:6379&gt; get name\"shaun2314\"127.0.0.1:6379&gt; getrange name 0 1\"sh\"127.0.0.1:6379&gt; getrange name 0 -1\"shaun2314\" 字符串下标是从0开始，start和end表示的是一个闭区间 setrange替换一个字符串的其中的一部分，在此处不能使用-1下标表示最后一个了，且可以向后超出范围 12345678910111213141516171819# setrange key offset value127.0.0.1:6379&gt; get name\"shaun2314\"127.0.0.1:6379&gt; setrange name 2 xx(integer) 9127.0.0.1:6379&gt; get name\"shxxn2314\"127.0.0.1:6379&gt; setrange name -1 xxx(error) ERR offset is out of range127.0.0.1:6379&gt; get name\"shxxn2314\"127.0.0.1:6379&gt; setrange name 9 xxx(integer) 12127.0.0.1:6379&gt; get name\"shxxn2314xxx\"127.0.0.1:6379&gt; setrange name 13 j(integer) 14127.0.0.1:6379&gt; get name\"shxxn2314xxx\\x00j\" setexset with expire，设置一个带有过期时间的字符串 如果这个key之前存在，则会将其覆盖 123456789101112131415161718192021222324252627127.0.0.1:6379&gt; keys *1) \"num\"2) \"b\"3) \"name\"# setex key seconds value127.0.0.1:6379&gt; setex num 10 9OK127.0.0.1:6379&gt; get num\"9\"127.0.0.1:6379&gt; ttl num(integer) 2127.0.0.1:6379&gt; get num(nil)127.0.0.1:6379&gt; keys *1) \"b\"2) \"name\"127.0.0.1:6379&gt; setex num 10 8OK127.0.0.1:6379&gt; get num\"8\"127.0.0.1:6379&gt; ttl num(integer) 5127.0.0.1:6379&gt; ttl num(integer) 1127.0.0.1:6379&gt; get num(nil) setnxset if not exist 如果这个值不存在才会进行设置，如果这个值当时存在，则什么也不做 在分布式锁中经常使用 1234567891011121314127.0.0.1:6379&gt; keys *1) \"a\"2) \"name\"127.0.0.1:6379&gt; get a\"1\"# setnx key value127.0.0.1:6379&gt; setnx a 8(integer) 0127.0.0.1:6379&gt; get a\"1\"127.0.0.1:6379&gt; setnx b 9(integer) 1127.0.0.1:6379&gt; get b\"9\" mget一次性获得多个值 1234567891011127.0.0.1:6379&gt; keys *1) \"b\"2) \"a\"3) \"name\"# mget key [key ...]127.0.0.1:6379&gt; mget a1) \"1\"127.0.0.1:6379&gt; mget a b c1) \"1\"2) \"9\"3) (nil) mset一次性设置多个值 1234567891011127.0.0.1:6379&gt; keys *1) \"a\"2) \"name\"# mset key value [key value ...]127.0.0.1:6379&gt; mset a 3 b 4 c 5OK127.0.0.1:6379&gt; keys *1) \"c\"2) \"b\"3) \"a\"4) \"name\" msetnx一次性设置多个原本不存在的值 注：该操作为原子操作，若其中有一个值之前存在，则整条命令都不会执行成功 1234567891011121314151617181920212223242526127.0.0.1:6379&gt; keys *1) \"c\"2) \"b\"3) \"a\"4) \"name\"# msetnx key value [key value ...]127.0.0.1:6379&gt; msetnx d 8 e 9(integer) 1127.0.0.1:6379&gt; keys *1) \"c\"2) \"b\"3) \"e\"4) \"name\"5) \"d\"6) \"a\"127.0.0.1:6379&gt; msetnx a 7 f 9(integer) 0127.0.0.1:6379&gt; keys *1) \"c\"2) \"b\"3) \"e\"4) \"name\"5) \"d\"6) \"a\"127.0.0.1:6379&gt; get a\"3\" 对象在redis中，可以使用user:1:name这种key的命名方式来表示一个对象的值 user:{id}:{field} 12345678127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379&gt; keys *1) \"user:1:name\"2) \"user:1:age\"127.0.0.1:6379&gt; mget user:1:name user:1:age1) \"zhangsan\"2) \"2\" getset返回这个键的值，并将其赋予新的值 1234567127.0.0.1:6379&gt; keys *(empty array)# getset key value127.0.0.1:6379&gt; getset name zhangsan(nil)127.0.0.1:6379&gt; getset name lisi\"zhangsan\" List列表类型就是列表 无论从哪边，编号都是从0开始，-1表示最后一个节点 lpush头插法插入一个节点，即在左边插入一个节点 123456789# lpush key element [element ...]127.0.0.1:6379&gt; lpush list one(integer) 1127.0.0.1:6379&gt; lpush list two(integer) 2127.0.0.1:6379&gt; lpush list three(integer) 3127.0.0.1:6379&gt; lpush list four five(integer) 5 lrange从左边开始查找列表中的元素 12345678910111213# lrange key start stop127.0.0.1:6379&gt; lrange list 0 01) \"five\"127.0.0.1:6379&gt; lrange list 0 21) \"five\"2) \"four\"3) \"three\"127.0.0.1:6379&gt; lrange list 0 -11) \"five\"2) \"four\"3) \"three\"4) \"two\"5) \"one\" rpush尾插法插入一个节点，即在右边插入一个节点 lpop &amp; rpop弹出头节点和弹出尾节点，并返回节点的值 12345678910111213141516171819# lpop key# rpop key127.0.0.1:6379&gt; lrange list 0 -11) \"five\"2) \"four\"3) \"three\"4) \"two\"5) \"one\"6) \"six\"127.0.0.1:6379&gt; lpop list\"five\"127.0.0.1:6379&gt; lpop list\"four\"127.0.0.1:6379&gt; rpop list\"six\"127.0.0.1:6379&gt; lrange list 0 -11) \"three\"2) \"two\"3) \"one\" lindex获取列表中某一个下标对应的元素的值 1234567891011# lindex key index127.0.0.1:6379&gt; lrange list 0 -11) \"three\"2) \"two\"3) \"one\"127.0.0.1:6379&gt; lindex list 0\"three\"127.0.0.1:6379&gt; lindex list 2\"one\"127.0.0.1:6379&gt; lindex list 3(nil) llen获取列表的长度 123# llen key127.0.0.1:6379&gt; llen list(integer) 3 lrem从左到右移除列表中若干个等于某个值的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445# lrem key count element127.0.0.1:6379&gt; lrange list 0 -1 1) \"c\" 2) \"a\" 3) \"b\" 4) \"a\" 5) \"b\" 6) \"a\" 7) \"a\" 8) \"three\" 9) \"two\"10) \"one\"127.0.0.1:6379&gt; lrem list 1 one(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) \"c\"2) \"a\"3) \"b\"4) \"a\"5) \"b\"6) \"a\"7) \"a\"8) \"three\"9) \"two\"127.0.0.1:6379&gt; lrem list 2 two(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) \"c\"2) \"a\"3) \"b\"4) \"a\"5) \"b\"6) \"a\"7) \"a\"8) \"three\"127.0.0.1:6379&gt; lrem list 1 a(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) \"c\"2) \"b\"3) \"a\"4) \"b\"5) \"a\"6) \"a\"7) \"three\" ltrim保留列表中的某个区间的节点，删除其他节点 123456789101112# ltrim key start stop127.0.0.1:6379&gt; lrange list 0 -11) \"a0\"2) \"a1\"3) \"a2\"4) \"a3\"5) \"a4\"127.0.0.1:6379&gt; ltrim list 2 3OK127.0.0.1:6379&gt; lrange list 0 -11) \"a2\"2) \"a3\" rpoplpush是一个组合命令，移除一个列表中的尾节点，并将这个节点插入到另一个列表的头部 123456789101112127.0.0.1:6379&gt; lrange list 0 -11) \"a2\"2) \"a3\"127.0.0.1:6379&gt; lrange anotherlist 0 -1(empty array)# rpoplpush source destination127.0.0.1:6379&gt; rpoplpush list anotherlist\"a3\"127.0.0.1:6379&gt; lrange list 0 -11) \"a2\"127.0.0.1:6379&gt; lrange anotherlist 0 -11) \"a3\" lset更新一个列表中某个下标的节点的值 需要保证这个节点是存在的，否则会报错 12345678910111213141516171819202122# lset key index element127.0.0.1:6379&gt; lrange list 0 -11) \"a0\"2) \"a1\"3) \"a2\"4) \"a3\"127.0.0.1:6379&gt; lset list 0 itemOK127.0.0.1:6379&gt; lrange list 0 -11) \"item\"2) \"a1\"3) \"a2\"4) \"a3\"127.0.0.1:6379&gt; lset list 2 tempOK127.0.0.1:6379&gt; lrange list 0 -11) \"item\"2) \"a1\"3) \"temp\"4) \"a3\"127.0.0.1:6379&gt; lset list 4 other(error) ERR index out of range linsert将某个值插入到一个列表的某个值的左边或者右边 若列表中不存在该值，则插入失败 12345678910111213141516# linsert key BEFORE|AFTER pivot element127.0.0.1:6379&gt; lrange list 0 -11) \"a0\"2) \"a1\"3) \"a2\"4) \"a3\"127.0.0.1:6379&gt; linsert list before a1 a_new(integer) 5127.0.0.1:6379&gt; lrange list 0 -11) \"a0\"2) \"a_new\"3) \"a1\"4) \"a2\"5) \"a3\"127.0.0.1:6379&gt; linsert list after aa aaa(integer) -1 Set集合类型无序不重复集合 sadd插入一个元素 1234567# sadd key member [member ...]127.0.0.1:6379&gt; sadd myset a0(integer) 1127.0.0.1:6379&gt; sadd myset a1 a2(integer) 2127.0.0.1:6379&gt; sadd myset a0(integer) 0 smembers查询一个集合中的所有元素 12345# smembers key127.0.0.1:6379&gt; smembers myset1) \"a1\"2) \"a0\"3) \"a2\" sismember查询一个值是否存在于一个集合中 12345# sismember key member127.0.0.1:6379&gt; sismember myset a0(integer) 1127.0.0.1:6379&gt; sismember myset a5(integer) 0 scard查询一个集合中的元素个数 123# scard key127.0.0.1:6379&gt; scard myset(integer) 3 srem移除一个集合中的某个或某些指定的元素 12345678910# srem key member [member ...]127.0.0.1:6379&gt; smembers myset1) \"a1\"2) \"a0\"3) \"a2\"127.0.0.1:6379&gt; srem myset a0(integer) 1127.0.0.1:6379&gt; smembers myset1) \"a1\"2) \"a2\" srandmember从一个集合中随机取出一个或多个元素，默认是1个 1234567891011121314151617181920212223242526272829# srandmember key [count]127.0.0.1:6379&gt; smembers myset1) \"a6\"2) \"a2\"3) \"a4\"4) \"a1\"5) \"a0\"6) \"a5\"7) \"a3\"127.0.0.1:6379&gt; srandmember myset\"a1\"127.0.0.1:6379&gt; srandmember myset\"a0\"127.0.0.1:6379&gt; srandmember myset\"a1\"127.0.0.1:6379&gt; srandmember myset\"a6\"127.0.0.1:6379&gt; srandmember myset 31) \"a2\"2) \"a4\"3) \"a1\"127.0.0.1:6379&gt; srandmember myset 31) \"a6\"2) \"a1\"3) \"a0\"127.0.0.1:6379&gt; srandmember myset 31) \"a1\"2) \"a0\"3) \"a3\" spop在一个集合中随机移除一个或多个元素 1234567891011121314151617181920# spop key [count]127.0.0.1:6379&gt; smembers myset1) \"a6\"2) \"a2\"3) \"a4\"4) \"a1\"5) \"a0\"6) \"a5\"7) \"a3\"127.0.0.1:6379&gt; spop myset\"a1\"127.0.0.1:6379&gt; spop myset\"a5\"127.0.0.1:6379&gt; spop myset 21) \"a0\"2) \"a2\"127.0.0.1:6379&gt; smembers myset1) \"a6\"2) \"a4\"3) \"a3\" smove将一个指定的值移动到另一个集合中 123456789101112# smove source destination member127.0.0.1:6379&gt; smembers myset1) \"a6\"2) \"a4\"3) \"a3\"127.0.0.1:6379&gt; smove myset myset2 a3(integer) 1127.0.0.1:6379&gt; smembers myset1) \"a6\"2) \"a4\"127.0.0.1:6379&gt; smembers myset21) \"a3\" sinter &amp; sunion &amp; sdiff分别表示交集、并集、差集 12345678910111213141516171819202122# sinter key [key ...]# sunion key [key ...]# sdiff key [key ...]127.0.0.1:6379&gt; smembers set11) \"a1\"2) \"a0\"3) \"a2\"127.0.0.1:6379&gt; smembers set21) \"a4\"2) \"a3\"3) \"a2\"127.0.0.1:6379&gt; sinter set1 set21) \"a2\"127.0.0.1:6379&gt; sunion set1 set21) \"a4\"2) \"a2\"3) \"a1\"4) \"a0\"5) \"a3\"127.0.0.1:6379&gt; sdiff set1 set21) \"a0\"2) \"a1\" Hash哈希类型即unordered_map hsetset一个或多个具体的key-value 老版本的hset只能设置一组值 12345# hset key field value [field value ...]127.0.0.1:6379&gt; hset myhash name shaun(integer) 1127.0.0.1:6379&gt; hset myhash age 0 some a1(integer) 2 hget获得一个hash的一个指定的值 123# hget key field127.0.0.1:6379&gt; hget myhash name\"shaun\" hmset和hset功能一样，老的版本的hset只能设置一组值 1# hmset key field value [field value ...] hmget获取一个hash中的一组或多组值 1234# hmget key field [field ...]127.0.0.1:6379&gt; hmget myhash name age1) \"shaun\"2) \"0\" hgetall获取一个hash中的所有值 12345678# hgetall key127.0.0.1:6379&gt; hgetall myhash1) \"name\"2) \"shaun\"3) \"age\"4) \"0\"5) \"some\"6) \"a1\" hdel删除一个hash中的几个或多个指定的值 12345678910111213# hdel key field [field ...]127.0.0.1:6379&gt; hgetall myhash1) \"name\"2) \"shaun\"3) \"age\"4) \"0\"5) \"some\"6) \"a1\"127.0.0.1:6379&gt; hdel myhash name some(integer) 2127.0.0.1:6379&gt; hgetall myhash1) \"age\"2) \"0\" hlen获取一个hash的字段数量 12345678# hlen key127.0.0.1:6379&gt; hgetall myhash1) \"age\"2) \"0\"3) \"name\"4) \"shaun\"127.0.0.1:6379&gt; hlen myhash(integer) 2 hexists判断一个hash中某个字段是否存在 123# hexists key field127.0.0.1:6379&gt; hexists myhash name(integer) 1 hkeys &amp; hvals仅获得一个hash中所有的key或value 12345678# hkeys key# hvals key127.0.0.1:6379&gt; hkeys myhash1) \"age\"2) \"name\"127.0.0.1:6379&gt; hvals myhash1) \"0\"2) \"shaun\" hincrby使一个hash中的某个值自增 与string中的incrby类似 1# hincrby key field increment hsetnx与string中的setnx类似 1# hsetnx key field value Zset有序集合类型一个有序集合，需要存入一个pair&lt;int, string&gt;记作&lt;score, member&gt; int用于排序，string用于存内容 zadd添加一个或多个值 12345# zadd key [NX|XX] [CH] [INCR] score member [score member ...]127.0.0.1:6379&gt; zadd myzset 1 a1(integer) 1127.0.0.1:6379&gt; zadd myzset 2 a2 9 a9(integer) 2 zrange查找一个zset中某个区间的值，从小到大 12345# zrange key start stop [WITHSCORES]127.0.0.1:6379&gt; zrange myzset 0 -11) \"a1\"2) \"a2\"3) \"a9\" zrevrange从大到小，查找zset中某个区间的值 12345# zrevrange key start stop [WITHSCORES]127.0.0.1:6379&gt; zrevrange myzset 0 -11) \"a9\"2) \"a2\"3) \"a1\" zrangebyscore通过score进行给定区间的从小到大排序 后面的withscores是指会把score值也输出来 12345678910111213# zrangebyscore key min max [WITHSCORES] [LIMIT offset count]127.0.0.1:6379&gt; zrangebyscore myzset -inf +inf1) \"a1\"2) \"a2\"3) \"a9\"127.0.0.1:6379&gt; zrangebyscore myzset 0 51) \"a1\"2) \"a2\"127.0.0.1:6379&gt; zrangebyscore myzset 0 5 withscores1) \"a1\"2) \"1\"3) \"a2\"4) \"2\" zrem移除一个或多个元素 12345678910# zrem key member [member ...]127.0.0.1:6379&gt; zrange myzset 0 -11) \"a1\"2) \"a2\"3) \"a9\"127.0.0.1:6379&gt; zrem myzset a1(integer) 1127.0.0.1:6379&gt; zrange myzset 0 -11) \"a2\"2) \"a9\" zcard获取有序集合中的元素个数 123# zcard key127.0.0.1:6379&gt; zcard myzset(integer) 2 zcount获取指定区间的成员数量 1234567# zcount key min max127.0.0.1:6379&gt; zrevrange myzset 0 -11) \"a9\"2) \"a2\"3) \"a1\"127.0.0.1:6379&gt; zcount myzset 0 5(integer) 2 Geospatial地理位置类型存每个地方的经纬度 底层实现是使用zset实现的，可以使用zset的相关命令操作该类型 geoadd添加一个或多个位置 南极和北极无法直接添加 12345# geoadd key longitude latitude member [longitude latitude member ...]127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai 106.50 29.53 chongqing(integer) 2 geopos获取一个或多个位置的经纬度 123456789# geopos key member [member ...]127.0.0.1:6379&gt; geopos china:city beijing1) 1) \"116.39999896287918091\" 2) \"39.90000009167092543\"127.0.0.1:6379&gt; geopos china:city beijing shanghai1) 1) \"116.39999896287918091\" 2) \"39.90000009167092543\"2) 1) \"121.47000163793563843\" 2) \"31.22999903975783553\" geodist获取两个位置之间的直线距离 单位：默认为米 m，米 km，千米 ft，英尺 mi，英里 12345# geodist key member1 member2 [m|km|ft|mi]127.0.0.1:6379&gt; geodist china:city beijing shanghai\"1067378.7564\"127.0.0.1:6379&gt; geodist china:city beijing shanghai km\"1067.3788\" georadius通过给定位置和半径进行查询 count为获取指定数量的位置 withdist表示显示距离 123456789# georadius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [A127.0.0.1:6379&gt; georadius china:city 110 30 1000 km1) \"chongqing\"127.0.0.1:6379&gt; georadius china:city 110 30 10000 km1) \"chongqing\"2) \"shanghai\"3) \"beijing\"127.0.0.1:6379&gt; georadius china:city 110 30 10000 km count 11) \"chongqing\" georadiusbymember以一个成员位置为中心，查找给定半径内的位置 1234567# georadiusbymember key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE127.0.0.1:6379&gt; georadiusbymember china:city chongqing 1000 km1) \"chongqing\"127.0.0.1:6379&gt; georadiusbymember china:city chongqing 10000 km1) \"chongqing\"2) \"shanghai\"3) \"beijing\" geohash返回一个位置的经纬度的哈希值 1234# geohash key member [member ...]127.0.0.1:6379&gt; geohash china:city beijing chongqing1) \"wx4fbxxfke0\"2) \"wm5xzrybty0\" Hyperloglog基数统计类型基数：不重复的元素 优点：占用的内存很小 会有误差，但是误差很小，是可以接受的 pfadd添加一个或多个元素 12345# pfadd key element [element ...]127.0.0.1:6379&gt; pfadd mykey a s d d f g h j k l(integer) 1127.0.0.1:6379&gt; pfadd mykey2 z x c v d a a f t w g(integer) 1 pfcount统计基数 123# pfcount key [key ...]127.0.0.1:6379&gt; pfcount mykey(integer) 9 pfmerge合并多个统计集合(并集) 12345# pfmerge destkey sourcekey [sourcekey ...]127.0.0.1:6379&gt; pfmerge mykey3 mykey mykey2OK127.0.0.1:6379&gt; pfcount mykey3(integer) 14 bitmap位图类型按位存储，只有0和1两个状态 setbit设置某个位的值 采用偏移量的下标进行定位 123456789# setbit key offset value127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 1(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0 getbit获取某个位的值 123# getbit key offset127.0.0.1:6379&gt; getbit sign 2(integer) 0 bitcount获取一个bitmap中1的个数 也可以指定区间 123# bitcount key [start end]127.0.0.1:6379&gt; bitcount sign(integer) 3 事务一组命令的集合 注：Redis单条命令具有原子性，但是事务不保证原子性 有一个队列，可以将各条命令加入到队列中 直到输入执行命令之后才会开始执行 一次性、顺序性、排他性 执行一个事务的时候不会被其他命令干扰 流程： 开启事务 命令入队 执行事务 multi开启事务 exec执行事务 1234567891011121314151617# multi -127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set a 1QUEUED127.0.0.1:6379&gt; set b 2QUEUED127.0.0.1:6379&gt; get aQUEUED127.0.0.1:6379&gt; strlen aQUEUED# exec -127.0.0.1:6379&gt; exec1) OK2) OK3) \"1\"4) (integer) 1 discard放弃事务，队列中的命令不会执行 1234567891011# discard -127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set a 1QUEUED127.0.0.1:6379&gt; set s 2QUEUED127.0.0.1:6379&gt; discardOK127.0.0.1:6379&gt; keys *(empty array) 出错 编译型异常 代码编写有问题，命令使用错误，此时，事务中的所有命令都不会执行 1234567891011121314127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set a 1QUEUED127.0.0.1:6379&gt; set s 2QUEUED127.0.0.1:6379&gt; set c(error) ERR wrong number of arguments for 'set' command127.0.0.1:6379&gt; set d 3QUEUED127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get a(nil) 运行时异常 出现了语法性错误，此时，其他命令会正常执行，错误命令会抛出异常 12345678910111213141516171819127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr strQUEUED127.0.0.1:6379&gt; set a 1QUEUED127.0.0.1:6379&gt; set s 2QUEUED127.0.0.1:6379&gt; get aQUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range2) OK3) OK4) \"1\"127.0.0.1:6379&gt; get s\"2\" 此时是因为对字符串进行incr操作而产生异常，其他命令都成功运行。 使用watch实现乐观锁 悲观锁：很悲观，认为什么时候都会出问题，无论做什么都会加锁 乐观锁：很乐观，认为什么时候都不会出问题，不会上锁，只是在更新数据的时候会去判断一下在此期间是否有人修改过这个数据，如判断version watch &amp; unwatch监视 监视一个值，在修改时会去判断在此期间是否有其他人修改多这个数据，如果有人修改过，则不会进行修改 监视的那个值是调用watch时的值，如果在调用watch之后当前进程对这个键的值进行修改，则事务也不会执行 watch是一次性的，在调用一个事务之后，watch即会失效，需要调用unwatch取消监视，再重新调用watch进行监视 只能用于事务 1# watch key [key ...] example 开两个线程，记为线程1和线程2 按顺序执行下列操作 线程1： 123456127.0.0.1:6379&gt; set all 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch allOK 线程2： 1234127.0.0.1:6379&gt; get all\"100\"127.0.0.1:6379&gt; incrby all 100(integer) 200 线程1： 12345678127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby all 20QUEUED127.0.0.1:6379&gt; incrby out 20QUEUED127.0.0.1:6379&gt; exec(nil) 此时，线程1就会执行失败，因为在此期间值all被线程2修改了 失败的解决方法 先解锁，即取消所有监视 再开启监视，即调用watch 再重新开启事务 如果失败，重新开始第1步，直到执行成功 持久化之RDB(Redis DataBase)在手动调用或指定的时间间隔内将内存中的数据集快照写入磁盘，即Snapshot快照，恢复时是直接将快照文件读取到内存中 默认使用RDB进行持久化 存储位置以及自动存储时间间隔等配置可以通过配置文件进行更改，默认存储文件为dump.rdb 12345678# 默认时间间隔save 900 1save 300 10save 60 10000# 默认存储位置# The filename where to dump the DBdbfilename dump.rdb 过程： redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，等持久化过程结束，再使用这个临时文件替换上次持久化好的文件。 整个过程中主进程是不会进行任何IO操作，确保了极高的性能。 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那么RDB就会比AOF方式更高效。 缺点：在最后一次持久化之后的数据可能会丢失 save即手动调用RDB存储 123# save -127.0.0.1:6379&gt; saveOK 可以从server段的输出内容看到保存的情况 12160:M 13 Jul 2023 15:50:33.914 * DB saved on disk160:M 13 Jul 2023 15:51:48.780 * DB saved on disk 保存的触发机制 在配置文件中的配置的情况满足的情况下，会自动触发保存 手动调用save 执行flushall命令 退出redis，也会触发保存 持久化之AOF(Append Only File)以日志的形式来记录每个写操作，将所有的写操作历史记录保存到一个文件中 恢复的时候就是把这个文件中的命令全部再执行一遍 默认是不开启的 1234567# AOF and RDB persistence can be enabled at the same time without problems.# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information.appendonly no 将no改为yes即可开启 文件位置 123# The name of the append only file (default: \"appendonly.aof\")appendfilename \"appendonly.aof\" 默认为appendonly.aof 保存时间间隔 1234567891011121314151617181920212223242526# The fsync() call tells the Operating System to actually write data on disk# instead of waiting for more data in the output buffer. Some OS will really flush# data on disk, some other OS will just try to do it ASAP.## Redis supports three different modes:## no: don't fsync, just let the OS flush the data when it wants. Faster.# always: fsync after every write to the append only log. Slow, Safest.# everysec: fsync only one time every second. Compromise.## The default is \"everysec\", as that's usually the right compromise between# speed and data safety. It's up to you to understand if you can relax this to# \"no\" that will let the operating system flush the output buffer when# it wants, for better performances (but if you can live with the idea of# some data loss consider the default persistence mode that's snapshotting),# or on the contrary, use \"always\" that's very slow but a bit safer than# everysec.## More details please check the following article:# http://antirez.com/post/redis-persistence-demystified.html## If unsure, use \"everysec\".# appendfsync alwaysappendfsync everysec# appendfsync no 默认为everysec，即每秒保存 如果这个文件有错误，如被恶意修改，此时，redis是启动不起来的，需要修复这个appendonly.aof文件 redis给我们提供了一个工具 1redis-check-aof --fix appendonly.aof 如果恢复成功，则可正常启动 当两种持久化都开启时，启动redis时会优先载入aof方法的文件 订阅发布就类似于B站中的关注功能，可以订阅up主，up主可以发布动态，所有的粉丝都会收到动态（消息） subscribe订阅一个或多个频道 123456# subscribe channel [channel ...]127.0.0.1:6379&gt; subscribe shaunReading messages... (press Ctrl-C to quit)1) \"subscribe\"2) \"shaun\"3) (integer) 1 执行完这个命令之后就会开始读取推送的信息 publish发布内容（发布动态） 12345# publish channel message127.0.0.1:6379&gt; publish shaun hello(integer) 1127.0.0.1:6379&gt; publish shaun world(integer) 1 之后订阅这个频道的所有客户端都会收到这个消息 123456789101112# 订阅这个频道的客户端127.0.0.1:6379&gt; subscribe shaunReading messages... (press Ctrl-C to quit)1) \"subscribe\"2) \"shaun\"3) (integer) 11) \"message\"2) \"shaun\"3) \"hello\"1) \"message\"2) \"shaun\"3) \"world\" 主从复制指的是：将一台redis服务器上的数据，复制到其他redis服务器上。前者称为主节点(master/leader)，后者称为从节点(slave/follower) 数据的复制时单向的，只能从主节点到从节点 master以写为主，slave以读为主 默认情况下，每台redis服务器都是主节点 一个主节点可以有零个或多个从节点，但一个从节点只能有一个主节点 主要作用 数据冗余：实现了数据的热备份，是持久化之外的一种数据冗余方式 故障恢复：主节点出现问题时，可以由从节点提供服务 负载均衡：在主从复制的基础上，配合读写分离，可以主节点提供写服务，从节点提供读服务，分担服务器负载。可以大大提高redis服务器的并发量 高可用(集群)基石：主从复制是哨兵和集群能够实施的基础 配置只需要配置从节点，主节点不需要配置，因为每个节点都默认是主节点 查看当前节点的信息 123456789101112127.0.0.1:6379&gt; info replication# Replicationrole:master # 角色 masterconnected_slaves:0 # 连接的从机的数量master_replid:fcd48402e5c2c4779693d9999a84c3476ed22749master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0 example 一主两从，在此使用本机进行配置 首先创建3个配置文件，这里以端口进行命名 12shaun@DESKTOP-JJRTDBP:~/redis/colony$ lsredis_master_6379.conf redis_slave_6380.conf redis_slave_6381.conf 之后需要对这三个配置文件进行对应的更改 主要注意的几个配置项： bind，连接的主机地址 port，连接的端口 pidfile，pid文件 logfile，日志文件 dbfilename，使用rdb进行持久化时需要有自己的dump.rdb文件，不能重复 redis_master_6379.conf 12345bind 127.0.0.1 ::1port 6379pidfile /var/run/redis/redis-server_6379.pidlogfile ./log/redis-server_6379.logdbfilename dump_6379.rdb redis_slave_6380.conf 12345bind 127.0.0.1 ::1port 6380pidfile /var/run/redis/redis-slave_6380.pidlogfile ./log/redis-slave_6380.logdbfilename dump_6380.rdb redis_slave_6381.conf 12345bind 127.0.0.1 ::1port 6381pidfile /var/run/redis/redis-slave_6381.pidlogfile ./log/redis-slave_6381.logdbfilename dump_6381.rdb 配置好之后分别开启这几个服务端 我这里只能在root权限下才能成功开启服务 可以使用这个命令查看进程信息 12345shaun@DESKTOP-JJRTDBP:~/redis/colony$ ps -ef | grep redisroot 556 9 0 11:16 ? 00:00:00 redis-server 127.0.0.1:6379root 576 9 0 11:17 ? 00:00:00 redis-server 127.0.0.1:6380root 582 9 0 11:17 ? 00:00:00 redis-server 127.0.0.1:6381shaun 588 281 0 11:17 pts/3 00:00:00 grep --color=auto redis 启动之后，可以启动客户端连接服务端，并使用info replication查看主机状态 1234567891011121314151617181920212223242526272829303132333435363738394041# 6379127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:0master_replid:f6a6b4b59c7cbc6225a04babaca578309cc7dcdcmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0# 6380127.0.0.1:6380&gt; info replication# Replicationrole:masterconnected_slaves:0master_replid:fd20fbf6c2d1d6acd1ba342cb19d993d27d9d637master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0# 6381127.0.0.1:6381&gt; info replication# Replicationrole:masterconnected_slaves:0master_replid:fd5c40ad7c157b8dddc52524b9e33944f55fc707master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0 默认三个服务端都是主节点，需要我们去配置从节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# slaveof host port# 在从节点中使用该命令，表示作谁的从节点# 6380127.0.0.1:6380&gt; slaveof 127.0.0.1 6379OK127.0.0.1:6380&gt; info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:10master_sync_in_progress:0slave_repl_offset:140slave_priority:100slave_read_only:1connected_slaves:0master_replid:d9254af02b5bc2603e53c14cfbe20602f7b10374master_replid2:0000000000000000000000000000000000000000master_repl_offset:140second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:140# 6381127.0.0.1:6381&gt; slaveof 127.0.0.1 6379OK127.0.0.1:6381&gt; info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:6master_sync_in_progress:0slave_repl_offset:770slave_priority:100slave_read_only:1connected_slaves:0master_replid:d9254af02b5bc2603e53c14cfbe20602f7b10374master_replid2:0000000000000000000000000000000000000000master_repl_offset:770second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:771repl_backlog_histlen:0 可以在从节点中看到主节点的信息 配置好之后，查看主节点的info replication 123456789101112131415# 6379127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip=127.0.0.1,port=6380,state=online,offset=798,lag=1slave1:ip=127.0.0.1,port=6381,state=online,offset=798,lag=1master_replid:d9254af02b5bc2603e53c14cfbe20602f7b10374master_replid2:0000000000000000000000000000000000000000master_repl_offset:798second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:798 也可以在主节点中看到两个从节点的信息 以上是使用命令进行配置的，实际上应该是需要在配置文件中进行配置 在配置文件中，有REPLICATION字段 1# replicaof &lt;masterip&gt; &lt;masterport&gt; 在此进行配置即可 主节点可以进行读和写的操作，但是从节点只能进行读操作，无法进行写操作 只要从机连接到主机，就会触发一次全量复制，即主节点会把所有数据传输到从节点一次。之后会进行增量复制，即每次写操作都会向从节点传输一次。 宕机主节点宕机之后手动配置的流程 这时候需要将一个从节点变成主节点 首先执行slaveof no one来将一个从节点变成主节点 123456789101112131415# 6380127.0.0.1:6380&gt; slaveof no oneOK127.0.0.1:6380&gt; info replication# Replicationrole:masterconnected_slaves:0master_replid:ad9330d14b3efb752103cb0cdbddb565fbf1f7c7master_replid2:d9254af02b5bc2603e53c14cfbe20602f7b10374master_repl_offset:3494second_repl_offset:3495repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:3494 此时，其他节点就可以手动连接到这个新的主节点了 哨兵(自动选举老大) 哨兵是一个独立的进程，哨兵会通过发送命令的方式，检查redis服务器是否有响应，以此来判断服务器是否出现故障。 程序redis-sentinel为哨兵 需要先配置哨兵的配置文件，之后启动这个程序即可自动开始监控 我这里电脑上下载的没有redis-sentinel，无法进行实际练习 缓存穿透概念 用户查询一个数据，如果redis缓存中没有，就会持续向持久层数据库发起查询，发现也没有，即查询失败。如果很多用户都同时持续发生这种情况，就会给持久层数据库造成很大的压力，即缓存穿透 解决方法 布隆过滤器 布隆过滤器是一种数据结构，对所有可能的查询的参数以hash形式存储，在控制层进行校验，如果一个查询不符合，则会丢弃，以此来避免对底层存储系统的查询压力 缓存空对象 当存储层不命中后，即使返回的是空对象也缓存起来，并设置一个过期时间，之后再访问这个数据就会从缓存中进行获取，保护了后端数据源 缺点：存储空值也会消耗空间，空间浪费；即使有过期时间，也有可能会存在缓存层和存储层的数据会有一段时间窗口的不一致 缓存击穿概念有一个非常热的热点，不停的扛着大并发，并且这个大并发集中对一个点进行访问，当缓存中的这个key过期的一瞬间，持续的大并发就会穿破缓存，直接请求数据库，就像在一个点击穿一样，如果服务器没有扛住，就会出现宕机了 解决方法 设置热点数据永不过期 使用分布式锁 缓存雪崩概念指某一个时间段，缓存中的数据集中过期，或者缓存服务器宕机，断电 此时所有的请求都会到达底层存储 解决方法 redis高可用 即多增几台服务器 限流降级 如停掉一些其他服务，保证这个服务可用 数据预热 在正式部署之前，把可能的数据先访问一遍，以加载到缓存中，手动设置不同的过期时间","categories":[{"name":"redis","slug":"redis","permalink":"http://shaun-2314.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://shaun-2314.github.io/tags/redis/"},{"name":"数据库","slug":"数据库","permalink":"http://shaun-2314.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"scrapy框架学习","slug":"crawler-scrapy","date":"2023-06-26T09:35:30.000Z","updated":"2023-06-30T16:26:35.744Z","comments":true,"path":"2023/06/26/crawler-scrapy/","link":"","permalink":"http://shaun-2314.github.io/2023/06/26/crawler-scrapy/","excerpt":"","text":"scrapy框架学习整体框架 下载12pip install scrapyscrapy version 创建scrapy项目1scrapy startproject test 文件目录： spiders中存放爬虫 middelwares.py为中间件文件，很重要 pipelines.py为管道文件，用于文件的传输和存储方法 settings.py为配置文件 运行项目运行单个爬虫 12# scrapy crawl 爬虫名scrapy crawl bilibili 创建爬虫12# scrapy genspider \"爬虫名字\" \"限制域名\"scrapy genspider bilibili bilibili.com 此操作将在spiders文件夹中创建bilibili.py文件 需要重写里面的parse函数 爬取文章名称和url12345678with open(\"shaun.txt\", \"w\", encoding=\"utf-8\") as f: article = response.xpath(\"//article\") card_list = article.xpath(\"./div/div/div[@class = 'card']\") for card in card_list: title = card.xpath(\"./a/div/span/text()\").extract_first() href = card.xpath(\"./a/@href\").extract_first() url = response.urljoin(href) f.write(f\"{title}, {url}\\n\") 爬虫重写新建爬虫中的parse函数该函数是用于处理返回的数据 可以使用yield 'data' 进行向管道传递数据，’data’需要替换为具体的数据。 也可以在该方法中直接调用一些接口进行储存 1234567class BilibiliSpider(scrapy.Spider): name = \"bilibili\" allowed_domains = [\"bilibili.com\"] start_urls = [\"https://bilibili.com\"] def parse(self, response): print(response.text()) 对于爬取到的url继续进行爬取使用yield scrapy.Request进行实现 1 管道在pipeline中完成数据传输12345class 类名: def process_item(self, item, spider): # item: 数据 # spider: 爬取这个数据的爬虫 returnitem 将数据存入文件关于将数据存到文件里的情况，若每次存一条数据都打开文件再关闭，效率过低 因此，需要在开始存数据之前打开文件，在所有数据存好了之后再关闭 scrapy框架中给了两个方法可以进行重载，以完成上述功能 12345678910111213class CaipiaoPipeline: def open_spider(self, spider): self.f = open(\"./data.csv\", \"a\", encoding = \"utf-8\") def close_spider(self, spider): if self.f: self.f.close() def process_item(self, item, spider): # item: 数据 # spider: 爬取这个数据的爬虫 self.f.write(f\"{item['qihao']}, {'_'.join(item['red_ball'])}, {item['blue_ball']}\\n) return item 将数据存入数据库思路和上面一样，只是把那两个函数的实现改成连接数据库和关闭数据库即可。","categories":[{"name":"python爬虫学习","slug":"python爬虫学习","permalink":"http://shaun-2314.github.io/categories/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://shaun-2314.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://shaun-2314.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"scrapy","slug":"scrapy","permalink":"http://shaun-2314.github.io/tags/scrapy/"}]},{"title":"爬虫基础","slug":"crawler-base","date":"2023-06-21T07:06:31.000Z","updated":"2023-06-30T16:19:14.261Z","comments":true,"path":"2023/06/21/crawler-base/","link":"","permalink":"http://shaun-2314.github.io/2023/06/21/crawler-base/","excerpt":"","text":"python 爬虫基础从站点获得数据需要使用到 requests 这个库 requests 库下载1pip install requests 使用方法123456789101112import requests# 这个header是我的电脑的User-Agentheaders = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36\"}# response = requests.get(\"目标网址\", 其他条件(如自定义各个请求头的值))response = requests.get(f\"https://movie.douban.com/top250?start={start}&amp;filter=\", headers = headers)# response是一个类，包含返回的各种数据html = response.text# html即为服务器返回的html文件的内容# html也是一个类 对从站点获得的数据进行加工处理需要使用 BeautifulSoup 函数，在库 bs4 中 bs4 库下载1pip install bs4 使用方法导入 1from bs4 import BeautifulSoup BeautifulSoup 函数能够把从上一步得到的 html 加工成一个树结构，方便后面的操作。 12# 第二个参数用来指定解析器soup = BeautifulSoup(html, \"html.parser\") 之后可以使用 findAll 函数进行具体内容的查找 1234567# 第一个参数为查找的标签，第二个参数为限制条件all_names = soup.findAll(\"span\", attrs = {\"class\": \"title\"})for name in all_names: if \"/\" not in str(name.string): id = id + 1 f.write(str(id) + \": \" + str(name.string) + '\\n') 实例获取豆瓣TOP250的中文名字123456789101112131415161718import requestsfrom bs4 import BeautifulSoupwith open(\"douban.txt\", \"w\", encoding = \"utf-8\") as f: headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36\"} id = 0 for start in range(0, 250, 25): response = requests.get(f\"https://movie.douban.com/top250?start={start}&amp;filter=\", headers = headers) html = response.text soup = BeautifulSoup(html, \"html.parser\") all_names = soup.findAll(\"span\", attrs = {\"class\": \"title\"}) for name in all_names: if \"/\" not in str(name.string): id = id + 1 f.write(str(id) + \": \" + str(name.string) + '\\n')","categories":[{"name":"python爬虫学习","slug":"python爬虫学习","permalink":"http://shaun-2314.github.io/categories/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://shaun-2314.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://shaun-2314.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"数据库sqlite3学习","slug":"sqlite3-learning","date":"2023-05-16T02:32:18.000Z","updated":"2023-05-16T08:24:14.399Z","comments":true,"path":"2023/05/16/sqlite3-learning/","link":"","permalink":"http://shaun-2314.github.io/2023/05/16/sqlite3-learning/","excerpt":"","text":"数据库sqlite3学习笔记选择sqlite3的原因 数据库课程 CMU 15-445 的作业所使用的数据库系统。 学习来源 tutorialspoint学习网站 下载各操作系统的下载教程及链接 sqlite3的基础命令 在shell中使用 sqlite3 或 sqlite3 test.db 进入数据库 在数据库系统中 .help 帮助 .databases 列出所有的数据库文件 .exit 和 .quit 均为退出数据库系统 .table 列出该数据库系统中所有的表 .schema table_name table_name为表的名字，显示出该表的内部结构 .show 显示出当前的配置设置信息 sqlite3对大小写不敏感如题，select与SELECT等价。 数据类型 NULL INTEGER 整数，视数据大小储存在1, 2, 3, 4, 6, 8个比特位中 REAL 8比特浮点数 TEXT 即string BLOB The value is a blob of data, stored exactly as it was input. 翻译：该值是一个数据团，完全按照输入的方式存储。 sqlite3数据库语法 创建，导出，导入 可直接在shell中sqlite3 test.db即可创建新的数据库 sqlite3 testDB.db .dump &gt; testDB.sql即将 testDB.db 导出为 testDB.sql sqlite3 testDB.db &lt; testDB.sql即使用 testDB.sql 创建 testDB.db ATTACH DETACH CREATE table 在数据库中创建一个新表格 1234567CREATE TABLE database_name.table_name( column1 datatype PRIMARY KEY(one or more columns), column2 datatype, column3 datatype, ..... columnN datatype); Example: 1234567sqlite&gt; CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL); DROP table 删除一个表格 1DROP TABLE database_name.table_name; Example: 1sqlite&gt;DROP TABLE COMPANY; INSERT 在一个表格中插入一行数据 12INSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)] VALUES (value1, value2, value3,...valueN); 1INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN); Example: 12INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (1, 'Paul', 32, 'California', 20000.00 ); 1INSERT INTO COMPANY VALUES (7, 'James', 24, 'Houston', 10000.00 ); SELECT 查数据 1SELECT column1, column2, columnN FROM table_name; 1SELECT * FROM table_name; 这个更多是和WHERE进行搭配使用 运算符 算术运算符 +, -, *, /, \\%$ 加，减，乘，除，取模 比较运算符 ==, =, !=, &lt;&gt;, &gt;, &lt;, &gt;=, &lt;=, !&lt;, !&gt; 均为字面意思，其中 $&lt;&gt;$ 和 $!=$ 等价 逻辑运算符 AND, BETWEEN, EXISTS, IN, NOT IN, LIKE, GLOB, NOT, OR, IS NULL, IS, IS NOT, ||, UNIQUE 其中||用于连接两个字符串 位运算符 &amp;, |, ~, &lt;&lt;, &gt;&gt; 如字面意思 WHERE 条件语句，用于限定条件，可用于SELECT, UPDATE, DELETE等语句中。 123SELECT column1, column2, columnN FROM table_nameWHERE [condition] Example: 1SELECT * FROM COMPANY WHERE NAME LIKE 'Ki%'; AND &amp; OR 用于连接条件语句 123SELECT column1, column2, columnN FROM table_nameWHERE [condition1] AND [condition2]...AND [conditionN]; OR与其类似 UPDATE 修改数据 123UPDATE table_nameSET column1 = value1, column2 = value2...., columnN = valueNWHERE [condition]; Example: 1sqlite&gt; UPDATE COMPANY SET ADDRESS = 'Texas' WHERE ID = 6; DELETE 删除数据 12DELETE FROM table_nameWHERE [condition]; Example: 1sqlite&gt; DELETE FROM COMPANY WHERE ID = 7; LIKE 用于字符串或数字匹配，不区分大小写 %表示任何数量的字符或数字 _表示一个字符或数字 12345678SELECT FROM table_nameWHERE column LIKE 'XXXX%'or SELECT FROM table_nameWHERE column LIKE '%XXXX%'orSELECT FROM table_nameWHERE column LIKE 'XXXX_' Example: 12sqlite&gt; SELECT * FROM COMPANY WHERE AGE LIKE '2%';sqlite&gt; SELECT * FROM COMPANY WHERE ADDRESS LIKE '%-%'; GLOB 用于字符串或数字匹配，区分大小写 *表示任何数量的字符或数字 ?表示一个字符或数字 用法与 LIKE 一致。 LIMIT 限制输出的行数及偏移量 123SELECT column1, column2, columnN FROM table_nameLIMIT [no of rows] 123SELECT column1, column2, columnN FROM table_nameLIMIT [no of rows] OFFSET [row num] Example: 1sqlite&gt; SELECT * FROM COMPANY LIMIT 6; 1sqlite&gt; SELECT * FROM COMPANY LIMIT 3 OFFSET 2; ORDER BY 用于给输出的数据排序 1234SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC]; ASC为从上到下递增 DESC为从上到下递减 默认为ASC Example: 1sqlite&gt; SELECT * FROM COMPANY ORDER BY SALARY ASC; 1sqlite&gt; SELECT * FROM COMPANY ORDER BY NAME, SALARY ASC; GROUP BY 给输出的数据分组 位于WHERE语句的末尾，ORDER BY语句之前 12345SELECT column-listFROM table_nameWHERE [ conditions ]GROUP BY column1, column2....columnNORDER BY column1, column2....columnN Example: 123456789101112ID NAME AGE ADDRESS SALARY---------- ---------- ---------- ---------- ----------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.07 James 24 Houston 10000.08 Paul 24 Houston 20000.09 James 44 Norway 5000.010 James 45 Texas 5000.0 1234567891011sqlite&gt; SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME ORDER BY NAME;NAME SUM(SALARY)---------- -----------Allen 15000David 85000James 20000Kim 45000Mark 65000Paul 40000Teddy 20000 HAVING HAVING是针对于GROUP BY进行条件过滤的 需要位于GROUP BY的后面，位于ORDER BY的前面。 123456SELECT column1, column2FROM table1, table2WHERE [ conditions ]GROUP BY column1, column2HAVING [ conditions ]ORDER BY column1, column2 Example: 12345sqlite &gt; SELECT * FROM COMPANY GROUP BY name HAVING count(name) &gt; 2;ID NAME AGE ADDRESS SALARY---------- ---------- ---------- ---------- ----------10 James 45 Texas 5000 DISTINCT 去重，将输出的结果进行去重 123SELECT DISTINCT column1, column2,.....columnN FROM table_nameWHERE [condition]","categories":[{"name":"sql","slug":"sql","permalink":"http://shaun-2314.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://shaun-2314.github.io/tags/sql/"},{"name":"sqlite3","slug":"sqlite3","permalink":"http://shaun-2314.github.io/tags/sqlite3/"}]},{"title":"二面阿里广告营销部门的引擎架构团队","slug":"Job-interview-alibaba-ad-second","date":"2023-05-12T07:10:05.000Z","updated":"2023-05-14T02:58:07.579Z","comments":true,"path":"2023/05/12/job-interview-alibaba-ad-second/","link":"","permalink":"http://shaun-2314.github.io/2023/05/12/job-interview-alibaba-ad-second/","excerpt":"","text":"二面阿里广告营销部门的引擎架构团队面的是研发工程师C/C++ 没回答上来的问题 new和malloc的区别(底层区别) malloc是C语言中申请内存的函数，这个函数实现的功能是仅仅申请大小为 $size$ 的空间，并返回 $void*$ 类型。 而new是C++语言中创建一个新的对象的关键字，new同样也完成申请内存的功能，但是new不需要指定具体内存大小，new会通过对象的类型来计算出需要申请的空间的大小。 最大的区别：new在申请完空间之后会调用对象的构造函数，而malloc是仅仅申请空间，不会调用构造函数。 同样，delete会在调用对象的析构函数之后将空间释放掉，而free是仅仅释放空间。 vector和queue的内部实现区别 vector的底层实现，vector扩容时调用复制构造函数吗 map和unordered_map的区别，内部实现，以及在什么情况下使用哪个，在什么数量级上使用哪个 linux中进程和线程的相同点及区别，更深层次的 对我的建议 我对stl底层实现还是很不熟悉，建议我多了解了解stl底层实现 去了解了解linux中的数据结构 问的问题 语言方面 谈一谈对static和const的理解 谈一谈对new和malloc的理解，以及区别，底层实现的区别 谈一谈对vector和queue的理解，也是更深层次的，并提问了关于这方面的问题 谈一谈对map和unordered_map的理解，也是深层次，并提问了关于这方面的问题 操作系统方面 谈一谈对linux中进程和线程的相同点及区别 现场编程 给了一道题(力扣上的原题) 给定一个字符串，求这个字符串中“不含相同字母的最长的字串”。 我的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051输入: s = \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。输入: s = \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1const int MAXN = 100005;char s[MAXN];int n;int solve() { scanf(\"%s\", s + 1); n = strlen(s + 1); if(n == 0) return 0; int ans = 1; int l = 1, r = 1; int flag = 0;0000000000000-&gt;a0000000000001-&gt;b0000000000011 flag |= 1 &lt;&lt; (s[1] - 'a'); while(r &lt; n) { if(flag &amp; (1 &lt;&lt; (s[r + 1] - 'a'))) { while(s[l] != s[r + 1]) { flag ^= 1 &lt;&lt; (s[l] - 'a'); ++l; } ++l; } ++r; flag |= 1 &lt;&lt; (s[r] - 'a'); ans = max(ans, r - l + 1); } return ans;} 感觉这个部分对我挺加分的，写完之后，面试官问我关于flag优化的东西，说对这个flag很感兴趣，让我讲一下这个。 我问他问题 后面还会有几轮面试，以及面试的性质 后面还会有1-2轮面试，大概一周两周内可能会来找我，依然是技术面，之后可能还会有一场HR面。 对我的建议 在上面 总结感觉印象还是挺好的，但是我对stl的底层还是不太熟悉，以及操作系统的底层，需要去了解一下这些。","categories":[{"name":"面试","slug":"面试","permalink":"http://shaun-2314.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://shaun-2314.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"阿里巴巴","slug":"阿里巴巴","permalink":"http://shaun-2314.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"}]},{"title":"一面阿里广告营销部门的引擎架构团队","slug":"Job-interview-alibaba-ad-first","date":"2023-05-08T07:46:05.000Z","updated":"2023-05-12T07:48:40.747Z","comments":true,"path":"2023/05/08/job-interview-alibaba-ad-first/","link":"","permalink":"http://shaun-2314.github.io/2023/05/08/job-interview-alibaba-ad-first/","excerpt":"","text":"一面阿里广告营销部门的引擎架构团队面的是研发工程师C/C++ 没回答上来的问题 C++的几种构造函数 默认构造函数 普通构造函数 复制构造函数(拷贝构造函数) 赋值构造函数(转换构造函数) C++类成员的初始化顺序是按照初始化列表的顺序进行初始化的吗 是严格按照成员变量的声明顺序进行初始化的。 1234class Node { int a, b; Node(int aa, int bb) : b(bb), a(aa) {}}; 在这种情况下，是先初始化 $a$ ，再初始化 $b$ 。 复制构造函数为什么参数必须是引用类型的 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。 写代码的时候需要new一个数组，但是我忘记了如何使用new进行申请一段连续的空间。 1234567int *a = new int;int *b = new int(4);//赋值为4int *c = new int[5];//申请长度为5个int的空间delete a;delete b;delete[] c; 问的问题 语言方面 对C++中static关键字的理解 对C++中各种构造函数的理解 对C++中类的继承的理解 以及多态的用法 操作系统方面 关于虚拟内存从上到下排序啥的？(不太记得了) 我当时回答是还没学到这一块。 关于多线程同时改变一个变量？(好像是) 我的回答是使用互斥锁，然后问我还有什么方法，我说可能还有信号，但是我只用过互斥锁。 关于一个场景，多个人需要从一个地方进行读和写，如何实现多个人同时进行读，并且有人写的时候没有人读。 我的回答是使用信号，比如semaP和semaV这种的信号调用。就是在cs162课程中第9节课讲到的具体例子。接着对这个场景的实现进行了详细的描述。 现场编程 给了一个场景，如果要实现一个string类，使用的是一段连续的空间，并且只有两个变量：这段连续空间的首地址、长度。 写一个构造函数。 写一个复制构造函数。 刚开始在用new进行申请空间，但是写着写着忘了怎么用new申请一段连续的空间了，就跟面试官说忘了怎么使用new了，因为最近使用的一直是malloc进行申请空间，然后面试官就让我用malloc进行实现了，并且还提醒了我使用配套的函数进行空间的释放。 然后写完这部分之后问我有没有什么bug，然后给我说了一个场景，a = a的时候会出问题，会把原本的空间给释放掉。 写一个赋值构造函数。 我当时不记得赋值构造函数是什么了，就没写。 然后问我为什么写复制构造函数的时候必须使用引用变量，我没回答出来。 我当时写的 123456789101112131415161718192021222324252627282930class my_string {private: char *st; int len;public: my_string() { st = nullptr; len = 0; } my_string(mystring &amp;s) const { if(this-&gt;st == s.get_st()) return; if(st != nullptr) free(st); // this-&gt;st = new char[s.get_len()]; this-&gt;st = (char*)malloc(sizeof(char) * s.get_len()); this-&gt;len = s.get_len(); // strcpy(this-&gt;st, s.get_st()); for(int i = 0; i &lt; len; ++i) { this-&gt;st[i] = s.get_st()[i]; } } char* get_st() { return st; } int get_len() { return len; }}; 给出两个有序的单向链表，把这两个链表合并成为一个链表，并保持有序。 提醒了我如果一个链表已经结束，就可以直接break掉了。 当时写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Node {public: int val; Node *next;};Node *merge(Node *a, Node *b) { if(a == nullptr) { if(b == nullptr) { return nullptr; } return b; } else if(b == nullptr) { return a; } Node *ret, *now; if(a-&gt;val &lt; b-&gt;val) { now = ret = a; a = a-&gt;next; } else { now = ret = b; b = b-&gt;next; } while((a != nullptr) || (b != nullptr)) { if(a == nullptr) { now-&gt;next = b; break; // now = b; // b = b-&gt;next; // continue; } else if(b == nullptr) { now-&gt;next = a; break; // now = a; // a = a-&gt;next; // continue; } if(a-&gt;val &lt; b-&gt;val) { now-&gt;next = a; now = a; a = a-&gt;next; } else { now-&gt;next = b; now = b; b = b-&gt;next; } } return ret;} 问了一下关于二叉树的几种遍历方式，然后说还有一种遍历方式是按层来遍历，然后我简单说了一下实现方法，说还没有写过这种的，然后就让我现场实现一下。 这一部分没有什么问题。 当时写的代码 123456789101112131415161718192021222324252627282930class tree_node {public: int val; tree_node *left, *right;}void func(tree_node *root) { if(root == nullptr) return; queue&lt;tree_node*&gt; q; q.emplace(root); while(!q.empty()) { tree_node *now = q.front(); q.pop(); printf(\"%d \", now-&gt;val); if(now-&gt;left != nullptr) { q.emplace(now-&gt;left); } if(now-&gt;right != nullptr) { q.emplace(now-&gt;right); } } printf(\"\\n\"); return;} 总结最后面试官给我介绍了他们部门和他们团队主要是做什么的，然后问了我之后是否要考研，然后是问我还有什么问题没有，让我进行提问。","categories":[{"name":"面试","slug":"面试","permalink":"http://shaun-2314.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://shaun-2314.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"阿里巴巴","slug":"阿里巴巴","permalink":"http://shaun-2314.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"}]},{"title":"cs162作业hw-shell","slug":"cs162-hw-shell","date":"2023-05-05T00:24:34.000Z","updated":"2023-05-17T02:57:33.906Z","comments":true,"path":"2023/05/05/cs162-hw-shell/","link":"","permalink":"http://shaun-2314.github.io/2023/05/05/cs162-hw-shell/","excerpt":"","text":"cs162作业hw-shellhw-shell 在给出的架构中使用c语言实现一个shell，完成内置函数”pwd, cd”，运行已有程序，运行环境变量中的程序，输入输出重定向，管道，信号处理的功能。 内置函数(Directory commands)使用结构体 $fun_desc$ 封装内置函数，使用 $cmd_table$ 数组来标识每一个内置函数。 12345678910111213141516/* Built-in command functions take token array (see parse.h) and return int */typedef int cmd_fun_t(struct tokens* tokens);/* Built-in command struct and lookup table */typedef struct fun_desc { cmd_fun_t* fun; char* cmd; char* doc;} fun_desc_t;fun_desc_t cmd_table[] = { {cmd_help, \"?\", \"show this help menu\"}, {cmd_exit, \"exit\", \"exit the command shell\"}, {cmd_pwd, \"pwd\", \"print the current working directory to standard output\"}, {cmd_cd, \"cd\", \"change the current working directory to that directory\"},}; 其中 $cmd_help$ 和 $cmd_exit$ 是已经实现好的，$cmd_pwd$ 和 $cmd_cd$ 的实现如下 123456789101112131415161718192021222324252627//Print the current working directory to standard outputint cmd_pwd(struct tokens* tokens) { char *buffs = getcwd(NULL, 0); printf(\"%s\\n\", buffs); free(buffs); return 1;}//Change the current working directory to that directoryint cmd_cd(struct tokens* tokens) { const char HOME_PATH[14] = \"/home/vagrant\"; if(tokens_get_length(tokens) == 1) { chdir(HOME_PATH); } else if(tokens_get_length(tokens) == 2 &amp;&amp; strcmp(tokens_get_token(tokens, 1), \"~\") == 0) { chdir(HOME_PATH); } else { int failed = chdir(tokens_get_token(tokens, 1)); if(failed) { printf(\"error\\n\"); } } return 1;} 运行已有程序(Program Execution)使用 $execv$ 函数进行实现。 $execv$ 函数原型 1int execv(const char *pathname, char *const argv[]); 其中 $pathname$ 为需要运行的程序的相对路径或绝对路径，$argv$ 为参数列表。 $argv$ 列表的最后一项一定需要赋值为 $NULL$。 此函数会运行程序 $pathname$，使用运行程序的进程将调用该函数的进程覆盖掉。此函数只有在发生错误时才会返回，返回值为 $-1$。 我在此使用了一个 $configuration$ 结构体来表示运行一个程序的一些设置（参数列表，输入输出重定向，管道等信息）。 1234567891011121314//execution configurationtypedef struct Configuration { //arglist char **arglist; //redirection int redirection; int read_file_fd; char *read_file_path; int write_file_fd; char *write_file_path; //pipe int **pipe; int pipe_num, cur_num;} Config; 运行程序 12//runexecv(whole_path, config-&gt;arglist); 运行环境变量中的程序(Path resolution)使用 $getenv$ 函数获得环境变量。 $getenv$ 函数原型 1char *getenv(const char *name); The getenv() function searches the environment list to find the environment variable name, and returns a pointer to the corresponding value string. 即该函数会返回环境变量 $name$ 的指针，如果没有匹配的环境变量则返回 $NULL$ 。 注：由于该函数返回的是环境变量本身的指针，因此在使用时必须保证不会修改该指针所指的信息 使用时最好创建一个副本进行操作。 使用 $strtok_r$ 函数进行切割字符串。 $strtok_r$ 函数原型 1char *strtok_r(char *str, const char *delim, char **saveptr); 其中 $str$ 为需要切割的字符串，$delim$ 为切割依据的集合，如按照 $|$ 和 $%$ 进行切割的话，$delim$ 即为 $|%$ ，$saveptr$ 为进行切割时的标记。 返回值为一个字符串的首地址（每次调用返回下一个部分的首地址），如果已经结束，则返回 $NULL$。 对于一个特定的字符串，第一次调用该函数的时候需要将 $str$ 参数设置为字符串的地址，$delim$ 即为切割依据的集合，$saveptr$ 为一个指针的地址。第一次调用之后，$saveptr$ 将会被赋予一个值，用于标记这个字符串的切割情况。之后的每次调用需要将 $str$ 置为 $NULL$，$delim$ 依然为切割依据的集合，$saveptr$ 需和之前的保持一致，用于标识这个字符串的切割情况。直到该函数返回 $NULL$ 结束。 注：该函数会修改原字符串 使用 $opendir$ , $readdir$ , $closedir$ 函数读取文件夹中的所有文件。 函数原型 123456789101112DIR *opendir(const char *name);struct dirent *readdir(DIR *dirp);int closedir(DIR *dirp);struct dirent { ino_t d_ino; /* Inode number */ off_t d_off; /* Not an offset; see below */ unsigned short d_reclen; /* Length of this record */ unsigned char d_type; /* Type of file; not supported by all filesystem types */ char d_name[256]; /* Null-terminated filename */}; $opendir$ 依据 $name$ 打开一个文件夹流，并返回一个 $DIR$ 结构体的指针。 $readdir$ 会依次读取文件夹中的每个文件，返回一个 $dirent$ 结构体指针，直到返回 $NULL$ 。 $closedir$ 即为关闭文件夹流。 从环境变量中寻找所需文件的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445char *ORI_PATH = getenv(\"PATH\");char *PATH = malloc(sizeof(char) * (strlen(ORI_PATH) + 1));strcpy(PATH, ORI_PATH);char *flagptr, *token;//split by ':'for(int i = 0; ; ++i) { token = strtok_r(PATH, \":\", &amp;flagptr); if(PATH != NULL) { free(PATH);//maybe not safe PATH = NULL; } if(token == NULL) { break; } DIR *dir = opendir(token); if(dir == NULL) { continue; } struct dirent *file; while(1) { file = readdir(dir); if(file &lt;= 0) { break; } if(strcmp(path, file-&gt;d_name) == 0) { found = true; //-&gt;whole_path whole_path = malloc(sizeof(char) * (strlen(token) + strlen(file-&gt;d_name) + 2)); strcpy(whole_path, token); whole_path[strlen(token)] = '/'; strcpy(whole_path + strlen(token) + 1, file-&gt;d_name); // printf(\" %s\\n\", whole_path);// break; } } closedir(dir); if(found) break;} 之后使用 $execv$ 运行程序即可。 输入输出重定向(Redirection)实现类似于[process] &gt; [file]和[process] &lt; [file]的输入输出重定向。 即，将程序的标准输入、标准输出重定向到某个文件中。 在重定向的检测中就知识在检测&lt;和&gt;的位置，以及重定向符号后面的文件是否存在。 在重定向中，使用到了dup2函数 函数原型 1int dup2(int oldfd, int newfd); 使用newfd代替oldfd的文件描述符 0为stdin，1为stdout。 代码 123456789101112131415161718192021//make sure the redirectionint read_fd = -1, write_fd = -1;if(config-&gt;redirection == 1) read_fd = open(config-&gt;read_file_path, O_RDONLY);else if(config-&gt;redirection == 2) write_fd = open(config-&gt;write_file_path, O_WRONLY | O_CREAT);else if(config-&gt;redirection == 3) { if(strcmp(config-&gt;read_file_path, config-&gt;write_file_path) == 0) { read_fd = write_fd = open(config-&gt;read_file_path, O_RDWR); } else { read_fd = open(config-&gt;read_file_path, O_RDONLY); write_fd = open(config-&gt;write_file_path, O_WRONLY | O_CREAT); }}//redirection and pipeif(read_fd != -1) dup2(read_fd, 0);//stdinif(write_fd != -1) dup2(write_fd, 1);//stdout 管道(Pipes)管道详解 需要完成类似于[process A] | [process B] | [process C]的功能 需要用到函数int pipe(int fds[2]) 函数原型 1int pipe(int pipefd[2]); 管道通信的原理 使用pipe函数创建了两个文件描述符，pipefd[0]和pipefd[1]，这就是一个管道的读取通道和写入通道。 使用dup2函数将标准输入输出重定向到管道即可实现管道通信。 12345//redirection and pipeif(read_fd != -1) dup2(read_fd, 0);//stdinif(write_fd != -1) dup2(write_fd, 1);//stdout 管道的内部实现是一个循环队列，写入端通过pipefd[1]将字符写道管道中，如果管道是满的，那么就会阻塞该进程，待管道不满之后，继续写入。读取端通过pipefd[0]进行读取，如果管道是空的，会阻塞该进程，直到管道非空。 注：一定要保证管道读取和写入结束之后，把文件描述符关闭掉，否则会造成进程阻塞，结束不了。 管道的创建 12345678910111213int **pipe_fd;//pipe_file_discreptorpid_t *pid;//process_idmy_token *token = (my_token*)malloc(sizeof(my_token));token-&gt;tokens_length = 0;token-&gt;tokens = NULL;int pgrp = 0;pipe_fd = malloc(sizeof(int*) * pipe_num);for(int i = 0; i &lt; pipe_num; ++i) { pipe_fd[i] = malloc(sizeof(int) * 2); pipe(pipe_fd[i]);}pid = malloc(sizeof(int) * (pipe_num + 1)); 在每一个子进程中需要将所有无关的管道都给关闭掉 12345678//close other pipefor(int i = 0; i &lt; config-&gt;pipe_num; ++i) { for(int j = 0; j &lt; 2; ++j) { if((config-&gt;pipe[i][j] != config-&gt;read_file_fd) &amp;&amp; (config-&gt;pipe[i][j] != config-&gt;write_file_fd)) { close(config-&gt;pipe[i][j]); } }} 进行管道的输入输出重定向 12345//redirection and pipeif(read_fd != -1) dup2(read_fd, 0);//stdinif(write_fd != -1) dup2(write_fd, 1);//stdout 同理，在父进程中，需要将所有的管道都关闭 1234//close pipefor(int i = 0; i &lt; pipe_num; ++i) for(int j = 0; j &lt; 2; ++j) close(pipe_fd[i][j]); 之后，等待所有的子进程结束 123//wait for the childsfor(int i = 0; i &lt;= pipe_num; ++i) waitpid(pid[i], NULL, 0); 信号处理使用setpgid函数改变进程所属的进程组 使用tcsetpgrp(int fd, pid_t pgrp)函数改变前台进程组。 键入Ctrl + Z或Ctrl + C时，应该只对前台的进程组产生影响，而不应该对shell本身或后台的进程组产生影响。 常用信号概览 在linux中man 7 signal以查看。 1SIGINT CTRL-C. 默认情况下，会结束程序。 1SIGQUIT CTRL-\\. 默认情况下，这个也是会结束程序，但是这个信号会试程序在退出时产生一个core文件，类似于一个程序错误信号。 1SIGKILL 没有快捷键. 这个信号会强制结束一个程序，并且，该信号不能被程序重载。 1SIGTERM 没有快捷键. 这个信号和 SIGQUIT 的行为是一样的。 1SIGTSTP CTRL-Z. 默认情况下，这会使程序暂停并回到bash中。 1SIGCONT 在bash中，当运行fg或者fg %NUMBER命令时，该信号会使一个暂停的进程重新恢复运行。 1SIGTTIN 会停止后台进程从键盘读入数据 1SIGTTOU 和SIGTTIN类似，这个管的是output，停止后台进程在shell的输出，并阻塞。 在C语言中，可以使用sigaction函数来改变当前进程对某些信号的行为，可以忽略、执行自定义的操作等。 函数原型 123456789int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void);}; 函数表示，使用新的行为act来代替对信号signum的操作，将原来的行为保存到oldact中，oldact为NULL时表示不保存原来的行为。 定义了一个专门处理信号的函数 12345678910111213//signal controlstruct sigaction sa;//handle the singalvoid signal_handle() { if (sigaction(SIGTTOU, &amp;sa, NULL) == -1) { perror(\"sigaction error\"); exit(EXIT_FAILURE); } if (sigaction(SIGTTIN, &amp;sa, NULL) == -1) { perror(\"sigaction error\"); exit(EXIT_FAILURE); } if (sigaction(SIGCONT, &amp;sa, NULL) == -1) { perror(\"sigaction error\"); exit(EXIT_FAILURE); } if (sigaction(SIGTSTP, &amp;sa, NULL) == -1) { perror(\"sigaction error\"); exit(EXIT_FAILURE); } if (sigaction(SIGTERM, &amp;sa, NULL) == -1) { perror(\"sigaction error\"); exit(EXIT_FAILURE); } if (sigaction(SIGINT, &amp;sa, NULL) == -1) { perror(\"sigaction error\"); exit(EXIT_FAILURE); } if (sigaction(SIGQUIT, &amp;sa, NULL) == -1) { perror(\"sigaction error\"); exit(EXIT_FAILURE); }} main函数中的初始化 1234sa.sa_handler = SIG_IGN; // 表示忽略sigemptyset(&amp;sa.sa_mask);sa.sa_flags = 0;signal_handle(); 在每个子进程的入口，都需要将信号改为默认行为。 12345//Enable some signalssa.sa_handler = SIG_DFL;signal_handle();//setpgidsetpgid(getpid(), getpid());","categories":[{"name":"cs162","slug":"cs162","permalink":"http://shaun-2314.github.io/categories/cs162/"}],"tags":[{"name":"cs162","slug":"cs162","permalink":"http://shaun-2314.github.io/tags/cs162/"},{"name":"操作系统","slug":"操作系统","permalink":"http://shaun-2314.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"shell","slug":"shell","permalink":"http://shaun-2314.github.io/tags/shell/"}]},{"title":"2022牛客多校加赛场","slug":"2022nowcoder-extra","date":"2022-09-08T08:11:55.000Z","updated":"2023-01-11T06:47:58.907Z","comments":true,"path":"2022/09/08/2022nowcoder-extra/","link":"","permalink":"http://shaun-2314.github.io/2022/09/08/2022nowcoder-extra/","excerpt":"","text":"2022牛客多校加赛场contest传送门 战况 这次的发挥实在是离谱，甚至差点进前50。 然后至于为什么这么久才开始补这场的博客，是因为我今天下午刚补了一道这场的字符串题目，前面有提到过这道题。 补题Cmostp题意给出一个长度为 $n(1 \\leq n \\leq 10^5)$ 的字符串 $s$ ，然后会有 $q(1 \\leq q \\leq 10^5)$ 个提问。 每次提问给出一个区间 $[l,r]$ ，询问字符串 $s$ 中，所有结尾在 $[l,r]$ 的子串中，本质不同子串的个数。 思路这道题的思路和之前的一道洛谷上面的题目特别类似，那道题是求区间本质不同子串数量，具体见我写的这篇，这道题的大致思路和那道题的思路十分类似，也是利用 $SAM$ + $LCT$ + 扫描线思想 + 离线处理 + 线段树 来进行求解的。不同的地方就是 $LCT$ 里面的 $access$ 操作有点不太一样。 这道题里面的线段树中维护的是以该位置为结尾的子串的数量，所以在 $LCT$ 中的 $access$ 操作中要进行操作和维护的是字串的右端点，进行一些改动即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=500005;int n,q;char s[MAXX];int pos[MAXX];struct SamNode{ int ch[26]; int len,fa; SamNode(){memset(ch,0,sizeof(ch));len=0;}}sam[MAXX&lt;&lt;1];int las=1,sam_cnt=1;//LL num[MAXX&lt;&lt;1];void add(int c){ int p=las;int np=las=++sam_cnt;// num[np]=1LL;//此行为计数用，标记出现过几次 sam[np].len=sam[p].len+1; for(;p&amp;&amp;!sam[p].ch[c];p=sam[p].fa) sam[p].ch[c]=np; if(!p) sam[np].fa=1; else{ int q=sam[p].ch[c]; if(sam[q].len==sam[p].len+1) sam[np].fa=q; else{ int nq=++sam_cnt;sam[nq]=sam[q]; sam[nq].len=sam[p].len+1; sam[q].fa=sam[np].fa=nq; for(;p&amp;&amp;sam[p].ch[c]==q;p=sam[p].fa) sam[p].ch[c]=nq; } }}struct Seg{ LL tr[MAXX&lt;&lt;2],lazy[MAXX&lt;&lt;2]; //sum inline void pushup(int now){ tr[now]=tr[now&lt;&lt;1]+tr[now&lt;&lt;1|1]; } inline void pushdown(int now,int l,int r){ if(lazy[now]){ int mid=(l+r)&gt;&gt;1; lazy[now&lt;&lt;1]+=lazy[now]; lazy[now&lt;&lt;1|1]+=lazy[now]; tr[now&lt;&lt;1]+=lazy[now]*(mid-l+1); tr[now&lt;&lt;1|1]+=lazy[now]*(r-mid); lazy[now]=0; } } //add void updata(int now,int l,int r,int ll,int rr,LL val){ if(l&gt;=ll&amp;&amp;r&lt;=rr){ lazy[now]+=val; tr[now]+=val*(r-l+1); return; } pushdown(now,l,r); int mid=(l+r)&gt;&gt;1; if(mid&gt;=ll) updata(now&lt;&lt;1,l,mid,ll,rr,val); if(mid&lt;rr) updata(now&lt;&lt;1|1,mid+1,r,ll,rr,val); pushup(now); } //sum LL getsum(int now,int l,int r,int ll,int rr){ if(l&gt;=ll&amp;&amp;r&lt;=rr) return tr[now]; pushdown(now,l,r); LL ret=0; int mid=(l+r)&gt;&gt;1; if(mid&gt;=ll) ret+=getsum(now&lt;&lt;1,l,mid,ll,rr); if(mid&lt;rr) ret+=getsum(now&lt;&lt;1|1,mid+1,r,ll,rr); return ret; }}seg;struct LCT{ struct node{ int fa,left,right,val,cover; }s[MAXX&lt;&lt;1]; inline void pushdown(int i){ if(s[i].cover){ if(s[i].left) s[s[i].left].val=s[s[i].left].cover=s[i].cover; if(s[i].right) s[s[i].right].val=s[s[i].right].cover=s[i].cover; s[i].cover=0; } } inline int identify(int i){ if(s[s[i].fa].left==i) return 0; if(s[s[i].fa].right==i) return 1; return -1; } inline void connect(int i,int f,int op){ s[i].fa=f; if(op==1) s[f].right=i; if(op==0) s[f].left=i; } inline void rotate(int x){ int y=s[x].fa; int z=s[y].fa; int opy=identify(y); int opx=identify(x); int u=0; if(opx==1) u=s[x].left; if(opx==0) u=s[x].right; connect(u,y,opx); connect(y,x,opx^1); connect(x,z,opy); } void pushall(int x){ if(identify(x)!=-1) pushall(s[x].fa); pushdown(x); } inline void splay(int i){ pushall(i); while(identify(i)!=-1){ int up=s[i].fa; if(identify(up)==-1) rotate(i); else if(identify(i)==identify(up)) rotate(up),rotate(i); else rotate(i),rotate(i); } } //以上为splay的一些基本操作 //下面是LCT的操作 //构建一条从根到k的一条重链 inline int access(int k,int id){ int temp=0; while(k){ splay(k); if(s[k].val){ seg.updata(1,1,n,s[k].val,s[k].val,-(sam[k].len-sam[s[k].fa].len)); } s[k].right=temp; temp=k; k=s[k].fa; } seg.updata(1,1,n,id,id,id); s[temp].val=s[temp].cover=id; return temp; }}lct;struct query{ int l,r,id;}qq[MAXX];LL ans[MAXX];bool cmp(query jj,query kk){return jj.r&lt;kk.r;}inline void solve(){ scanf(\"%d%d\",&amp;n,&amp;q); getchar();scanf(\"%s\",s+1); for(int i=1;i&lt;=n;++i){ add(s[i]-'a'); pos[i]=las; } for(int i=2;i&lt;=sam_cnt;++i) lct.s[i].fa=sam[i].fa; for(int i=1;i&lt;=q;++i) scanf(\"%d%d\",&amp;qq[i].l,&amp;qq[i].r),qq[i].id=i; sort(qq+1,qq+q+1,cmp); int p=1; for(int i=1;i&lt;=n;++i){ lct.access(pos[i],i); while(qq[p].r==i){ ans[qq[p].id]=seg.getsum(1,1,n,qq[p].l,qq[p].r); ++p; } } for(int i=1;i&lt;=q;++i) printf(\"%lld\\n\",ans[i]);}signed main(){// LL t;scanf(\"%lld\",&amp;t);// while(t--) solve(); return 0;} 总结这道题也算是字符串里面的一道神仙题目了。需要多练习练习。","categories":[{"name":"2022牛客多校","slug":"2022牛客多校","permalink":"http://shaun-2314.github.io/categories/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"}]},{"title":"cf-edu134-E，KMP的代替物？（速度超快）","slug":"cf-edu134-E","date":"2022-08-29T11:09:09.000Z","updated":"2022-08-30T05:19:59.810Z","comments":true,"path":"2022/08/29/cf-edu134-e/","link":"","permalink":"http://shaun-2314.github.io/2022/08/29/cf-edu134-e/","excerpt":"","text":"Prefix Function Queries题目传送门 题意有一个长度为 $n(1 \\leq n \\leq 10^6)$ 的字符串 $s$ ，有 $q(1 \\leq q \\leq 10^5)$ 次询问。 每次询问给出一个非空字符串 $t(1 \\leq |t| \\leq 10)$ ，如果把 $t$ 拼接到 $s$ 的后面，求长度为 $n+1,n+2, \\dots ,n+|t|$ 的前缀的最长相同前缀后缀。（即求 $KMP$ 中的 $pmt$ 数组的 $pmt[n+1],pmt[n+2], \\dots ,pmt[n+|t|]$ ）。 思路我刚开始感觉这就是个 $KMP$ 的裸题，但是在我交了上去并发现 $T$ 了的时候，感觉又不像是 $KMP$ 。 然后，在今天题解出来之后，我看了一下，发现了一个叫前缀函数自动机的东西，这个东西和 $AC自动机$ 极其类似，都有一个叫失配指针的东西，然后这东西又有点像 $Trie 树$ ，有着相似的转移。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=1000050;int n,q;char s[MAXX];int fail[MAXX],ch[MAXX][26];inline void solve(){ scanf(\"%s%d\",s+1,&amp;q); n=strlen(s+1); ch[0][s[1]-'a']=1; for(int i=2;i&lt;=n;++i){ for(int j=0;j&lt;26;++j){ if(s[i]-'a'==j){ ch[i-1][j]=i; fail[i]=ch[fail[i-1]][j]; } else ch[i-1][j]=ch[fail[i-1]][j]; } } while(q--){ getchar();scanf(\"%s\",s+n+1); int nn=strlen(s+n+1)+n; for(int i=n+1;i&lt;=nn;++i){ for(int j=0;j&lt;26;++j){ if(s[i]-'a'==j){ ch[i-1][j]=i; fail[i]=ch[fail[i-1]][j]; } else ch[i-1][j]=ch[fail[i-1]][j]; } } for(int i=n+1;i&lt;=nn;++i) printf(\"%d%c\",fail[i],\" \\n\"[i==nn]); } }signed main(){// LL t;scanf(\"%lld\",&amp;t);// while(t--) solve(); return 0;} 总结感觉这个东西在只需要求 $pmt$ 数组的时候，可以作为 $KMP$ 的替代品。","categories":[{"name":"狂刷字符串","slug":"狂刷字符串","permalink":"http://shaun-2314.github.io/categories/%E7%8B%82%E5%88%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"字符串","slug":"字符串","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"洛谷P6292，个人认为的字符串神仙题目","slug":"luogu-P6292","date":"2022-08-26T08:26:26.000Z","updated":"2022-08-26T09:45:16.691Z","comments":true,"path":"2022/08/26/luogu-p6292/","link":"","permalink":"http://shaun-2314.github.io/2022/08/26/luogu-p6292/","excerpt":"","text":"区间本质不同子串个数题目传送门 前言借鉴了题解中的这篇。 起因 前面多校训练的时候，出了一道和这道题十分类似但是又差别很大的题目。于是想着先把这道题给学会了，然后再尝试写多校训练中出现的那道题目。 本题知识点一览 $SAM$ + $LCT$ + 线段树 + 扫描线思想 + 离线处理 乱七八糟的 因为当时我还并不会 $LCT$ ，于是才有了昨天的那篇学习 $LCT$ 的文章。然后，为了学 $LCT$ ，又需要学会 $splay$ 和 树剖 ，于是又有了上上篇的学习树剖， $splay$ 实在是学不动了(其实就是懒)，就直接跳过 $splay$ 去学 $LCT$ 了，然后对于 $LCT$ 的理解，除了 $splay$ 部分，感觉还是可以的(然而只有学会 $splay$ 才能完全理解 $LCT$ )。 当时写着写着才发现我甚至还没有一个像样的线段树板子，于是当时就去 copy 了一份，到后面了再总结一下这个板子。 步入正文 题意给出一个长度为 $n(1 \\leq n \\leq 10^5)$ 的字符串 $S$ ，$m(1 \\leq m \\leq 2 \\times 10^5)$ 次询问由 $S$ 的第 $L$ 到第 $R$ 个字符组成的字符串包含多少个本质不同的子串。 思路我们首先考虑静态区间不同元素种类数这种经典问题的求解方法。 首先把所有询问离线下来，根据右端点排序。 对于一个固定的右端点 $i$ ，贪心的只考虑 $i$ 之前每种元素最后出现的位置。按下标从左到右扫描线，用线段树维护每个位置是否在前缀 $i$ 种最后一次出现。加入第 $i$ 个元素时，在线段树中把当前位置 $+1$ ，把上一个相同元素的位置 $-1$ 。答案就直接区间查询即可。 我们发现这道题是可以采用这个思路的。 我们把每种本质不同的子串都当作是一种元素。 线段树中维护区间和，每个位置 $i$ 表示那些此时以 $i$ 位置为开头并且是最后一次出现的子串的数量。 那么，在插入 $i$ 位置时，我们应当把所有以 $i$ 为结尾的子串的贡献加入到线段树中，再把重复出现的子串的上次出现位置的贡献给删掉，子串有长度，我们只需要维护左端点即可(即上一段说的定义)。把贡献加入到线段树我们可以直接使用一次区间加就可以完成，但是把上次的贡献给删掉就不好搞了，因为我们并不知道他们上次出现的位置。 于是，我们建一个后缀自动机，那么以 $i$ 位置结尾的子串就是前缀 $i$ 对应的节点在后缀链接树上的所有 $father$ 节点。根据 $SAM$ 的特点，每个节点会表示同一个状态的多个子串，而他们的上一次出现的位置的右端点是完全一样的，而且他们的左端点是一个连续的片段。 考虑暴力求解，对每一个节点设置一个染色，我们可以暴力向上跳后缀链接树并在线段树上进行区间修改，同时，我们还需要把这条链染成 $i$ 颜色，表示最后一次出现的位置的右端点是 $i$ 。但是显然这种复杂度是无法接受的。 通过观察，我们发现我们操作的好像都是 $SAM$ 上的链，于是我们考虑 $LCT$ 进行优化，我们发现“暴力向上跳后缀链接树并在线段树上进行区间修改”正好对应着 $LCT$ 上的 $access$ 操作，我们可以利用 $access$ 操作中的断链、连接链来直接进行线段树上的区间加操作和整条链染色的操作，这样做的复杂度是十分友好的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3f3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;int n,m,pos[MAXX];char s[MAXX];struct SamNode{ int ch[26]; int len,fa; SamNode(){memset(ch,0,sizeof(ch));len=0;}}sam[MAXX&lt;&lt;1];int las=1,sam_cnt=1;//LL num[MAXX&lt;&lt;1];void add(int c){ int p=las;int np=las=++sam_cnt;// num[np]=1LL;//此行为计数用，标记出现过几次 sam[np].len=sam[p].len+1; for(;p&amp;&amp;!sam[p].ch[c];p=sam[p].fa) sam[p].ch[c]=np; if(!p) sam[np].fa=1; else{ int q=sam[p].ch[c]; if(sam[q].len==sam[p].len+1) sam[np].fa=q; else{ int nq=++sam_cnt;sam[nq]=sam[q]; sam[nq].len=sam[p].len+1; sam[q].fa=sam[np].fa=nq; for(;p&amp;&amp;sam[p].ch[c]==q;p=sam[p].fa) sam[p].ch[c]=nq; } }}struct Seg{ LL val[MAXX&lt;&lt;2],tag[MAXX&lt;&lt;2]; Seg(){memset(val,0,sizeof(val));memset(tag,0,sizeof(tag));} void push_down(int rt,int l,int r){ if(tag[rt]){ int mid=(l+r)&gt;&gt;1; tag[rt&lt;&lt;1]+=tag[rt],tag[rt&lt;&lt;1|1]+=tag[rt]; val[rt&lt;&lt;1]+=tag[rt]*(mid-l+1);val[rt&lt;&lt;1|1]+=tag[rt]*(r-(mid+1)+1); tag[rt]=0; } } void push_up(int rt){ val[rt]=val[rt&lt;&lt;1]+val[rt&lt;&lt;1|1]; } void add(int l,int r,int rt,int tl,int tr,LL w){ if(tl&gt;tr) return; if(tl&lt;=l&amp;&amp;r&lt;=tr){ tag[rt]+=w;val[rt]+=w*(r-l+1);return; } push_down(rt,l,r); int mid=(l+r)&gt;&gt;1; if(tl&lt;=mid)add(l,mid,rt&lt;&lt;1,tl,tr,w); if(tr&gt;=mid+1)add(mid+1,r,rt&lt;&lt;1|1,tl,tr,w); push_up(rt); } LL getsum(int l,int r,int rt,int tl,int tr){ if(tl&lt;=l&amp;&amp;r&lt;=tr){return val[rt];} push_down(rt,l,r); int mid=(l+r)&gt;&gt;1;LL ans=0; if(tl&lt;=mid)ans+=getsum(l,mid,rt&lt;&lt;1,tl,tr); if(tr&gt;=mid+1)ans+=getsum(mid+1,r,rt&lt;&lt;1|1,tl,tr); return ans; }}seg;//add(1,n,1,l,r,v);struct LCT{ struct node{ int fa,left,right,val,cov; }s[MAXX&lt;&lt;1]; inline void pushdown(int i){ if(s[i].cov){ if(s[i].left) s[s[i].left].val=s[s[i].left].cov=s[i].cov; if(s[i].right) s[s[i].right].val=s[s[i].right].cov=s[i].cov; s[i].cov=0; } } inline int identify(int i){ if(s[s[i].fa].left==i) return 0; if(s[s[i].fa].right==i) return 1; return -1; } inline void connect(int i,int f,int op){ s[i].fa=f; if(op==1) s[f].right=i; if(op==0) s[f].left=i; } inline void rotate(int x){ int y=s[x].fa; int z=s[y].fa; int opy=identify(y); int opx=identify(x); int u=0; if(opx==1) u=s[x].left; if(opx==0) u=s[x].right; connect(u,y,opx); connect(y,x,opx^1); connect(x,z,opy); } void pushall(int x){ if(identify(x)!=-1) pushall(s[x].fa); pushdown(x); } inline void splay(int i){ pushall(i); while(identify(i)!=-1){ int up=s[i].fa; if(identify(up)==-1) rotate(i); else if(identify(i)==identify(up)) rotate(up),rotate(i); else rotate(i),rotate(i); } } inline int access(int k,int id){ int temp=0; while(k){ splay(k); if(s[k].val){ // printf(\"*%d %d %d\\n\",s[k].val-sam[k].len+1,s[k].val-sam[s[k].fa].len,-1);// seg.add(1,n,1,s[k].val-sam[k].len+1,s[k].val-sam[s[k].fa].len,-1); } s[k].right=temp; temp=k; k=s[k].fa; } // printf(\"*1 %d 1\\n\",id);// seg.add(1,n,1,1,id,1); s[temp].val=s[temp].cov=id; return temp; }}lct;struct QQ{ int l,r,id;}a[MAXX*2];bool cmp(QQ jj,QQ kk){return (jj.r&lt;kk.r);}LL ans[MAXX*2];inline void solve(){ scanf(\"%s\\n%d\",s+1,&amp;m); for(int i=1;i&lt;=m;++i){ scanf(\"%d%d\",&amp;a[i].l,&amp;a[i].r); a[i].id=i; } n=strlen(s+1); sort(a+1,a+m+1,cmp); for(int i=1;i&lt;=n;++i){ add(s[i]-'a'); pos[i]=las; } for(int i=2;i&lt;=sam_cnt;++i){ lct.s[i].fa=sam[i].fa; } int p=1; for(int i=1;i&lt;=n;++i){ lct.access(pos[i],i); while(a[p].r==i) ans[a[p].id]=seg.getsum(1,n,1,a[p].l,a[p].r),++p; } for(int i=1;i&lt;=m;++i) printf(\"%lld\\n\",ans[i]);}signed main(){// LL t;scanf(\"%lld\",&amp;t);// while(t--) solve(); return 0;} 总结这道题真是我见过的字符串题目中的神仙题目了，难度十分的高，我现在写完了这篇博客也是无法做到完完全全的理解，但是大概也算是理解了。这道题涉及到的操作实在是太多了，现在短时间内还无法完全消化，后面有时间会尽量多看看，争取完全理解。","categories":[{"name":"狂刷字符串","slug":"狂刷字符串","permalink":"http://shaun-2314.github.io/categories/%E7%8B%82%E5%88%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"LCT","slug":"LCT","permalink":"http://shaun-2314.github.io/tags/LCT/"},{"name":"字符串","slug":"字符串","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://shaun-2314.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"线段树","slug":"线段树","permalink":"http://shaun-2314.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"扫描线","slug":"扫描线","permalink":"http://shaun-2314.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"离线","slug":"离线","permalink":"http://shaun-2314.github.io/tags/%E7%A6%BB%E7%BA%BF/"}]},{"title":"学一下LCT，有多道例题","slug":"LCT-learning","date":"2022-08-25T12:04:44.000Z","updated":"2022-08-25T12:28:16.559Z","comments":true,"path":"2022/08/25/lct-learning/","link":"","permalink":"http://shaun-2314.github.io/2022/08/25/lct-learning/","excerpt":"","text":"LCT(link-cut tree)前言关于我为什么要学这个东西 学这个是因为我要学习这道题的写法，而这道题是用到了 $LCT$ ，于是，学一下。 大概解释这里不做详细解释，只粗略的做个描述。 $LCT$ 和树链剖分很像，但是， $LCT$ 并不是根据轻重链来分的，而是根据需要，可以随意的分。 $LCT$ 在结构上看，整体结构就是”树链剖分+ $splay$ “，这里面，每条独立的链的内部都是一个 $splay$ 来进行维护的。里面的各种函数都是在这个基础上进行操作的。 我的重点不在此处，这里不做过多解释，便只描述了一下整体结构。 适用场景学了一下才发现，这东西是真的妙啊，这个东西是个动态树。 可以支持动态维护一个树结构，具体来说就是支持加边和删除边。 可以用来求无根树的lca，就是可以多次随意指定一个根来求lca。 这个东西还可以当作一个动态并查集来使用。即可以加边也可以删边的并查集。 几个例题【模板】动态树（Link Cut Tree）题目传送门 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;struct LCT{ struct node{ int fa,left,right,val,sum,lazy; }s[MAXX]; //根据需要维护什么进行改动(大概) inline void pushup(int i){ s[i].sum=s[s[i].left].sum^s[s[i].right].sum^s[i].val; } inline void pushdown(int i){ if(s[i].lazy){ swap(s[i].left,s[i].right); if(s[i].left) s[s[i].left].lazy^=1; if(s[i].right) s[s[i].right].lazy^=1; s[i].lazy=0; } } inline int identify(int i){ if(s[s[i].fa].left==i) return 0; if(s[s[i].fa].right==i) return 1; return -1; } inline void connect(int i,int f,int op){ s[i].fa=f; if(op==1) s[f].right=i; if(op==0) s[f].left=i; } inline void rotate(int x){ int y=s[x].fa; int z=s[y].fa; int opy=identify(y); int opx=identify(x); int u=0; if(opx==1) u=s[x].left; if(opx==0) u=s[x].right; connect(u,y,opx); connect(y,x,opx^1); connect(x,z,opy); pushup(y); pushup(x); } void pushall(int x){ if(identify(x)!=-1) pushall(s[x].fa); pushdown(x); } inline void splay(int i){ pushall(i); while(identify(i)!=-1){ int up=s[i].fa; if(identify(up)==-1) rotate(i); else if(identify(i)==identify(up)) rotate(up),rotate(i); else rotate(i),rotate(i); } } //以上为splay的一些基本操作 //下面是LCT的操作 //构建一条从根到k的一条重链 inline int access(int k){ int temp=0; while(k){ splay(k); s[k].right=temp; pushup(k); temp=k; k=s[k].fa; } return temp; } inline void makeroot(int k){ access(k); splay(k); swap(s[k].left,s[k].right); if(s[k].left) s[s[k].left].lazy^=1; if(s[k].right) s[s[k].right].lazy^=1; } inline int findroot(int k){ access(k); splay(k); while(s[k].left){ pushdown(k); k=s[k].left; } splay(k); return k; } //询问或操作从x到y这条链 //将从x到y这条链单独提出来，并将y变成根 inline void split(int x,int y){ makeroot(x); access(y); splay(y); } //返回x和y的lca inline int lca(int x,int y){ access(x); return access(y); } //返回以r为根的情况下的x和y的lca inline int lca(int r,int x,int y){ makeroot(r); access(x); return access(y); } inline bool link(int x,int y){ makeroot(x); if(findroot(y)==x) return false; s[x].fa=y; return true; } inline bool cut(int x,int y){ if(findroot(x)!=findroot(y)) return false; split(x,y); if(s[x].fa!=y||s[x].right) return false; s[x].fa=s[y].left=0; pushup(x); return true; }}lct;int n,m;inline void solve(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i){ scanf(\"%d\",&amp;lct.s[i].val); lct.s[i].sum=lct.s[i].val; } while(m--){ int op,x,y; scanf(\"%d%d%d\",&amp;op,&amp;x,&amp;y); if(op==0){ lct.split(x,y); printf(\"%d\\n\",lct.s[y].sum); } else if(op==1) lct.link(x,y); else if(op==2) lct.cut(x,y); else{ lct.split(x,x); lct.s[x].val=lct.s[x].sum=y; } }}signed main(){// LL t;scanf(\"%lld\",&amp;t);// while(t--) solve(); return 0;} 智乃的LCA题目传送门 题意给出一棵树 多次询问 $lca(root,x,y)$ ，表示以 $root$ 为根的时候 $x$ 和 $y$ 的 lca 。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;struct LCT{ struct node{ int fa,left,right,val,sum,lazy; }s[MAXX]; //根据需要维护什么进行改动(大概) inline void pushup(int i){ s[i].sum=s[s[i].left].sum^s[s[i].right].sum^s[i].val; } inline void pushdown(int i){ if(s[i].lazy){ swap(s[i].left,s[i].right); if(s[i].left) s[s[i].left].lazy^=1; if(s[i].right) s[s[i].right].lazy^=1; s[i].lazy=0; } } inline int identify(int i){ if(s[s[i].fa].left==i) return 0; if(s[s[i].fa].right==i) return 1; return -1; } inline void connect(int i,int f,int op){ s[i].fa=f; if(op==1) s[f].right=i; if(op==0) s[f].left=i; } inline void rotate(int x){ int y=s[x].fa; int z=s[y].fa; int opy=identify(y); int opx=identify(x); int u=0; if(opx==1) u=s[x].left; if(opx==0) u=s[x].right; connect(u,y,opx); connect(y,x,opx^1); connect(x,z,opy); pushup(y); pushup(x); } void pushall(int x){ if(identify(x)!=-1) pushall(s[x].fa); pushdown(x); } inline void splay(int i){ pushall(i); while(identify(i)!=-1){ int up=s[i].fa; if(identify(up)==-1) rotate(i); else if(identify(i)==identify(up)) rotate(up),rotate(i); else rotate(i),rotate(i); } } //以上为splay的一些基本操作 //下面是LCT的操作 //构建一条从根到k的一条重链 inline int access(int k){ int temp=0; while(k){ splay(k); s[k].right=temp; pushup(k); temp=k; k=s[k].fa; } return temp; } inline void makeroot(int k){ access(k); splay(k); swap(s[k].left,s[k].right); if(s[k].left) s[s[k].left].lazy^=1; if(s[k].right) s[s[k].right].lazy^=1; } inline int findroot(int k){ access(k); splay(k); while(s[k].left){ pushdown(k); k=s[k].left; } splay(k); return k; } //询问或操作从x到y这条链 inline void split(int x,int y){ makeroot(x); access(y); splay(y); } //返回x和y的lca inline int lca(int x,int y){ access(x); return access(y); } //返回以r为根的情况下的x和y的lca inline int lca(int r,int x,int y){ makeroot(r); access(x); return access(y); } inline bool link(int x,int y){ makeroot(x); if(findroot(y)==x) return false; s[x].fa=y; return true; } inline bool cut(int x,int y){ if(findroot(x)!=findroot(y)) return false; split(x,y); if(s[x].fa!=y||s[x].right) return false; s[x].fa=s[y].left=0; pushup(x); return true; }}lct;int n,m;inline void solve(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;++i){ int jj,kk; scanf(\"%d%d\",&amp;jj,&amp;kk); lct.link(jj,kk); } scanf(\"%d\",&amp;m); while(m--){ int r,x,y; scanf(\"%d%d%d\",&amp;r,&amp;x,&amp;y); printf(\"%d\\n\",lct.lca(r,x,y)); }}signed main(){// LL t;scanf(\"%lld\",&amp;t);// while(t--) solve(); return 0;} [SDOI2008]CAVE 洞穴勘测题目传送门 题意三种操作 加边 删边 询问 $x$ 和 $y$ 是否连通 保证一直是树结构 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;struct LCT{ struct node{ int fa,left,right,val,sum,lazy; }s[MAXX]; //根据需要维护什么进行改动(大概) inline void pushup(int i){ s[i].sum=s[s[i].left].sum^s[s[i].right].sum^s[i].val; } inline void pushdown(int i){ if(s[i].lazy){ swap(s[i].left,s[i].right); if(s[i].left) s[s[i].left].lazy^=1; if(s[i].right) s[s[i].right].lazy^=1; s[i].lazy=0; } } inline int identify(int i){ if(s[s[i].fa].left==i) return 0; if(s[s[i].fa].right==i) return 1; return -1; } inline void connect(int i,int f,int op){ s[i].fa=f; if(op==1) s[f].right=i; if(op==0) s[f].left=i; } inline void rotate(int x){ int y=s[x].fa; int z=s[y].fa; int opy=identify(y); int opx=identify(x); int u=0; if(opx==1) u=s[x].left; if(opx==0) u=s[x].right; connect(u,y,opx); connect(y,x,opx^1); connect(x,z,opy); pushup(y); pushup(x); } void pushall(int x){ if(identify(x)!=-1) pushall(s[x].fa); pushdown(x); } inline void splay(int i){ pushall(i); while(identify(i)!=-1){ int up=s[i].fa; if(identify(up)==-1) rotate(i); else if(identify(i)==identify(up)) rotate(up),rotate(i); else rotate(i),rotate(i); } } //以上为splay的一些基本操作 //下面是LCT的操作 //构建一条从根到k的一条重链 inline int access(int k){ int temp=0; while(k){ splay(k); s[k].right=temp; pushup(k); temp=k; k=s[k].fa; } return temp; } inline void makeroot(int k){ access(k); splay(k); swap(s[k].left,s[k].right); if(s[k].left) s[s[k].left].lazy^=1; if(s[k].right) s[s[k].right].lazy^=1; } inline int findroot(int k){ access(k); splay(k); while(s[k].left){ pushdown(k); k=s[k].left; } splay(k); return k; } //询问或操作从x到y这条链 inline void split(int x,int y){ makeroot(x); access(y); splay(y); } //返回x和y的lca inline int lca(int x,int y){ access(x); return access(y); } //返回以r为根的情况下的x和y的lca inline int lca(int r,int x,int y){ makeroot(r); access(x); return access(y); } inline bool link(int x,int y){ makeroot(x); if(findroot(y)==x) return false; s[x].fa=y; return true; } inline bool cut(int x,int y){ if(findroot(x)!=findroot(y)) return false; split(x,y); if(s[x].fa!=y||s[x].right) return false; s[x].fa=s[y].left=0; pushup(x); return true; }}lct;int n,m;char s[20];inline void solve(){ scanf(\"%d%d\",&amp;n,&amp;m); while(m--){ int x,y; scanf(\"\\n%s%d%d\",s+1,&amp;x,&amp;y); if(s[1]=='C') lct.link(x,y); else if(s[1]=='D') lct.cut(x,y); else{ lct.makeroot(x); if(lct.findroot(y)==x) printf(\"Yes\\n\"); else printf(\"No\\n\"); } }}signed main(){// LL t;scanf(\"%lld\",&amp;t);// while(t--) solve(); return 0;}","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://shaun-2314.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"LCT","slug":"LCT","permalink":"http://shaun-2314.github.io/tags/LCT/"}]},{"title":"学一下树剖，洛谷P3384模板题","slug":"luogu-P3384","date":"2022-08-24T06:26:27.000Z","updated":"2022-08-24T06:35:58.108Z","comments":true,"path":"2022/08/24/luogu-p3384/","link":"","permalink":"http://shaun-2314.github.io/2022/08/24/luogu-p3384/","excerpt":"","text":"【模板】轻重链剖分/树链剖分题目传送门 题目大意 已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作： 1 x y z，表示将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。 2 x y，表示求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。 3 x z，表示将以 $x$ 为根节点的子树内所有节点值都加上 $z$。 4 x 表示求以 $x$ 为根节点的子树内所有节点值之和 思路使用树剖，将一棵树变成一条条互不相交的链进行维护 每条链上的下标连续，每棵子树的所有节点的下标连续，之后就可以使用线段树或者树状数组进行维护。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;int m,R;//树状数组+树剖int n;LL mod,a[MAXX];vector&lt;int&gt; to[MAXX];//树状数组LL c1[MAXX],c2[MAXX];inline int lowbit(int x){ return x&amp;(-x);}inline void add(int l,int r,int x){ x %= mod; int ad1 = (LL)(l-1)*x%mod; int ad2 = (LL)r*x%mod; for(int t=l;t&lt;=n;t+=lowbit(t)){ c1[t] = (c1[t]+x)%mod; c2[t] = (c2[t]+ad1)%mod; } for(int t=r+1;t&lt;=n;t+=lowbit(t)){ c1[t] = (c1[t]-x)%mod; c1[t] = (c1[t]+mod)%mod; c2[t] = (c2[t]-ad2)%mod; c2[t] = (c2[t]+mod)%mod; }}inline int qwq(int i){ //qwq int res = 0; for(int t=i;t&gt;0;t-=lowbit(t)){ res = (res+(LL)i*c1[t]%mod)%mod; res = (res-c2[t])%mod; res = (res+mod)%mod; } return res;}inline int query(int l,int r){ int res = (qwq(r)-qwq(l-1))%mod; return (res+mod)%mod;}//树剖int depth[MAXX],num[MAXX],son[MAXX],fa[MAXX];int top[MAXX],id[MAXX];void dfs1(int now,int fa){ depth[now]=depth[::fa[now]=fa]+1; num[now]=1; int maxnum=0; for(int jj:to[now]){ if(jj==fa) continue; dfs1(jj,now); num[now]+=num[jj]; if(num[jj]&gt;maxnum){ son[now]=jj; maxnum=num[jj]; } }}int cnt=0;void dfs2(int now,int t){ top[now]=t; id[now]=++cnt; if(a[now]) add(id[now],id[now],a[now]); if(son[now]) dfs2(son[now],t); for(int jj:to[now]){ if(jj==son[now]||jj==fa[now]) continue; dfs2(jj,jj); }}inline void init(int root){//root为根节点 dfs1(root,0); dfs2(root,root);}void addpath(int l,int r,LL jk){ while(top[l]!=top[r]){ if(depth[top[l]]&lt;depth[top[r]]) swap(l,r); add(id[top[l]],id[l],jk); l=fa[top[l]]; } if(depth[l]&gt;depth[r]) swap(l,r); add(id[l],id[r],jk);}LL getsum(int l,int r){ LL ret=0LL; while(top[l]!=top[r]){ if(depth[top[l]]&lt;depth[top[r]]) swap(l,r); ret=(ret+query(id[top[l]],id[l]))%mod; l=fa[top[l]]; } if(depth[l]&gt;depth[r]) swap(l,r); ret=(ret+query(id[l],id[r]))%mod; return ret;}void addtree(int x,LL jk){ add(id[x],id[x]+num[x]-1,jk);}LL getsum(int x){ return query(id[x],id[x]+num[x]-1);}inline void solve(){ scanf(\"%d%d%d%lld\",&amp;n,&amp;m,&amp;R,&amp;mod); for(int i=1;i&lt;=n;++i) scanf(\"%lld\",&amp;a[i]); for(int i=1;i&lt;n;++i){ int jj,kk;scanf(\"%d%d\",&amp;jj,&amp;kk); to[jj].emplace_back(kk); to[kk].emplace_back(jj); } init(R); while(m--){ int ch;scanf(\"%d\",&amp;ch); if(ch==1){ int l,r;LL jk; scanf(\"%d%d%lld\",&amp;l,&amp;r,&amp;jk); addpath(l,r,jk); } else if(ch==2){ int l,r;scanf(\"%d%d\",&amp;l,&amp;r); printf(\"%lld\\n\",getsum(l,r)); } else if(ch==3){ int x;LL jk; scanf(\"%d%lld\",&amp;x,&amp;jk); addtree(x,jk); } else{ int x;scanf(\"%d\",&amp;x); printf(\"%lld\\n\",getsum(x)); } }}signed main(){// LL t;scanf(\"%lld\",&amp;t);// while(t--) solve(); return 0;}","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://shaun-2314.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"树剖","slug":"树剖","permalink":"http://shaun-2314.github.io/tags/%E6%A0%91%E5%89%96/"}]},{"title":"2022杭电多校第7场","slug":"2022hdu-7","date":"2022-08-10T08:10:01.000Z","updated":"2022-08-10T13:08:05.321Z","comments":true,"path":"2022/08/10/2022hdu-7/","link":"","permalink":"http://shaun-2314.github.io/2022/08/10/2022hdu-7/","excerpt":"","text":"2022杭电多校第7场contest传送门 战况 这次贼猛，前几题写的也贼快，甚至在前面的时候甚至排到了第3名。 这次我也写了一道题，和曹佬一块讨论出了1002。 这次没有找到字符串题目。 补题1006-Sumire (数位dp)题意计算 $\\sum_{i=l}^r f^k(i,B,d)$ 其中 $f(x,B,d)$ 表示数字 $d$ 在 $B$ 进制的数字 $x$ 中出现的次数。 思路数位dp，我们使用 $dp[i][j]$ 表示还剩 $i$ 位要填并且前面已经有 $j$ 个数字 $d$ 的情况下的答案总数(这里指已经进行了 $k$ 次方运算后的结果) 大体上就是数位dp的板子了，但是直接交上去会 $T$ ，因为在这道题里面，可能会有 $10^9$ 进制的数，这时，只是一次循环就会 $T$ 掉，于是，我们需要做亿些优化 我们可以对下一个要枚举的数字进行分类，比如下一位是否等于 $d$ ，是否等于 $0$ ，是否等于上界 $up$ ，然而，这几种情况中间又会有交集，于是，这就变成了一个非常大的 $if / else$ 了，对上面的几种情况进行分类讨论即可。 代码实现要十分细心，此处细节非常多，很容易出错。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3f#pragma GCC optimize(2)using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;const LL mod=1000000007LL;LL num[100],dp[70][70];LL k,b,d,l,r;LL fastpow(LL jj,LL kk){ if(jj==0LL) return 0LL; LL ret=1; while(kk){ if(kk&amp;1) ret=ret*jj%mod; jj=jj*jj%mod; kk&gt;&gt;=1; } return ret;}LL dfs(LL now,bool limit,bool nozero,LL sum){ if(!now) return fastpow(sum,k); if(!limit&amp;&amp;nozero&amp;&amp;dp[now][sum]!=-1) return dp[now][sum]; LL ret=0,up=limit?num[now]:b-1; // ret+=dfs(now-1,(limit&amp;&amp;(i==up)),nozero||i,sum+(bool)((nozero||i)&amp;&amp;(i==d))); if(d&lt;=up){ ret+=dfs(now-1,(limit&amp;&amp;(d==up)),nozero||d,sum+(bool)(nozero||d)),ret%=mod;//d if(up==0); else{ if(d==0){ ret+=dfs(now-1,(limit),1,sum),ret%=mod;//up ret+=(up-1)*dfs(now-1,0,1,sum),ret%=mod;//other } else if(d==up){ ret+=dfs(now-1,0,nozero,sum),ret%=mod;//0 ret+=(up-1)*dfs(now-1,0,1,sum),ret%=mod;//other } else{ ret+=dfs(now-1,0,nozero,sum),ret%=mod;//0 ret+=dfs(now-1,(limit),1,sum),ret%=mod;//up ret+=(up-2)*dfs(now-1,0,1,sum),ret%=mod;//other } } } else{ if(up==0) ret+=dfs(now-1,(limit),nozero,sum),ret%=mod; else{ ret+=dfs(now-1,0,nozero,sum),ret%=mod;//0 ret+=dfs(now-1,(limit),1,sum),ret%=mod;//up ret+=(up-1)*dfs(now-1,0,1,sum),ret%=mod;//other } } if(!limit&amp;&amp;nozero) dp[now][sum]=ret; return ret;}inline LL getans(LL x){ memset(dp,-1,sizeof(dp)); LL p=0; while(x){ num[++p]=x%b; x/=b; } return dfs(p,true,false,0LL);}inline void solve(){ scanf(\"%lld%lld%lld%lld%lld\",&amp;k,&amp;b,&amp;d,&amp;l,&amp;r); printf(\"%lld\\n\",(getans(r)-getans(l-1)+mod)%mod);}signed main(){ LL t;scanf(\"%lld\",&amp;t); while(t--) solve(); return 0;}","categories":[{"name":"2022杭电多校","slug":"2022杭电多校","permalink":"http://shaun-2314.github.io/categories/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"}]},{"title":"hdu7192,巧用sam","slug":"hdu-7192","date":"2022-08-05T05:58:32.000Z","updated":"2022-08-05T06:26:21.853Z","comments":true,"path":"2022/08/05/hdu-7192/","link":"","permalink":"http://shaun-2314.github.io/2022/08/05/hdu-7192/","excerpt":"","text":"AC/DC题目传送门 前言这是2022hdu多校第5场的1008，当时因为通过率过低，题目都没看，结束后看了之后发现是道 $SAM$ 好题，在这里补一下。 题目大意给出一个初始字符串 $s$ ，有三种操作 $1\\ c$ : 在 $s$ 的末尾加上一个字符 $c$ 。 $2$ : 删掉 $s$ 的最前面的那个字符。 $3\\ t$ : 这里 $t$ 是一个字符串，表示询问字符串 $t$ 在当前的 $s$ 中出现多少次，即询问当前的 $s$ 中有多少个子串 $t$ 。 $T(1 \\leq T \\leq 5)$ 组样例，初始长度为 $n(1 \\leq n \\leq 10^5)$ ，操作数量为 $m(1 \\leq m \\leq 10^5)$ 。 强制在线。 大致思路看完题之后很容易能够想到 $SAM$ ，可以非常有效的进行查询。 但是这道题的操作数过多。朴素使用 $SAM$ 会造成超时。 于是我们想到使用定期重构的思路。 设 $T=\\sqrt n$ ，每 $T$ 次添加或删除字符操作后，就重构 $SAM$ 。对于还没有来得及重构的询问，我们使用字符串 $Hash$ 来进行解决。 对于计数，我们在每次重构 $SAM$ 之后进行一次 $dfs$ 即可更新。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;struct SamNode{ int ch[26]; int len,fa; SamNode(){memset(ch,0,sizeof(ch));len=0;}}sam[MAXX&lt;&lt;2];int las=1,sam_cnt=1;LL num[MAXX&lt;&lt;2];void add(int c){ int p=las;int np=las=++sam_cnt; num[np]=1LL;//此行为计数用，标记出现过几次 sam[np].len=sam[p].len+1; for(;p&amp;&amp;!sam[p].ch[c];p=sam[p].fa) sam[p].ch[c]=np; if(!p) sam[np].fa=1; else{ int q=sam[p].ch[c]; if(sam[q].len==sam[p].len+1) sam[np].fa=q; else{ int nq=++sam_cnt;sam[nq]=sam[q]; sam[nq].len=sam[p].len+1; sam[q].fa=sam[np].fa=nq; for(;p&amp;&amp;sam[p].ch[c]==q;p=sam[p].fa) sam[p].ch[c]=nq; } }}vector&lt;int&gt; to[MAXX&lt;&lt;2];void dfs(int now){ for(int jj:to[now]){ dfs(jj); num[now]+=num[jj]; }}int m,l,r,lasl,lasr;char s[MAXX&lt;&lt;1],a[MAXX];typedef unsigned long long ull;//prim 是自己设置的一个素数,具体数值根据情况而定ull p[MAXX&lt;&lt;1],hashs[MAXX&lt;&lt;1],prim=233;inline void init(){ p[0]=1ull; int maxx=MAXX&lt;&lt;1; for(int i=1;i&lt;maxx;++i) p[i]=p[i-1]*prim;}inline ull gethash(int l,int r){ return hashs[r]-hashs[l-1]*p[r-l+1];}inline bool check(int l,int r,ull jj){ return gethash(l,r)==jj;}inline void build(){ for(int i=1;i&lt;=sam_cnt;++i){ sam[i]=SamNode(); to[i].clear(); num[i]=0LL; } las=sam_cnt=1; for(int i=l;i&lt;=r;++i) add(s[i]-'a'); lasl=l;lasr=r; for(int i=1;i&lt;=sam_cnt;++i) to[sam[i].fa].emplace_back(i); dfs(1); num[0]=num[1]=0;}int getans(int len){ int ans=0,now=1; for(int i=1;i&lt;=len;++i){ now=sam[now].ch[a[i]-'a']; } ans=num[now]; ull hasha=0LL; for(int i=1;i&lt;=len;++i) hasha=hasha*prim+a[i]; for(int i=lasl;i&lt;l&amp;&amp;i+len-1&lt;=lasr;++i){ if(check(i,i+len-1,hasha)) --ans; } for(int i=lasr+1;i&lt;=r&amp;&amp;i-len+1&gt;=l;++i){ if(check(i-len+1,i,hasha)) ++ans; } return ans;}inline void solve(){ getchar();scanf(\"%s\",s+1); l=1;r=strlen(s+1); for(int i=l;i&lt;=r;++i) hashs[i]=hashs[i-1]*prim+s[i]; build(); scanf(\"%d\",&amp;m); int lastans=0,changed=0,rebuild=4000; while(m--){ int cho;scanf(\"%d\",&amp;cho); if(cho==1){ char ch; getchar();scanf(\"%c\",&amp;ch); ch=((ch-'a')^lastans)%26+'a'; s[++r]=ch; hashs[r]=hashs[r-1]*prim+s[r]; ++changed; } else if(cho==2){ ++l;++changed; } else{ getchar();scanf(\"%s\",a+1); int len=strlen(a+1); for(int i=1;i&lt;=len;++i) a[i]=((a[i]-'a')^lastans)%26+'a'; if(changed&gt;=rebuild){ build(); changed=0; } if(r==l-1){ lastans=0; printf(\"%d\\n\",lastans); continue; } lastans=getans(len); // printf(\"%s\\n\",a+1); printf(\"%d\\n\",lastans); } } }signed main(){ init(); LL t;scanf(\"%lld\",&amp;t); while(t--) solve(); return 0;} 总结一般这种定期重构的代码量会比较大，非常容易出错，要耐下心来认真写。 对于 $T$ 的取值，这道题的数据量是 $10^5$ ，我们取 $T=4000$ 。","categories":[{"name":"狂刷字符串","slug":"狂刷字符串","permalink":"http://shaun-2314.github.io/categories/%E7%8B%82%E5%88%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"字符串","slug":"字符串","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://shaun-2314.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"2022杭电多校第5场","slug":"2022hdu-5","date":"2022-08-05T05:50:45.000Z","updated":"2022-08-05T06:30:49.543Z","comments":true,"path":"2022/08/05/2022hdu-5/","link":"","permalink":"http://shaun-2314.github.io/2022/08/05/2022hdu-5/","excerpt":"","text":"2022杭电多校第5场contest传送门 战况 这次总体来看没有之前那么猛 这次我也算是写了0.5道，我和姚老师讨论出了10的结论。 这次有字符串题目，但是通过率都非常低，当时的08连题都没看。 补题08-AC/DC我感觉这是一道非常好的字符串题目，练习 $SAM$ 的使用技巧的非常好的题。于是单独写了一篇。 在这里","categories":[{"name":"2022杭电多校","slug":"2022杭电多校","permalink":"http://shaun-2314.github.io/categories/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"}]},{"title":"2021江苏省赛H题","slug":"cf-gym-103495-H","date":"2022-08-01T11:31:46.000Z","updated":"2022-08-01T11:55:29.192Z","comments":true,"path":"2022/08/01/cf-gym-103495-h/","link":"","permalink":"http://shaun-2314.github.io/2022/08/01/cf-gym-103495-h/","excerpt":"","text":"Reverse the String题目传送门 题意给出一个字符串，有一种操作，将其中一个子串反转，我们可以进行最多一次这样的操作，需要使得这个字符串字典序最小。 $T$ 组数据， $1 \\leq |s| \\leq 10^5$ ， $\\sum|s| \\leq 1.5 * 10^6$ 思路这里又要用到字符串哈希了。 我们使用一个 $pair$ 数组 $suf[]$ 来存下标 $i$ 之后的最小的字母及其最后出现的位置。 容易想到，如果每个位置上的字母都不比后面的字母大，那么这个字符串就已经是字典序最小的了，这时候直接输出就行。 如果对于一个位置 $i$ ， $suf[i].first$ 要小于 $s[i]$ ，那么这时，我们找到这个最小的 $i$ ，说明这时的 $i$ 就是我们需要进行反转操作的子串的起点。我们可以遍历后面的每一个点作为字串的终点，找出一个最优解即可。 那么我们如何进行比较两个终点哪个更优呢，我们可以考虑使用字符串哈希加二分，初始化两个哈希，一个正着，一个反着，对于两个终点，我们使用二分查找反转后的子串的 $lcp$ ，那么比较这个 $lcp$ 后面的那个字母大小关系即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;char,int&gt; P;const int MAXX=100005;int n;char a[MAXX],s[MAXX];typedef unsigned long long ull;//prim 是自己设置的一个素数,具体数值根据情况而定ull p[MAXX],hasha[MAXX],hashs[MAXX],prim=233;inline void init(){ p[0]=1ull; for(int i=1;i&lt;MAXX;++i) p[i]=p[i-1]*prim;}inline ull gethasha(int l,int r){ return hasha[r]-hasha[l-1]*p[r-l+1];}inline ull gethashs(int l,int r){ return hashs[l]-hashs[r+1]*p[r-l+1];}// for(int i=1;i&lt;=n;++i)// hash[i]=hash[i-1]*prim+a[i];P suf[MAXX];inline bool xiao(int st,int en,int enn){ int l=0,r=enn-st+1,mid; while(l&lt;r){ mid=(l+r)/2; if(mid==l){ ++mid; ull jj,kk; if(mid&gt;en-st+1){ jj=gethashs(st,en)*p[mid-(en-st+1)]+gethasha(en+1,en+mid-(en-st+1)); } else jj=gethashs(en-mid+1,en); kk=gethashs(enn-mid+1,enn); if(jj==kk) l=mid; break; } else{ ull jj,kk; if(mid&gt;en-st+1){ jj=gethashs(st,en)*p[mid-(en-st+1)]+gethasha(en+1,en+mid-(en-st+1)); } else jj=gethashs(en-mid+1,en); kk=gethashs(enn-mid+1,enn); if(jj==kk) l=mid; else r=mid-1; } } if(l&gt;=en-st+1) return a[st+l]&lt;a[enn-l]; return a[en-l]&lt;a[enn-l];}inline void solve(){ getchar();scanf(\"%s\",a+1); n=strlen(a+1); a[n+1]='z'; hashs[n+1]=0; for(int i=1;i&lt;=n;++i) hasha[i]=hasha[i-1]*prim+a[i]; for(int i=n;i&gt;=1;--i) hashs[i]=hashs[i+1]*prim+a[i]; suf[n]=P(a[n],n); for(int i=n-1;i&gt;=1;--i){ if(a[i]&lt;suf[i+1].first) suf[i]=P(a[i],i); else suf[i]=suf[i+1]; } int st=0,en=0; for(int i=1;i&lt;=n;++i){ if(a[i]&gt;suf[i].first){ st=i,en=suf[i].second; break; } } if(st==0){ for(int i=1;i&lt;=n;++i) printf(\"%c\",a[i]); printf(\"\\n\"); return; } for(int i=en-1;i&gt;st;--i) if(xiao(st,i,en)) en=i; // printf(\"*%d %d\\n\",st,en);// for(int i=1;i&lt;st;++i) printf(\"%c\",a[i]); for(int i=en;i&gt;=st;--i) printf(\"%c\",a[i]); for(int i=en+1;i&lt;=n;++i) printf(\"%c\",a[i]); printf(\"\\n\");}signed main(){ init(); int t;scanf(\"%d\",&amp;t); while(t--) solve(); return 0;} 总结为什么又是字符串哈希，这种字符串哈希虽然产生冲突的概率很小很小，但是他确实是存在着冲突的，我一般都不敢用这个东西，怕测试点里面会有卡这个冲突的，而且也比较容易被hack，无法完全保证正确性。 字符串哈希我是真不敢用，存在着冲突的概率。但是我想不通为啥好多题都要用到这个，而且正解就是用的这个。","categories":[{"name":"狂刷字符串","slug":"狂刷字符串","permalink":"http://shaun-2314.github.io/categories/%E7%8B%82%E5%88%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"字符串","slug":"字符串","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"},{"name":"二分","slug":"二分","permalink":"http://shaun-2314.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"2022牛客多校第4场","slug":"2022nowcoder-4","date":"2022-07-30T11:59:45.000Z","updated":"2022-07-30T12:53:11.425Z","comments":true,"path":"2022/07/30/2022nowcoder-4/","link":"","permalink":"http://shaun-2314.github.io/2022/07/30/2022nowcoder-4/","excerpt":"","text":"2022牛客多校第4场contest传送门 战况 这次发挥比较平常，看题解才发现这次有一道字符串题目，但是那道题只有一个队写了出来。 补题K-NIO’s Sword题意玩家要打怪，初始有一把攻击力为 $0$ 的剑，需要按顺序从 $1$ 到 $n$ 打怪。 只有剑的攻击力和怪的编号同余的时候才能打败怪物。 玩家可以升级剑，每次升级剑相当于在当前攻击力的后面加上一个数字。 问最少需要升级多少次。 思路记录当前攻击力为 $A$ ，准备打编号为 $i$ 的怪，为了打败他，要进行 $k$ 次升级。 则有式子 $(i-1)*10^k+x \\equiv i(mod n) (0 \\leq x &lt; 10^k)$ 。 直接暴力枚举 $k$ 的值，直到得到的 $w&lt;10^k$ 。 $k$ 即为后面需要加的位数。 当 $n=1$ 时要特判答案为 $0$ 。 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;LL n;inline void solve(){ scanf(\"%lld\",&amp;n); LL ans=0; if(n==1){ printf(\"0\\n\"); return; } for(LL i=1;i&lt;=n;++i){ LL now=1,jj=10; for(;;){ LL kk=(i-((i-1)*jj)%n+n)%n; if(kk&gt;=0&amp;&amp;kk&lt;jj){ ans+=now; break; } ++now; jj*=10; } } printf(\"%lld\\n\",ans);}signed main(){// int t;scanf(\"%d\",&amp;t);// while(t--) solve(); return 0;} 总结要根据题目推式子。 H-Wall Builder II题意给出 $n$ 个 $1 \\times 1$ 的矩形， $n-1$ 个 $1 \\times 2$ 的矩形， $n-2$ 个 $1 \\times 3$ 的矩形 $\\dots$ ， $1$ 个 $1 \\times n$ 的矩形，把这些矩形拼成一个大矩形，使得这个大矩形周长最小，这些矩形不能旋转。 思路我们可以直到这个大矩形的总面积 $S$ 是固定的，我们可以枚举所有可能的长和宽，寻找能不能拼出这个大矩形。使用贪心的思想进行枚举，枚举顺序是周长从小到大即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=205;int n,num[MAXX],S,sum;array&lt;int,4&gt; ans[MAXX*MAXX];inline void solve(){ scanf(\"%d\",&amp;n); sum=n*(n+1)/2; memset(num,0,sizeof(num)); S=0; for(int i=1;i&lt;=n;++i){ num[i]=n+1-i; S+=i*num[i]; } int anslen=0; for(int h=sqrt((double)S);h&gt;=1;--h){ int l=S/h; if(h*l!=S) continue; for(int i=1;i&lt;=n;++i){ num[i]=n+1-i; S+=i*num[i]; } int p=0; bool cannot=false; for(int hi=1;hi&lt;=h;++hi){ int len=0; while(len&lt;l){ bool changed=false; for(int i=min(l-len,n);i&gt;=1;--i){ if(num[i]){ ans[++p]={len,hi-1,len+i,hi}; len+=i;changed=true; --num[i]; break; } } if(!changed){ cannot=true; break; } } if(cannot) break; } if(cannot) continue; anslen=(l+h)*2; break; } printf(\"%d\\n\",anslen); for(int i=1;i&lt;=sum;++i){ printf(\"%d %d %d %d\\n\",ans[i][0],ans[i][1],ans[i][2],ans[i][3]); }}signed main(){ int t;scanf(\"%d\",&amp;t); while(t--) solve(); return 0;} 总结当时没想到可以直接这样枚举，也没有考虑面积恒定这一点，思想一定要多元化。","categories":[{"name":"2022牛客多校","slug":"2022牛客多校","permalink":"http://shaun-2314.github.io/categories/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"}]},{"title":"2022杭电多校第4场","slug":"2022hdu-4","date":"2022-07-28T11:53:46.000Z","updated":"2022-07-28T15:02:03.226Z","comments":true,"path":"2022/07/28/2022hdu-4/","link":"","permalink":"http://shaun-2314.github.io/2022/07/28/2022hdu-4/","excerpt":"","text":"2022杭电多校第4场contest传送门 战况 这次队友的发挥直接起飞，我依旧是算是爆零了(( 这次还是没有出现字符串题目。 补题07-Climb Stairs题意有点像最近网上多次出现的智障广告小游戏 主人公，有一个战斗力，初始时在第 $0$ 层，每一次最多可以向上跳 $k$ 层，或者向下跳一层。每一层都有一个怪兽，有战斗力 $a_i$ 。主人公每次只能达到怪物的战斗力小于等于他的战斗力的所在的层，每到达一层，他都能抢夺怪物的战斗力，加到自己的战斗力上。 每一层最多只能访问一次。 问他能否把所有的怪物都消灭。 思路根据主人公的运动方式限制，可以得出他只能按照类似于这种运动方式进行运动。 于是我们可以直接使用贪心思想进行模拟即可，记录当前的战斗力，当前的位置，要去的位置。 直接进行模拟 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3f3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;int n,k;LL now,a[MAXX];inline void solve(){ scanf(\"%d%lld%d\",&amp;n,&amp;now,&amp;k); for(int i=1;i&lt;=n;++i) scanf(\"%lld\",&amp;a[i]); int l=0,las=0; LL need=0LL,sum=0LL; bool can=false; for(int i=1;i&lt;=n;++i){ if(las+k&lt;i) break; if(a[i]&gt;=need) need=a[i]-now; else{ need=max(need-a[i],a[i]-now); } sum+=a[i]; if(a[i]&lt;=now&amp;&amp;need&lt;=0){ if(i==n) can=true; now+=sum; las=l+1; l=i; need=sum=0LL; } } if(can) printf(\"YES\\n\"); else printf(\"NO\\n\");}signed main(){ int t;scanf(\"%d\",&amp;t); while(t--) solve(); return 0;} 11-Link is as bear题意给出一个长度为 $n$ 的 $long long$ 类型的数组，有一种操作，选个 $l,r\\ (1 \\leq l \\leq r \\leq n)$ ，使里面所有的 $a[i]=xor(l,r)$ ，里面的 $xor(l,r)$ 指的是里面所有元素异或起来的值。 可以进行无数次操作，最后要求使得所有的数都相等且尽可能大，问这个最大的值等于多少。 题目保证初始数组中最少有两个数相等。 思路可以证明，这道题中，从这 $n$ 个数里面任取一些数异或起来的方案，都是可以构造出对应的方案来做到的。 然后，这道题就转化为了在 $n$ 个数中选择一些数，使得这些数的异或值最大。 发现这是一个线性基的板子，直接板子题。 证明的话我直接把题解的证明放这 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3f3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;LL d[70];inline void init(){ for(int i=0;i&lt;=62;++i) d[i]=0LL;}inline void add(LL jj){ for(int i=62;i&gt;=0;--i){ if(jj&amp;(1LL&lt;&lt;i)){ if(!d[i]){ d[i]=jj; break; } jj^=d[i]; } }}inline LL getmax(){ LL ret=0LL; for(int i=62;i&gt;=0;--i) ret=max(ret,ret^d[i]); return ret;}int n;LL a[MAXX];inline void solve(){ init(); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i){ scanf(\"%lld\",&amp;a[i]); add(a[i]); } printf(\"%lld\\n\",getmax());}signed main(){ int t;scanf(\"%d\",&amp;t); while(t--) solve(); return 0;} 01-Link with Bracket Sequence II题意类似于上次的合法括号序列方案。 有长度为 $n$ 的序列，这次里面有 $m$ 种括号(其实时整数表示括号)，分别用一个正数和一个负数来表示左括号和对应的右括号。同样丢失了若干位置的数字，这里是知道丢失的位置的下标，输入时，输入 $0$ 表示这个位置的数字丢失了。 问有多少种合法的括号序列方案可以补全。 思路考虑区间dp， $f[i][j]$ 表示 $a[i]$ 和 $a[j]$ 匹配时子序列 $[i,j]$ 的合法序列方案数， $g[i][j]$ 表示子序列 $[i,j]$ 中所有合法序列方案数。 枚举 $i,j$ 位置上内容，如果能够形成匹配的括号对，则 $f[i][j]=k*g[i+1][j-1]$ ，其中 $k$ 为使得 $a[i]$ 和 $a[j]$ 相匹配的方案数 $g[i][j]=g[i][k-1]+f[k][j]$ ，其中 $k$ 为枚举 $[i,j]$ 中的值。 最后答案取 $g[1][n]$ 即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3f3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=505;const LL mod=1000000007;int n,m,a[MAXX];LL f[MAXX][MAXX],g[MAXX][MAXX];inline void solve(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); if(n%2){ printf(\"0\\n\"); return; } memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); for(int i=0;i&lt;=n;++i) g[i+1][i]=1LL; for(int len=2;len&lt;=n;len+=2){ for(int l=1;l+len-1&lt;=n;++l){ int r=l+len-1; LL jj=0LL; if(a[l]&gt;=0&amp;&amp;a[r]&lt;=0){ if(a[l]==0&amp;&amp;a[r]==0) jj=(LL)m; else if(a[l]==0||a[r]==0) jj=1LL; else if(a[l]+a[r]==0) jj=1LL; } f[l][r]=g[l+1][r-1]*jj%mod; for(int k=l;k&lt;=r;++k) g[l][r]=(g[l][r]+g[l][k-1]*f[k][r]%mod)%mod; } } printf(\"%lld\\n\",g[1][n]);}signed main(){ int t;scanf(\"%d\",&amp;t); while(t--) solve(); return 0;}","categories":[{"name":"2022杭电多校","slug":"2022杭电多校","permalink":"http://shaun-2314.github.io/categories/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"}]},{"title":"2022杭电多校第3场","slug":"2022hdu-3","date":"2022-07-26T12:29:11.000Z","updated":"2022-07-27T15:44:53.190Z","comments":true,"path":"2022/07/26/2022hdu-3/","link":"","permalink":"http://shaun-2314.github.io/2022/07/26/2022hdu-3/","excerpt":"","text":"2022杭电多校第3场contest传送门 战况 这次的题目确实比前两次要难了不少，过题数量比之前要少。 这次里面没有出字符串题目。 补题01-Equipment Upgrade题意有一把武器需要升级，从 $0$ 级升级到 $n$ 级。 对于当前的等级 $i$ ，花费 $c_i$ 金币进行升级，升级成功的概率是 $p_i$ ，会升级到 $i+1$ 级，也有可能升级失败，之后会有 $(1-p_i)\\frac{w_j}{\\sum_{k=1}^{i}w_k}$ 的概率变成 $i-j$ 级$(1 \\leq j \\leq i)$ 。 求从 $0$ 级升级到 $n$ 级所需要的金币的期望。 思路考虑概率DP， $dp[i]$ 表示从第 $i$ 级升级到第 $n$ 级所需要的金币的期望，显然 $dp[n]=0$ 。 首先根据题目可以写出这样一个式子$$dp[i]=p[i]*dp[i+1]+(1-p[i])\\frac{\\sum_{j=1}^{i}(w[j]*dp[i-j])}{\\sum_{k=1}^i w[k]}+c[i]$$这个式子比较复杂，无法进行迭代，于是进行化简， 下面把 $\\sum_{k=1}^i w[k]$ 记作 $pre[i]$ ，即 $w$ 数组的前缀和， 化简之后得$$dp[i]=\\frac{dp[i-1]-c[i-1]}{p[i-1]}-\\frac{1-p[i-1]}{pre[i-1]*p[i-1]}\\sum_{j=1}^{i-1}(w[j]dp[i-1-j])$$我们发现这样的形式仍然不好处理，于是我们想到了每一个 $dp[i]$ 都可以使用 $adp[0]+b$ 这样的一个形式来表示， 于是我们可以用两个数组 $a[i],b[i]$ 来辅助表示， $dp[i]=a[i]*dp[0]+b[i]$ 这里只把公式推导和思路写出，后面的具体实现需要使用分治+卷积，卷积我还不会，后面的就先不写了 09-Package Delivery题意小Q有 $n$ 个包裹，每个包裹有它的存放时间段 $[l[i],r[i]]$ ，暂存点最多可以同时存放 $k$ 个包裹，问小Q最少可以去取多少次包裹 思路使用优先队列来处理这个区间问题，首先将区间进行排序，之后对于每一个区间，如果当前的 $l[i]$ 大于优先队列顶元素，那么就必须要去取一次包裹，但是也有可能这次取完包裹之后 $l[i]$ 仍然大于优先队列顶元素，需要使用一个 $while$ 循环来进行。遍历结束之后再判断优先队列里面是否还有元素。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;int n,k;P a[MAXX];priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq;inline void solve(){ scanf(\"%d%d\",&amp;n,&amp;k); for(int i=1;i&lt;=n;++i) scanf(\"%d%d\",&amp;a[i].first,&amp;a[i].second); sort(a+1,a+n+1); int ans=0; for(int i=1;i&lt;=n;++i){ while(!pq.empty()&amp;&amp;a[i].first&gt;pq.top()){ ++ans; for(int j=1;j&lt;=k;++j){ if(pq.empty()) break; pq.pop(); } } pq.emplace(a[i].second); } while(!pq.empty()){ ++ans; for(int j=1;j&lt;=k;++j){ if(pq.empty()) break; pq.pop(); } } printf(\"%d\\n\",ans);}signed main(){ int t;scanf(\"%d\",&amp;t); while(t--) solve(); return 0;} 12-Two Permutations题意有两个长度为 $n$ 的排列 $P$ 和 $Q$ ，有一种操作，每一次都取走 $P$ 或 $Q$ 的最左边的数，放到一个新的数组 $R$ 中，直到取完为止。 输入两个长度为 $n$ 的排列 $P$ 和 $Q$ ，一个长度为 $2n$ 的数组 $S$ ，问有多少种取法能否使得组成的 $R$ 和 $S$ 相等。 两种取法不同当且仅当其中有至少一次取的排列不同。（第 $i$ 次取 $P$ 和第 $i$ 次取 $Q$ 即为不同）。 思路首先要记录一下数组 $S$ 中每个数字的出现次数，特判一下如果有数字的出现次数不是 $2$ ，则直接输出 $0$ 。 我们考虑动态规划，设 $dp[i][j]$ 表示排列 $P$ 的前 $i$ 项都匹配上了 $S$ ，而且 $P_i$ 匹配的是 $S$ 中第 $j$ 次出现 $P_i$ 的情况下的所有方案数。考虑状态转移，对于每一个 $dp[i][j]$ 的状态，我们枚举 $P_{i+1}$ 要匹配 $S$ 中的哪个位置，即匹配第一次出现的那个还是第二次出现的那个，此时，我们必须保证 $P_i$ 匹配的位置与 $P_{i+1}$ 匹配的位置中间的那段连续子序列必须和 $Q$ 中对应的子序列完全匹配。此时，我们考虑使用字符串 $Hash$ 进行 $O(1)$ 判断。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=300005;typedef unsigned long long ull;const LL mod=998244353;LL n,n2,a[MAXX],s[MAXX],d[2*MAXX],num[MAXX];ull ncf[2*MAXX],hs[MAXX],hd[2*MAXX],p=233;LL id[MAXX][2],dp[MAXX][2];inline void init(){ ncf[0]=1ull; for(int i=1;i&lt;2*MAXX;++i) ncf[i]=ncf[i-1]*p;}inline ull gethash(ull *h,int l,int r){ return h[r]-h[l-1]*ncf[r-l+1];}inline bool check(int ls,int rs,int ld,int rd){ if(ls&gt;rs) return true; if(ls&lt;1||rs&gt;(int)n||ld&lt;1||rd&gt;(int)n2) return false; return gethash(hs,ls,rs)==gethash(hd,ld,rd);}inline void solve(){ scanf(\"%lld\",&amp;n);n2=n+n; for(int i=1;i&lt;=n;++i) scanf(\"%lld\",&amp;a[i]); for(int i=1;i&lt;=n;++i) scanf(\"%lld\",&amp;s[i]),hs[i]=hs[i-1]*p+s[i]; for(int i=1;i&lt;=n;++i) id[i][0]=id[i][1]=0; for(int i=1;i&lt;=n2;++i){ scanf(\"%lld\",&amp;d[i]); hd[i]=hd[i-1]*p+d[i]; if(id[d[i]][0]) id[d[i]][1]=i; else id[d[i]][0]=i; } bool cannot=false; for(int i=1;i&lt;=n;++i) if((!id[i][0])||(!id[i][1])){ cannot=true;break; } if(cannot){ printf(\"0\\n\"); return; } //init for(int i=1;i&lt;=n;++i) dp[i][0]=dp[i][1]=0LL; if(check(1,id[a[1]][0]-1,1,id[a[1]][0]-1)) dp[1][0]=1; if(check(1,id[a[1]][1]-1,1,id[a[1]][1]-1)) dp[1][1]=1; for(int i=1;i&lt;n;++i) for(int j=0;j&lt;=1;++j){ if(dp[i][j]){ int jj=id[a[i]][j]; for(int k=0;k&lt;=1;++k){ int kk=id[a[i+1]][k]; if(kk&lt;=jj) continue; if(check(jj-i+1,kk-i-1,jj+1,kk-1)){ dp[i+1][k]=(dp[i+1][k]+dp[i][j])%mod; } } } } LL ans=0; for(int i=0;i&lt;=1;++i){ if(dp[n][i]){ int jj=id[a[n]][i]; if(check(jj-n+1,n,jj+1,n2)) ans=(ans+dp[n][i])%mod; } } printf(\"%lld\\n\",ans);}signed main(){ init(); int t;scanf(\"%d\",&amp;t); while(t--) solve(); return 0;} 总结得多练练 $dp$ 了！","categories":[{"name":"2022杭电多校","slug":"2022杭电多校","permalink":"http://shaun-2314.github.io/categories/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"}]},{"title":"2022牛客多校第3场","slug":"2022nowcoder-3","date":"2022-07-25T13:42:37.000Z","updated":"2022-07-25T14:44:02.619Z","comments":true,"path":"2022/07/25/2022nowcoder-3/","link":"","permalink":"http://shaun-2314.github.io/2022/07/25/2022nowcoder-3/","excerpt":"","text":"2022牛客多校第3场contest传送门 战况 整体来看没有前几次的好，今天的字符串题目 $H$ 我也没有写出来。 补题H-Hacker题意给出长度为 $n$ 的小写字符串 $A$ 和 $k$ 个长度为 $m$ 的小写字符串 $B_1 … B_k$ ， $B$ 的每个位置拥有统一的权值 $v_1 … v_m$ ，对于每个 $B_i$ 求最大和区间满足该区间构成的字符串是 $A$ 的子串（空区间合法）。 思路首先用给字符串 $A$ 建立一个后缀自动机 之后对于每个字符串 $B_i$ ，通过在后缀自动机上匹配的方法进行对 $B_i$ 的匹配，对于 $B_i$ 的每个位置 $j$ ，求以 $B_{ij}$ 为结尾的在 $A$ 中出现过的最长后缀的最大区间和，每一次取 $max$ 值，遍历完一个串之后就是这个串的 $ans$ 。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=500005;const int MAXN=100005;int n,m,k;LL a[MAXN];char s[MAXN];struct SamNode{ int ch[26]; int len,fa; SamNode(){memset(ch,0,sizeof(ch));len=0;}}sam[MAXX&lt;&lt;1];SamNode temp[MAXX];int las=1,sam_cnt=1;void add(int c){ int p=las;int np=las=++sam_cnt; sam[np].len=sam[p].len+1; for(;p&amp;&amp;!sam[p].ch[c];p=sam[p].fa) sam[p].ch[c]=np; if(!p) sam[np].fa=1; else{ int q=sam[p].ch[c]; if(sam[q].len==sam[p].len+1) sam[np].fa=q; else{ int nq=++sam_cnt;sam[nq]=sam[q]; sam[nq].len=sam[p].len+1; sam[q].fa=sam[np].fa=nq; for(;p&amp;&amp;sam[p].ch[c]==q;p=sam[p].fa) sam[p].ch[c]=nq; } }}inline void solve(){ scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); getchar();scanf(\"%s\",s+1); for(int i=1;i&lt;=m;++i) scanf(\"%lld\",&amp;a[i]); int len=strlen(s+1); for(int i=1;i&lt;=len;++i) add(s[i]-'a'); for(int i=1;i&lt;=k;++i){ getchar();scanf(\"%s\",s+1); len=strlen(s+1); LL ans=0LL,anss=0LL; int now=1; for(int j=1;j&lt;=len;++j){ if(anss&gt;0&amp;&amp;sam[now].ch[s[j]-'a']){ anss+=a[j]; now=sam[now].ch[s[j]-'a']; } else if(sam[1].ch[s[j]-'a']){ anss=a[j]; now=sam[1].ch[s[j]-'a']; } else{ anss=0LL; now=1; } ans=max(ans,anss); } printf(\"%lld\\n\",ans); } }signed main(){// LL t;scanf(\"%lld\",&amp;t);// while(t--) solve(); return 0;} 总结在 $SAM$ 中不一定非要把每个字符串都加到 $SAM$ 中才能进行子串匹配 在这道题中就是只对原串 $A$ 建立了 $SAM$ ，然后对于每一个新串，通过 $trie树$ 的匹配方式进行匹配即可。 J-Journey题意给定一个城市有若干十字路口，右转不需要等红灯，而直行、左转、掉头都需要等红灯，求从起点的路到终点的路最少等多少次红灯。 思路把城市中的每条路当成一个节点，把每个十字路口进行的四种操作当成边，建图，直接 $dijkstra$ 即可解决。 或者也可以不建图，可以直接在 $dijkstra$ 进行顶点转移的操作，最后达到的效果是一样的。 还有一种做法， $bfs$ ，具体原理和上面类似，不再赘述。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;typedef pair&lt;int,P&gt; PP;const int MAXX=500005;struct hashfunc{ template&lt;typename T, typename U&gt; size_t operator() (const pair&lt;T, U&gt; &amp;i) const { return (LL)(i.first)*1000000LL+(LL)(i.second); }};int n,stx,sty,enx,eny;unordered_map&lt;P,int,hashfunc&gt; dij;int c[MAXX][4];void dijs(){ priority_queue&lt;PP,vector&lt;PP&gt;,greater&lt;PP&gt; &gt; pq; pq.emplace(0,P(stx,sty)); dij[P(stx,sty)]=0; while(!pq.empty()){ PP now=pq.top();pq.pop(); P mid=now.second; if(dij[mid]!=now.first) continue; int jk=now.second.second; for(int i=0;i&lt;4;++i){ if(!c[jk][i]) continue; int too=c[jk][i],lenn=1; if(c[jk][(i+3)%4]==now.second.first) lenn=0; if(!dij.count(P(jk,too))||dij[P(jk,too)]&gt;dij[mid]+lenn){ dij[P(jk,too)]=dij[mid]+lenn; pq.emplace(dij[P(jk,too)],P(jk,too)); } } }}inline void solve(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i){ for(int j=0;j&lt;4;++j) scanf(\"%d\",&amp;c[i][j]); } scanf(\"%d%d%d%d\",&amp;stx,&amp;sty,&amp;enx,&amp;eny); dijs(); if(!dij.count(P(enx,eny))) printf(\"-1\\n\"); else printf(\"%d\\n\",dij[P(enx,eny)]);}signed main(){// LL t;scanf(\"%lld\",&amp;t);// while(t--) solve(); return 0;} 总结我当时是图建错了，然后当时 debug 了好久都找不出来是怎么回事，事后才发现是图建错了，但是仍然没找到为什么会错。 之后我放弃了建图的想法，直接在 $dijkstra$ 中进行顶点的转移操作。 在算法没错的情况下，可以尝试考虑是不是图建错了。","categories":[{"name":"2022牛客多校","slug":"2022牛客多校","permalink":"http://shaun-2314.github.io/categories/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"}]},{"title":"cfEduRound-131-Div-2-Summary","slug":"cfEduRound-131-Div-2-Summary","date":"2022-07-09T15:42:46.000Z","updated":"2022-07-09T16:06:05.576Z","comments":true,"path":"2022/07/09/cfeduround-131-div-2-summary/","link":"","permalink":"http://shaun-2314.github.io/2022/07/09/cfeduround-131-div-2-summary/","excerpt":"","text":"Educational Codeforces Round 131 (Div. 2)CONTEST传送门 战况Standing Rating 补题C - Schedule Management错因写二分的时候里面应该要用 $long long$ 存答案的，我用 $int$ 存了，没有注意到最大数据范围会不会超过 $int$ 的范围。 D - Permutation Restoration题目大意有一个排列 $a$ ，然后由排列 $a$ 经过操作 $b_i=\\lfloor\\frac{i}{a_i}\\rfloor$ 得到数组 $b$ 。 输入数组 $b$ ，求出一个符合题意的排列 $a$ 。 思路这道题很像之前写过的有一道区间问题的题目，每个位置上符合条件的数构成了一个区间，我们首先计算出每个位置上的区间的左右端点值，定义一个 $pair$ 的优先队列，规则是小的先出，具体思路为，根据左端点大小给每个区间排个序，左端点小的先入优先队列，入队的 $pair$ 值为 $[r[i],i]$ ，即这个点的右端点值和这个点的 $id$ ，之后根据这个顺序以此从 $1$ 到 $n$ 赋值即可，很像之前的一个区间处理的问题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;unordered_set&gt;#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define Inf 0x3f3f3f3f//#define int long longusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;typedef pair&lt;P,int&gt; PP;const int MAXX=500005;const double eps=0.0000001;const LL mod=1000000007;int n,s[MAXX],a[MAXX];int l[MAXX],r[MAXX];vector&lt;int&gt; pre[MAXX];priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; pq;inline void solve_it(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;s[i]); for(int i=1;i&lt;=n;++i){ int ll=1,rr=n,mid; while(ll&lt;rr){ mid=(ll+rr)/2; if(mid==ll){ if(i/mid!=s[i]) ll=rr; break; } if(i/mid&gt;s[i]) ll=mid+1; else rr=mid; } l[i]=ll; rr=n; while(ll&lt;rr){ mid=(ll+rr)/2; if(mid==ll){ if(i/rr==s[i]) ll=rr; break; } if(i/mid&gt;=s[i]) ll=mid; else rr=mid-1; } r[i]=ll;// printf(\"*%d %d\\n\",l[i],r[i]); } for(int i=1;i&lt;=n;++i) pre[i].clear(); while(!pq.empty()) pq.pop(); for(int i=1;i&lt;=n;++i) pre[l[i]].emplace_back(i); for(int i=1;i&lt;=n;++i){ for(int jj:pre[i]) pq.emplace(P(r[jj],jj)); a[pq.top().second]=i; pq.pop();// printf(\"*%d \",pq.size()); }// printf(\"\\n\"); for(int i=1;i&lt;n;++i) printf(\"%d \",a[i]); printf(\"%d\\n\",a[n]);}signed main(){ LL T;scanf(\"%lld\",&amp;T); while(T--) solve_it(); return 0;} 补充在计算 $l[i]$ 和 $r[i]$ 的值的时候，我是使用二分进行查找的值，但是我看到有的代码是直接给赋值的，应该是有对应的公式 $l[i] = (i + 1) / (b[i] + 1) + 1$ $r[i] = b[i] == 0 ? n : (i + 1) / b[i]$ E - Text Editor对于这道题我进行详细的补题，另写了一篇独立的博客 传送门","categories":[{"name":"cf总结","slug":"cf总结","permalink":"http://shaun-2314.github.io/categories/cf%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"cf","slug":"cf","permalink":"http://shaun-2314.github.io/tags/cf/"}]},{"title":"codeforces-edu131-E-Text Editor","slug":"cf-edu131-E","date":"2022-07-09T05:42:11.000Z","updated":"2022-07-09T14:58:45.446Z","comments":true,"path":"2022/07/09/cf-edu131-e/","link":"","permalink":"http://shaun-2314.github.io/2022/07/09/cf-edu131-e/","excerpt":"","text":"Text Editor题目传送门 题目大意给出两个字符串 $a$ 和 $s$ ，长度分别为 $n$ 和 $m$ ，且 $1≤m≤n≤5000$ ，问经过最少多少次操作能从 $a$ 串变成 $s$ 串，如果不能输出 $-1$ 。初始时光标位于 $a$ 串末尾。有几种操作 “left”，光标向前移动一格 “right”，光标向后移动一格 “home”，光标移动到最前面 “end”，光标移动到最后面 “backspace”，删除 思路考虑每一个公共子串，这个公共子串的右边使用 backspace 直到该公共子串的右侧，而左侧使用 home 先移到最左边，再进行 right 和 backspace 操作，直到该公共子串的左侧。 以此遍历每一个公共子串，每次更新 $ans$ 的值，取 $min$ ，由此得到的最终结果即为所求，相当于是一个 $n^2$ 的 $dp$ 。当然，$ans$ 的值首先要初始化为一路从右到左 backspace 的操作数。 然而，要进行这样的操作，需要知道这个公共子串的左侧能不能满足题目要求，即左侧剩余的字符串能否互相匹配上，右侧同理，因此，我们还需要维护两个数组 $pre[i]$ 和 $suf[i]$ 分别表示在从左到右和从右到左的顺序下，首先能匹配上的下标。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;unordered_set&gt;#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define Inf 0x3f3f3f3f//#define int long longusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;typedef pair&lt;P,int&gt; PP;const int MAXX=5005;const double eps=0.0000001;const LL mod=1000000007;int n,m,pre[MAXX],suf[MAXX];char a[MAXX],s[MAXX];int len[MAXX][MAXX];inline void solve_it(){ scanf(\"%d%d\",&amp;n,&amp;m); getchar();scanf(\"%s\",a+1); getchar();scanf(\"%s\",s+1); bool flag=false; int first=0; for(int i=1,j=1;i&lt;=n;++i){ if(a[i]==s[j]){ pre[j]=i; ++j; } else if(!first) first=i; if(j&gt;m) flag=true; } if(!flag){ printf(\"-1\\n\"); return; } if(n==m){ printf(\"0\\n\"); return; } for(int i=n,j=m;i&gt;=1;--i){ if(a[i]==s[j]){ suf[j]=i; --j; } if(j==0) break; } for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) len[i][j]=((a[i]==s[j])?(len[i-1][j-1]+1):(0)); int n1=n+1,m1=m+1; for(int i=1;i&lt;=n1;++i) len[i][m1]=0; for(int i=1;i&lt;=m1;++i) len[n1][i]=0; int ans=n-first+1; for(int j=1;j&lt;=m;++j) for(int i=pre[i];i&lt;=n;++i){ if(len[i+1][j+1]) continue; int lenn=len[i][j]; if((j==m||suf[j+1]&gt;i)&amp;&amp;(j-lenn==0||pre[j-lenn]&lt;i-lenn)){ int jj=n-i; if(i&gt;j) jj+=i-j+i-lenn+1; ans=min(ans,jj); } } printf(\"%d\\n\",ans);}signed main(){ LL T;scanf(\"%lld\",&amp;T); while(T--) solve_it(); return 0;} 补充此题也可以使用扩展KMP，具体为使用扩展KMP代替上面的求公共子串部分，可以达到一样的效果，但是感觉没有上面的简便。","categories":[{"name":"狂刷字符串","slug":"狂刷字符串","permalink":"http://shaun-2314.github.io/categories/%E7%8B%82%E5%88%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"字符串","slug":"字符串","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"扩展KMP","slug":"扩展KMP","permalink":"http://shaun-2314.github.io/tags/%E6%89%A9%E5%B1%95KMP/"},{"name":"最长公共子串","slug":"最长公共子串","permalink":"http://shaun-2314.github.io/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"}]},{"title":"洛谷P5357，关于AC自动机的优化方案","slug":"luogu-P5357","date":"2022-06-30T11:35:38.000Z","updated":"2022-06-30T12:09:54.821Z","comments":true,"path":"2022/06/30/luogu-p5357/","link":"","permalink":"http://shaun-2314.github.io/2022/06/30/luogu-p5357/","excerpt":"","text":"【模板】AC 自动机（二次加强版）题目传送门 题目大意给你一个文本串 $S$ 和 $n$ 个模式串 $T_{1 \\sim n}$ ，请你分别求出每个模式串 $T_i$ 在 $S$ 中出现的次数。 当时写题过程 当时看到题目后，看着和前面一个模板题一模一样，于是，就直接把前面一个的代码 copy 了过来，交了一发，出现了第一幕，40分，里面不是 WA 就是 TLE ，我想不通为什么会有 WA ，于是，我又重新读了一遍题，发现这道题里面 数据不保证任意两个模式串不相同 。 我想先保证算法的正确性，然后再进行优化操作，于是，把这里改了一下之后，就又交了一发，果然，这一发里面就只有 TLE 了，那么问题来了，该怎么优化呢。 当时想到了在匹配的过程中不进行答案的汇总，而是只进行汇总 Trie 树里面的每个节点到过的次数，等匹配结束之后再总的进行答案的汇总。果然，这次 TLE 的测试点数就少了好多，但是仍然无法AC。 之后，我又想到了在 bfs() 中把每个 Trie 树的节点所对应的单词汇总，这样就不需要每次都往根部递归求值了，结果，测试点中终于没有 TLE 了，但是，又出现了三个 MLE ，每个 Trie 树节点存的单词数量太大了，这个方法也行不通。 最后，我就想，有没有一种可能，我可以记录他在 bfs() 的过程中的 bfs 序，然后，在匹配的过程中只记录每个节点到过的次数，最后，在匹配结束之后，利用 bfs 序的逆序进行遍历，每遍历一个点，就把这个点往根部递归的第一个点的访问次数加上这个点的访问次数，以此递推，即可得出答案数组。 思路首先，在匹配的过程中，我们只需要记录每个点的访问次数，这里用 $nnum$ 数据进行记录。在匹配结束之后，为了防止递归式的求解(因为这样会一直重复访问一些(数据量非常大)节点)，我们需要遍历一遍就能求解出答案的方法。于是，我们需要一个特殊的遍历序列，这个序列需要满足后遍历的节点在递归的思路里面不会到达先遍历的节点，而且先遍历的节点需要能够把他的访问次数传递到他在递归的思路中到达的后遍历的节点。刚好，我们在 bfs() 的过程的序列刚好就是这个序列的逆序列。于是，我们记录下来在 bfs() 过程中的访问顺序，在最后求解答案的时候再逆序访问即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;unordered_set&gt;#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define Inf 0x3f3f3f3f//#define int long longusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;typedef pair&lt;P,int&gt; PP;const int MAXX=2000005;const double eps=0.0000001;const LL mod=998244353;const int id_max=MAXX;int n,flag[id_max],fail[id_max];int trie[id_max][26],id_cnt;vector&lt;int&gt; id[id_max];char s[MAXX];int num[MAXX];//初始化，用于多组数据输入 void init(){ id_cnt=0; for(int i=0;i&lt;id_max;++i){ flag[i]=fail[i]=0; id[i].clear(); for(int j=0;j&lt;26;++j) trie[i][j]=0; }}//向插入字典树中插入一个单词 void ins(char s[]){ int len=strlen(s+1); int now=0; for(int i=1;i&lt;=len;++i){ if(trie[now][s[i]-'a']==0) trie[now][s[i]-'a']=++id_cnt; now=trie[now][s[i]-'a']; } ++flag[now];}//向插入字典树中插入一个单词，并与输入顺序进行链接 void ins(char s[],int idd){ int len=strlen(s+1); int now=0; for(int i=1;i&lt;=len;++i){ if(trie[now][s[i]-'a']==0) trie[now][s[i]-'a']=++id_cnt; now=trie[now][s[i]-'a']; } id[now].emplace_back(idd);}int bfsn[id_max];//链接fail指针 void bfs(){ queue&lt;int&gt; qq; for(int i=0;i&lt;26;++i) if(trie[0][i]) qq.emplace(trie[0][i]); int bfs_cnt=0; while(!qq.empty()){ int now=qq.front();qq.pop(); bfsn[++bfs_cnt]=now; for(int i=0;i&lt;26;++i){ if(trie[now][i]){ fail[trie[now][i]]=trie[fail[now]][i]; qq.emplace(trie[now][i]); } else trie[now][i]=trie[fail[now]][i]; }// int fa=fail[now];// id[now].insert(id[now].end(),id[fa].begin(),id[fa].end()); }}//返回字典中有多少个单词在s串中出现过 int getone(char s[]){ int now=0,len=strlen(s+1); int ret=0; for(int i=1;i&lt;=len;++i){ now=trie[now][s[i]-'a']; int jj=now; while(jj&gt;0&amp;&amp;flag[jj]!=-1){ ret+=flag[jj]; flag[jj]=-1; jj=fail[jj]; } } return ret;}int nnum[id_max];//需事先定义num数组，用于保存每个单词在s串中出现过几次 void getnum(char s[]){ memset(num,0,sizeof(num)); int now=0,len=strlen(s+1); for(int i=1;i&lt;=len;++i){ now=trie[now][s[i]-'a']; ++nnum[now]; }}inline void solve_it(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i){ getchar(); scanf(\"%s\",s+1); ins(s,i); } bfs(); getchar();scanf(\"%s\",s+1); getnum(s); for(int i=id_cnt;i&gt;0;--i){ int now=bfsn[i]; nnum[fail[now]]+=nnum[now]; int si=id[now].size(); for(int j=0;j&lt;si;++j) num[id[now][j]]+=nnum[now]; } for(int i=1;i&lt;=n;++i){ printf(\"%d\\n\",num[i]); } // printf(\"%d\\n\",getone(s));}signed main(){// LL T;scanf(\"%lld\",&amp;T);// while(T--) solve_it(); return 0;} 总结这道题的变数感觉好多，当时写完这道题之后我去翻了翻题解，发现并没有我这样的写法，题解中的写法各式各样，思路众多，以后写这类题目一定要从多个方面进行思考。","categories":[{"name":"狂刷字符串","slug":"狂刷字符串","permalink":"http://shaun-2314.github.io/categories/%E7%8B%82%E5%88%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"字符串","slug":"字符串","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://shaun-2314.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"洛谷P3294，一道思路奇妙的Trie树题目","slug":"luogu-P3294","date":"2022-06-28T12:17:34.000Z","updated":"2022-06-30T11:33:48.593Z","comments":true,"path":"2022/06/28/luogu-p3294/","link":"","permalink":"http://shaun-2314.github.io/2022/06/28/luogu-p3294/","excerpt":"","text":"[SCOI2016]背单词题目传送门 前言参考这篇博客 题目大意输入 $n$ 个单词，要求我们给他进行重新排列，使得按以下规则花费最小 如果存在一个单词是它的后缀，并且当前没有被填入表内，那花费 $+= n*n$ ； 当它的所有后缀都被填入表内的情况下，如果在 $1 … x-1$ 的位置上的单词都不是它的后缀，那么花费 $+= x$ ； 当它的所有后缀都被填入表内的情况下，如果 $1 … x-1$ 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 $y$ ，那么花费 $+=x-y$ 。 思路读懂题意之后，可以将题意转化为 使得每个单词的后缀都在这个单词前面，且距离尽量近。 题目中需要的后缀，但是后缀不太好处理，于是我们想到把单词反转，用前缀表示后缀。以此可以建出 Trie 树 建好 Trie 树之后，我们呢还需要对这棵树进行重构操作，忽略上面的非单词结尾的点，将每个单词的结尾位置进行相连，即单词之间直接相连。 之后，我们还需要利用 dfs 再对这棵树进行重构，具体内容是将每个节点的子节点进行排序，按以子节点为根的子树的节点数从小到大的规则进行排序。 然后对这样重构之后的树直接进行遍历就是最后的序列，即 dfs 序就是最终的序列。使用 dfs 即可得到答案。 dfs 序为什么正确？ 考虑重新建树之后，i节点的子树中的所有节点的后缀都是 $i$ 如果同一深度上有不止一棵子树，那么我们先在一棵上取出一个叶子节点 $j$ ，再取出一个根节点 $i$ ，我们发现如果 $j&gt;i$ 的话肯定不如 $i&lt;j$ 优秀 因为调整之后i的子树上所有节点对花费的贡献 $-=$ 子树大小， $j$ 对花费的贡献 $+1$ ，所以我们可以看到 $j&gt;i$ 的花费 $&lt;=i&gt;j$ 的情况 最后我们经过所有的调整可以发现序列变成了 dfs 序 所以 dfs 序最优 最后答案记得用 long long . 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=510005;int n;char s[MAXX];int trie[MAXX][26],id_cnt;bool vis[MAXX];int num[MAXX];vector&lt;int&gt; to[MAXX];void insert(){ int now=0,len=strlen(s+1); for(int i=1;i&lt;=len;++i){ if(trie[now][s[i]-'a']==0) trie[now][s[i]-'a']=++id_cnt; now=trie[now][s[i]-'a']; } vis[now]=true;}void rebuild(int now,int last){ if(vis[now]){ to[last].emplace_back(now); for(int i=0;i&lt;26;++i) if(trie[now][i]) rebuild(trie[now][i],now); } else{ for(int i=0;i&lt;26;++i) if(trie[now][i]) rebuild(trie[now][i],last); }}bool cmp(int jj,int kk){return num[jj]&lt;num[kk];}void dfs(int now){ int si=to[now].size(); num[now]=1; for(int i=0;i&lt;si;++i){ dfs(to[now][i]); num[now]+=num[to[now][i]]; } sort(to[now].begin(),to[now].end(),cmp);}int dfn[MAXX],dfn_cnt=-1;LL getans(int now,int last){ LL ret=0; dfn[now]=++dfn_cnt; if(last==0) ret+=dfn[now]; else ret+=dfn[now]-dfn[last]; int si=to[now].size(); for(int i=0;i&lt;si;++i) ret+=getans(to[now][i],now); return ret;}inline void solve(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i){ scanf(\"%s\",s+1); reverse(s+1,s+strlen(s+1)+1); insert(); } rebuild(0,0); dfs(0); printf(\"%lld\\n\",getans(0,0));}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) solve(); return 0;} 总结这道题里面的思维非常的妙，使用前缀来表示后缀，以此可以直接使用 Trie 树。 还有对 Trie 树进行重构，都非常的巧妙。","categories":[{"name":"狂刷字符串","slug":"狂刷字符串","permalink":"http://shaun-2314.github.io/categories/%E7%8B%82%E5%88%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"字符串","slug":"字符串","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Trie 树","slug":"Trie-树","permalink":"http://shaun-2314.github.io/tags/Trie-%E6%A0%91/"}]},{"title":"牛客16638，一道比较经典的KMP题目","slug":"nowcoder-16638","date":"2022-06-27T05:26:23.000Z","updated":"2022-08-24T07:25:30.198Z","comments":true,"path":"2022/06/27/nowcoder-16638/","link":"","permalink":"http://shaun-2314.github.io/2022/06/27/nowcoder-16638/","excerpt":"","text":"carpet题目传送门 题目大意给出一个 $n * m$ 的字符矩阵，每个位置有一个 $cost$ ，找出这个矩阵的最小循环子矩阵 $p$ 行 $q$ 列，即最小二维循环周期，之后再找出每一个这样大小的子矩阵的 $cost$ 的最大值，再取最小值为 $A$ ，输出 $A*(p+1)*(q+1)$ 即可。 思路分三步，首先要求出字符矩阵的最小循环子矩阵的行数和列数，之后再对每一个这样大小的子矩阵的 $max{cost}$ 进行求 $min$ ，最后，输出答案即可。 针对第一步，我们采用KMP算法。 我们求出每一行的 $p[i]$ 值，之后利用 $p[i]$ 值将每一行的所有循环节长度(即周期)求出来，用 map 记录每个周期的出现次数，遍历完每一行之后，找出 map 中记录的出现了 m 次的周期的最小值，即为最小循环子矩阵的列数 $q$ 。 $p$ 的求法和 $q$ 一样，对每一列进行同样的操作即可。 针对第二步，我们采用优先队列优化的滑动窗口。 考虑到数据量较大，我们要首先对每一列进行滑动窗口的操作，记录下第 $i$ 行第 $j$ 列的 $max{cost[i-p+1 … i][j]}$ 。以此来优化矩阵的滑动窗口操作，变成了线性。 之后，我们对每一个 $p$ 行 $q$ 列的子矩阵进行求解，遍历每一行，每次可直接调用上一步求出的值，即可求出 $A$ 。 输出答案 $A*(p+1)*(q+1)$ ，注意这个结果是可能超过 int 的范围的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;unordered_set&gt;#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define Inf 0x3f3f3f3f//#define int long longusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;typedef pair&lt;P,int&gt; PP;const int MAXX=1000005;const double eps=0.0000001;int n,m,p[MAXX];void lgetpmt(const vector&lt;vector&lt;char&gt; &gt;&amp; a,int k){ for(int i=1,j=0;i&lt;m;++i){ while(j&gt;0&amp;&amp;a[k][i+1]!=a[k][j+1]) j=p[j]; if(a[k][i+1]==a[k][j+1]) ++j; p[i+1]=j; }}void tgetpmt(const vector&lt;vector&lt;char&gt; &gt;&amp; a,int k){ for(int i=1,j=0;i&lt;n;++i){ while(j&gt;0&amp;&amp;a[i+1][k]!=a[j+1][k]) j=p[j]; if(a[i+1][k]==a[j+1][k]) ++j; p[i+1]=j; }}inline void solve_it(){ scanf(\"%d%d\",&amp;n,&amp;m); vector&lt;vector&lt;char&gt; &gt; a(n+2,vector&lt;char&gt;(m+2)); vector&lt;vector&lt;int&gt; &gt; c(n+2,vector&lt;int&gt;(m+2)); for(int i=1;i&lt;=n;++i){ getchar(); for(int j=1;j&lt;=m;++j) scanf(\"%c\",&amp;a[i][j]); } for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) scanf(\"%d\",&amp;c[i][j]); map&lt;int,int&gt; left,top; int l=m,t=n; for(int i=1;i&lt;=n;++i){ lgetpmt(a,i); int jj=p[m]; while(jj!=0){ ++left[m-jj]; if(left[m-jj]==n) l=min(l,m-jj); jj=p[jj]; } } for(int i=1;i&lt;=m;++i){ tgetpmt(a,i); int jj=p[n]; while(jj!=0){ ++top[n-jj]; if(top[n-jj]==m) t=min(t,n-jj); jj=p[jj]; } } // printf(\"*%d %d\\n\",t,l);//t行l列 1 2 priority_queue&lt;P&gt; pq; vector&lt;vector&lt;int&gt; &gt; topmax(n+2,vector&lt;int&gt;(m+2)); for(int j=1;j&lt;=m;++j){ while(!pq.empty()) pq.pop(); for(int i=1;i&lt;=t;++i) pq.emplace(c[i][j],i); topmax[t][j]=pq.top().first; for(int i=t+1;i&lt;=n;++i){ pq.emplace(c[i][j],i); while(pq.top().second&lt;=i-t) pq.pop(); topmax[i][j]=pq.top().first; } } int ans=Inf; for(int i=t;i&lt;=n;++i){ while(!pq.empty()) pq.pop(); for(int j=1;j&lt;=l;++j) pq.emplace(topmax[i][j],j); ans=min(ans,pq.top().first); for(int j=l+1;j&lt;=m;++j){ pq.emplace(topmax[i][j],j); while(pq.top().second&lt;=j-l) pq.pop(); ans=min(ans,pq.top().first); } } // printf(\"*%d\\n\",ans);// printf(\"%lld\\n\",((LL)ans)*((LL)(l+1))*((LL)(t+1)));}signed main(){// LL T;scanf(\"%lld\",&amp;T);// while(T--) solve_it(); return 0;} 总结感觉这道题涉及了很多内容，可以当作一道比较经典的应用KMP进行求解的题目了。 前面因为所有循环节的求法写错了，导致调了半天一直调不出来，要牢记。 所有循环节的求法 12345int jj=p[n];while(jj!=0){ ans.emplace_back(n-jj);//这里的 n-jj 均为循环节，ans记录所有循环节 jj=p[jj];}","categories":[{"name":"狂刷字符串","slug":"狂刷字符串","permalink":"http://shaun-2314.github.io/categories/%E7%8B%82%E5%88%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"字符串","slug":"字符串","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"KMP","slug":"KMP","permalink":"http://shaun-2314.github.io/tags/KMP/"}]},{"title":"cfEduRound-130-Div-2-Summary","slug":"cfEduRound-130-Div-2-Summary","date":"2022-06-16T07:53:39.000Z","updated":"2022-06-29T13:52:01.124Z","comments":true,"path":"2022/06/16/cfeduround-130-div-2-summary/","link":"","permalink":"http://shaun-2314.github.io/2022/06/16/cfeduround-130-div-2-summary/","excerpt":"","text":"Educational Codeforces Round 130 (Div. 2)CONTEST传送门 战况Standing Rating 补题D - Guess The String题目大意这是一道交互题，首先输入一个整数，表示一个字符串的长度(1&lt;=n&lt;=1000)。我们需要通过询问推这个字符串并最终输出，询问包括两种 ? 1 i 表示询问第i个位置的字符是什么，将输入一个字符表示答案。 ? 2 l r 表示询问从下标l到r，中间有多少个不同的字母，将输入一个整数表示答案。 第一种询问不能超过26次，第二种询问不能超过6000次。 当时的思路先用一个整数表示一个位置的字符，相同的整数表示同一个字符。 遍历字符串，对于每一个位置 i，从当前位置 i 往前遍历 j ，每找到一个此次遍历未见过的字符，便询问 ? 2 i j ，找到那个第一个等于 区间已知字符的不同的数量+1 的位置，那个位置之前遍历的那个位置的字符便对应于位置 i 的字符。 最后再询问每一个整数对应的字符。 错因第二种询问的询问次数过多。 改进因为是26个字母，注意到 $\\log_2(26)=4.7\\leq 5$ ,于是我们便可以使用二分进行查询，即可通过。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define Inf 0x3f3f3f3f//#define int long longusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;typedef pair&lt;int,P&gt; PP;const int MAXX=1005;const double eps=0.0000001;struct CC{ char ans; int num;}a[MAXX];int n,num_cnt,last[MAXX],s[MAXX];char getans[MAXX];inline void solve_it(){ scanf(\"%d\",&amp;n); a[1].num=num_cnt=1; last[1]=1; for(int i=2;i&lt;=n;++i){ int l=1,r=num_cnt+1,mid,in; for(int j=1;j&lt;=num_cnt;++j) s[j]=last[j]; sort(s+1,s+num_cnt+1); while(l&lt;r){ mid=(l+r)/2; printf(\"? 2 %d %d\\n\",s[mid],i); fflush(stdout); scanf(\"%d\",&amp;in); if(in==num_cnt-mid+1)//=n l=mid+1; else r=mid; } if(l==1){ a[i].num=++num_cnt; last[num_cnt]=i; } else{ int flag=s[l-1]; for(int j=1;j&lt;=num_cnt;++j) if(last[j]==flag){ a[i].num=j; last[j]=i; break; } } } for(int i=1;i&lt;=n;++i){ if(!getans[a[i].num]){ printf(\"? 1 %d\\n\",i); fflush(stdout); char in; cin&gt;&gt;in; getans[a[i].num]=in; } a[i].ans=getans[a[i].num]; } printf(\"! \"); for(int i=1;i&lt;=n;++i) printf(\"%c\",a[i].ans); printf(\"\\n\"); fflush(stdout);}signed main(){// int T;scanf(\"%d\",&amp;T);// while(T--) solve_it(); return 0;} 总结当时脑子里也出现过使用二分的想法，但是由于二分写的太少，非常不熟练，短时间内无法写出来，于是便放弃了二分的想法。 还是得多练二分。","categories":[{"name":"cf总结","slug":"cf总结","permalink":"http://shaun-2314.github.io/categories/cf%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"cf","slug":"cf","permalink":"http://shaun-2314.github.io/tags/cf/"}]},{"title":"还记得小时候的梦想吗","slug":"childhool-dream-thinking","date":"2022-06-08T07:01:39.000Z","updated":"2022-06-08T13:01:51.509Z","comments":true,"path":"2022/06/08/childhool-dream-thinking/","link":"","permalink":"http://shaun-2314.github.io/2022/06/08/childhool-dream-thinking/","excerpt":"","text":"还记得小时候的梦想吗前言中午刷B站看到了一个视频有感 “cheems，你要去码头整点薯条吗？” 看得我泪目了，感触很深，写下此文。 送给每一个被生活埋葬梦想的人。 重新拿起铲子，把梦想挖出来吧。 然后去码头，整点薯条！ 感触刚开始看到这个标题的时候，我以为是什么搞笑类的视频，就点开看了，结果打开一看，有26分钟，发现不对劲。然后越看越感觉真实，看到一半左右的时候就已经泪目了。 在现在这样的社会环境下，有不知多少孩子的最真实的梦想被扼杀在了萌芽当中，可能是想去北极看一次极光(只是因为想去亲眼看看)，可能是想当一名画家(只是因为喜欢画画)，还可能是想当一名科学家(只是因为喜欢研究的感觉)，梦想很多，但最初始的梦想一般不会是搞钱。生活会把梦想埋葬。 现在的我，感觉已经没有了梦想，也想不起来小时候的梦想了，甚至不确定小时候是否有过梦想，但是我感觉应该是有的，至少曾经有过。我记得我在小学的时候有过一个密码本，是四位数的密码，但是我现在也不缺定我是否还记得密码是什么，等寒假回家之后，我一定要找到这个密码本，这里面可能有我被埋葬的梦想，至少希望有点线索。不知我还能不能拿起我的铲子，把梦想挖出来。 但是我的梦想是什么时候被埋葬的，我自己也不清楚了，可能在我想努力成为一名“好孩子”的时候就已经埋葬了吧。 不知到什么时候，我才能再去码头，整点薯条！","categories":[{"name":"一些感悟","slug":"一些感悟","permalink":"http://shaun-2314.github.io/categories/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"梦想","slug":"梦想","permalink":"http://shaun-2314.github.io/tags/%E6%A2%A6%E6%83%B3/"}]},{"title":"个人板子总结","slug":"template-summary","date":"2022-04-22T05:27:21.000Z","updated":"2022-10-23T12:00:45.349Z","comments":true,"path":"2022/04/22/template-summary/","link":"","permalink":"http://shaun-2314.github.io/2022/04/22/template-summary/","excerpt":"","text":"一个自己经常使用的板子的汇总主要是为了自己在需要用的时候能够很快找到对应的板子而写下本篇。 字符串字符串小日记 有种非常妙的思路：后缀转前缀 具体：把字符串 reverse ，再 insert 到 Trie 树里，可模拟后缀。 一定要看清楚题目！！！！！！！ 一定要看清楚模式串中间有没有重复的串！！！ 一定要看清楚具体每个字符串的数据范围，一般 MAXX 表示有几个串，但是最后的文本串可能会是 $1e6$ 的。 感觉字符串的题目一般很难直接抄板子，除了一些固定的步骤， 一般都要从头手打一遍 ，因为每次题目中的要求，条件等等都会变，一定要深度理解算法的思想，到时候做题才能更灵活。 字符串的题目灵活性太高了，可以试试从多个不同的角度进行思考。感觉很多题目都是会有很多种解法(优化方法)。 如果有时间的话，一定要多复习复习前面学过的内容，这些东西太容易忘了。 要多变通，不要死磕一种死方法。 一些常用结论和技巧 一个长度为 $n$ 的字符串一共有 $\\frac{n(n+1)}{2}$ 个子串。 字符串中重复了的子串的个数等于 $\\sum_{i=1}^{n} height[i]$ ，故一个字符串的所有不同子串个数就等于 $\\frac{n(n+1)}{2}-\\sum_{i=1}^{n} height[i]$ 。 多次询问字串 $s(l,r)$ 的出现次数 二分+$SA$ 最长重复子串（可重叠） $ans=\\max{height[i]}$ 两个字符串的最长公共子串 记录每一次的公共子串的长度 大致思路为下图，对角线即为重复子串。 123for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) len[i][j]=((a[i]==s[j])?(len[i-1][j-1]+1):(0)); waiting SAM使用技巧 在 $SAM$ 中 $len[i]-len[fa[i]]$ 表示 $sam[i]$ 中表示了几个字符串。 记录每个子串的出现次数(求 $|Right[s]|$ ) 在 add 模板中要有初始化 $num[np]=1$ 。 构造出 parent树 。 直接 dfs 。 例子： 12345678910vector&lt;int&gt; to[MAXX&lt;&lt;1];void dfs(int now){ for(int jj:to[now]){ dfs(jj); num[now]+=num[jj]; }}for(int i=1;i&lt;=sam_cnt;++i) to[sam[i].fa].emplace_back(i);dfs(1); 多少个本质不同的子串 在 $SAM$ 上从根节点开始的每一条路径都是一个子串且不重复，故直接在 $SAM$ 上跑 $DP$ 即可。 例子： 123456789LL ans[MAXX&lt;&lt;1];LL dfs(int now){ if(ans[now]) return ans[now]; for(int i=0;i&lt;26;++i) if(sam[now].ch[i]) ans[now]+=dfs(sam[now].ch[i]); return ++ans[now];}printf(\"%lld\\n\",dfs(1)-1); 两个字符串的本质不同公共子串个数 两个字符串依此插入到同一个 $sam$ 中，但是，每开始一个新的子串，就得将 $las=1$ ，达到从这个字符串的开头开始的效果。 $add$ 操作也要加一个标记，在结构体中新加变量 $bool\\ vis[2]$ ，用于标记在哪个串中出现过没有。 在 $add$ 函数最后一行加上 for(;np&amp;&amp;!sam[np].vis[jj];np=sam[np].fa) sam[np].vis[jj]=true; ，即可达到标记的效果。 最后遍历一遍 $sam$ 中的每一个点，如果这个点表示的状态的 $vis[0]==true&amp;&amp;vis[1]==true$ ，就 $ans+=sam[i].len-sam[sam[i].fa].len$。 例子： 1234567891011121314151617181920void add(int c,int jj){ ... for(;np&amp;&amp;!sam[np].vis[jj];np=sam[np].fa) sam[np].vis[jj]=true;}inline void solve(){ for(int i=1;i&lt;=2;++i){ scanf(\"%s\",s+1);getchar(); n=strlen(s+1); las=1; for(int j=1;j&lt;=n;++j) add(s[j]-'a',i-1); } for(int i=1;i&lt;=sam_cnt;++i) if(sam[i].vis[0]&amp;&amp;sam[i].vis[1]) ans+=sam[i].len-sam[sam[i].fa].len; printf(\"%lld\\n\",ans);} 如果有多个匹配串与一个模式串进行子串匹配，那么可以只对模式串进行建立 $SAM$ ，之后对于每一个匹配串，使用类似于 $trie树$ 的匹配方式进行匹配。之后可以使用动态规划的思想，搞出最长匹配长度。 对于有 $m$ 次操作且 $m$ 很大且会改变原字符串的情况，我们可以考虑定期重构。 设 $T=\\sqrt n$ ，每 $T$ 次添加或删除字符操作后，就重构 $SAM$ 。对于还没有来得及重构的询问，我们使用字符串 $Hash$ 来进行解决。 对于对字符串前面添加新字符还是前面删除字符都适用。 KMP模板12345678910111213141516171819202122232425262728char l[MAXX],s[MAXX];int lenl,lens,p[MAXX];void getpmt(){ p[1]=0; for(int i=1,j=0;i&lt;lens;++i){ while(j&gt;0&amp;&amp;s[i+1]!=s[j+1]) j=p[j]; if(s[i+1]==s[j+1]) ++j; p[i+1]=j; }}void getans(){ for(int i=0,j=0;i&lt;lenl;++i){ while(j&gt;0&amp;&amp;l[i+1]!=s[j+1]) j=p[j]; if(l[i+1]==s[j+1]) ++j; if(j==lens){ //dosomething printf(\"%d\\n\",i-j+2); // j=p[j]; } }} KMP求最小循环节1234//首先要求出p数组（即next数组）//字符串长度为len//循环节的长度为int l=len-p[len]; KMP求所有循环节12345int jj=p[n];while(jj!=0){ ans.emplace_back(n-jj);//这里的 n-jj 均为循环节，ans记录所有循环节 jj=p[jj];} 前缀函数自动机？12345678910111213141516int n;char s[MAXX];//fail数组即为pmt数组,ch数组表示转移int fail[MAXX],ch[MAXX][26];ch[0][s[1]-'a']=1;for(int i=2;i&lt;=n;++i){ for(int j=0;j&lt;26;++j){ if(s[i]-'a'==j){ ch[i-1][j]=i; fail[i]=ch[fail[i-1]][j]; } else ch[i-1][j]=ch[fail[i-1]][j]; }} 扩展KMP123456789101112131415161718192021//int z[MAXX],p[MAXX];void Z(char* s,int n){ z[1]=n; for(int i=2;i&lt;=n;++i) z[i]=0; for(int i=2,l=0,r=0;i&lt;=n;++i){ if(i&lt;=r) z[i]=min(z[i-l+1],r-i+1); while(i+z[i]&lt;=n&amp;&amp;s[i+z[i]]==s[z[i]+1]) ++z[i]; if(i+z[i]-1&gt;r) l=i,r=i+z[i]-1; }}void exkmp(char* a,int n,char* s,int m){ Z(s,m); for(int i=1;i&lt;=n;++i) p[i]=0; for(int i=1,l=0,r=0;i&lt;=n;++i){ if(i&lt;=r) p[i]=min(z[i-l+1],r-i+1); while(i+p[i]&lt;=n&amp;&amp;a[i+p[i]]==s[p[i]+1]) ++p[i]; if(i+p[i]-1&gt;r) l=i,r=i+p[i]-1; }}//exkmp(a,n,s,m); 字符串 $Hash$1234567891011121314151617typedef unsigned long long ull;//prim 是自己设置的一个素数,具体数值根据情况而定ull p[MAXX],hashs[MAXX],prim=233;inline void init(){ p[0]=1ull; for(int i=1;i&lt;MAXX;++i) p[i]=p[i-1]*prim;}inline ull gethash(int l,int r){ return hashs[r]-hashs[l-1]*p[r-l+1];}inline bool check(int l,int r,ull jj){ return gethash(l,r)==jj;}// for(int i=1;i&lt;=n;++i)// hashs[i]=hashs[i-1]*prim+s[i]; Trie树(字典树)1234567891011121314151617181920212223242526272829303132333435363738394041/*Trie树更重要的是思路碰到题目一般不会直接这样考模板要灵活变通*/class Trie{private: const static int maxid=MAXX*50; int trie[maxid][26],id_cnt; bool is_word[maxid];public: Trie(); void insert(char* jj); bool find(char* jj);};Trie::Trie(){ for(int i=0;i&lt;maxid;++i) for(int j=0;j&lt;26;++j) trie[i][j]=0; id_cnt=0; for(int i=0;i&lt;maxid;++i) is_word[i]=false;}void Trie::insert(char* jj){ int now=0,len=strlen(jj+1); for(int i=1;i&lt;=len;++i){ if(trie[now][jj[i]-'a']==0) trie[now][jj[i]-'a']=++id_cnt; now=trie[now][jj[i]-'a']; } is_word[now]=true;}bool Trie::find(char* jj){ int now=0,len=strlen(jj+1); for(int i=1;i&lt;=len;++i){ if(trie[now][jj[i]-'a']==0) return false; now=trie[now][jj[i]-'a']; } return is_word[now];} Border树(next树) 概念及性质概念 一个字符串长度为 $n$ 。 在 Border 树中，共有 $n+1$ 个节点， $0$ 是这棵有向树的根节点，对于其他每个点 $1 \\le i \\le n$ ，父节点为 $next[i]$ 。 性质 每个前缀 $Prefix[i]$ 的所有 $Border$ : 节点 $i$ 到根的链。 哪些前缀有长度为 $x$ 的 $Border$ : $x$ 的子树。 求两个前缀的公共 $Border$ 等价于求 $LCA$ 。 AC自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct ACAM{ static const int id_max=MAXX*2; struct Node{ int ch[26],len; int fail,las; LL val; Node(){ for(int i=0;i&lt;26;++i) ch[i]=0; len=fail=las=0; val=0; } }trie[id_max]; int id_cnt; ACAM(){ for(int i=0;i&lt;id_cnt;++i) trie[i]=Node(); id_cnt=0; } void ins(char s[],LL val){ int now=0,len=strlen(s+1); for(int i=1;i&lt;=len;++i){ if(trie[now].ch[s[i]-'a']) now=trie[now].ch[s[i]-'a']; else now=trie[now].ch[s[i]-'a']=++id_cnt; } trie[now].len=len; trie[now].val=val; } void bfs(){ queue&lt;int&gt; qq; for(int i=0;i&lt;26;++i) if(trie[0].ch[i]) qq.emplace(trie[0].ch[i]); while(!qq.empty()){ int now=qq.front();qq.pop(); for(int i=0;i&lt;26;++i){ if(trie[now].ch[i]){ trie[trie[now].ch[i]].fail=trie[trie[now].fail].ch[i]; qq.emplace(trie[now].ch[i]); if(trie[trie[trie[now].fail].ch[i]].len) trie[trie[now].ch[i]].las=trie[trie[now].fail].ch[i]; else trie[trie[now].ch[i]].las=trie[trie[trie[now].fail].ch[i]].las; } else trie[now].ch[i]=trie[trie[now].fail].ch[i]; } } } void solve(char s[]){ int len=strlen(s+1); int now=0; for(int i=1;i&lt;=len;++i){ now=trie[now].ch[s[i]-'a']; int jj=now; while(jj){ /* do something */ jj=trie[jj].las; } } }}ac; manacher12345678910111213141516171819202122232425262728293031323334//需事先定义好 char s[MAXX],a[MAXX*2]; //和 int ans[MAXX*2]; //s串是原字符串，a串用来存改变后的字符串，在该函数里面有实现//ans存改变后的串的以i为中心的最长的回文串的回文半径 //返回值为最长回文半径（对于原字符串来说） int manacher(){ int lens=strlen(s+1); int len=0; a[0]='@';a[1]='#'; for(int i=0;i&lt;=lens;++i){ a[len++]=s[i]; a[len++]='#'; } a[len]='%'; int r=0,mid=0,ret=1; ans[0]=1; for(int i=1;i&lt;=len;++i){ if(i&lt;r) ans[i]=min(r-i+1,ans[mid*2-i]); else ans[i]=1; while(a[i-ans[i]]==a[i+ans[i]]) ++ans[i]; if(r&lt;i+ans[i]-1){ mid=i; r=mid+ans[i]-1; } ret=max(ret,ans[i]); } return (ret*2-1)/2;} manacher(易于改动版)123456789101112131415161718192021222324252627282930313233343536373839404142int manacher(){ int len=lens*2; for(int i=0;i&lt;=len;++i){ a[i]='#'; ans[i]=1; } for(int i=1;i&lt;=lens;++i) a[i*2-1]=s[i]; int l=1,mid=0; int ret=0; ans[0]=1; for(int i=1;i&lt;=len;++i){ if(i&gt;mid+l-1){ int jj=1; while(i+jj-1&lt;=len&amp;&amp;i-jj+1&gt;=0&amp;&amp;a[i+jj-1]==a[i-jj+1]) ++jj; mid=i; l=jj-1; ans[i]=jj-1; } else{ int j=mid*2-i; if(j-ans[j]+1&gt;mid-l+1) ans[i]=ans[j]; else{ int jj=mid+l-i; while(i+jj-1&lt;=len&amp;&amp;i-jj+1&gt;=0&amp;&amp;a[i+jj-1]==a[i-jj+1]) ++jj; ans[i]=jj-1; if(i+ans[i]&gt;mid+l){ mid=i; l=jj-1; } } } ret=max(ret,ans[i]); } return (ret*2-1)/2;} PAM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct PamNode{ int ch[26]; int num;//该位置为结尾的回文串个数 int sum;//该节点表示的回文串出现的数量 int fail,len; PamNode(){memset(ch,0,sizeof(ch));num=fail=len=sum=0;}}pam[MAXX];int pam_cnt=0,last=0;char s[MAXX];//the stringinline void init(){ for(int i=0;i&lt;=pam_cnt;++i) pam[i]=PamNode(); pam[0].len=0;pam[1].len=-1; pam[0].fail=1;pam[1].fail=0; last=0;pam_cnt=1;}inline int getfail(int id,int las){ while(s[id-pam[las].len-1]!=s[id]) las=pam[las].fail; return las;}void add(int id){ int p=getfail(id,last); if(!pam[p].ch[s[id]-'a']){ pam[++pam_cnt].len=pam[p].len+2; int jj=getfail(id,pam[p].fail); pam[pam_cnt].fail=pam[jj].ch[s[id]-'a']; pam[pam_cnt].num=pam[pam[pam_cnt].fail].num+1; pam[p].ch[s[id]-'a']=pam_cnt; } last=pam[p].ch[s[id]-'a']; ++pam[last].sum;}void build(){ init();//init int len=strlen(s+1); for(int i=1;i&lt;=len;++i){ add(i); //do something or not } for(int i=pam_cnt;i&gt;1;--i) pam[pam[i].fail].sum+=pam[i].sum;}/*scanf(\"%s\",s+1);build();*/ SA&amp;&amp;LCP(st表)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int n;char s[MAXX];int x[MAXX],y[MAXX],c[MAXX],sa[MAXX];int rk[MAXX],height[MAXX];int mn[MAXX],stmin[MAXX][22];//后缀数组//需事先定义//int x[],y[],c[],sa[]; void SA(){ int m='z'; for(int i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; for(int i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(int i=n;i&gt;=1;--i) sa[c[x[i]]--]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1){ int num=0; for(int i=n-k+1;i&lt;=n;++i) y[++num]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) y[++num]=sa[i]-k; for(int i=1;i&lt;=m;++i) c[i]=0;//init for(int i=1;i&lt;=n;++i) ++c[x[i]]; for(int i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(int i=n;i&gt;=1;--i) sa[c[x[y[i]]]--]=y[i],y[i]=0; for(int i=1;i&lt;=n;++i) swap(x[i],y[i]); x[sa[1]]=1;num=1; for(int i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?num:++num; if(num==n) break; m=num; }}//需事先定义 //int rk[],height[];//int mn[MAXX],stmin[MAXX][22];void LCP(){ int h=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i;//init for(int i=1;i&lt;=n;++i){ if(rk[i]==1) continue; if(h) --h; int j=sa[rk[i]-1]; while(i+h&lt;=n&amp;&amp;j+h&lt;=n&amp;&amp;s[i+h]==s[j+h]) ++h; height[rk[i]]=h; } //st表init mn[0]=-1; for(int i=1;i&lt;=n;++i){ mn[i]=((i&amp;(i-1))==0)?mn[i-1]+1:mn[i-1]; stmin[i][0]=height[i]; } for(int j=1;j&lt;=mn[n];++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) stmin[i][j]=min(stmin[i][j-1],stmin[i+(1&lt;&lt;(j-1))][j-1]);}int getstmin(int l,int r){ int k=mn[r-l+1]; return min(stmin[l][k],stmin[r-(1&lt;&lt;k)+1][k]);}int getlcp(int l,int r){ if(l==r) return n-l+1; return getstmin(min(rk[l],rk[r])+1,max(rk[l],rk[r]));} SA&amp;&amp;LCP(st)(封装成类)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class SuffixArray{public: int n; int x[MAXX],y[MAXX],c[MAXX],sa[MAXX]; int rk[MAXX],height[MAXX]; int mn[MAXX],stmin[MAXX][22]; void SA(){ int m='z'; for(int i=1;i&lt;=m;++i) c[i]=0; for(int i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; for(int i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(int i=n;i&gt;=1;--i) sa[c[x[i]]--]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1){ int num=0; for(int i=n-k+1;i&lt;=n;++i) y[++num]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) y[++num]=sa[i]-k; for(int i=1;i&lt;=m;++i) c[i]=0;//init for(int i=1;i&lt;=n;++i) ++c[x[i]]; for(int i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(int i=n;i&gt;=1;--i) sa[c[x[y[i]]]--]=y[i],y[i]=0; for(int i=1;i&lt;=n;++i) swap(x[i],y[i]); x[sa[1]]=1;num=1; for(int i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?num:++num; if(num==n) break; m=num; } } void LCP(){ int h=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i;//init for(int i=1;i&lt;=n;++i){ if(rk[i]==1) continue; if(h) --h; int j=sa[rk[i]-1]; while(i+h&lt;=n&amp;&amp;j+h&lt;=n&amp;&amp;s[i+h]==s[j+h]) ++h; height[rk[i]]=h; } //st表init mn[0]=-1; for(int i=1;i&lt;=n;++i){ mn[i]=((i&amp;(i-1))==0)?mn[i-1]+1:mn[i-1]; stmin[i][0]=height[i]; } for(int j=1;j&lt;=mn[n];++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) stmin[i][j]=min(stmin[i][j-1],stmin[i+(1&lt;&lt;(j-1))][j-1]); } int getstmin(int l,int r){ int k=mn[r-l+1]; return min(stmin[l][k],stmin[r-(1&lt;&lt;k)+1][k]); } int getlcp(int l,int r){ if(l==r) return n-l+1; return getstmin(min(rk[l],rk[r])+1,max(rk[l],rk[r])); }}; SAM12345678910111213141516171819202122232425struct SamNode{ int ch[26]; int len,fa; SamNode(){memset(ch,0,sizeof(ch));len=0;}}sam[MAXX&lt;&lt;1];int las=1,sam_cnt=1;//LL num[MAXX&lt;&lt;1];void add(int c){ int p=las;int np=las=++sam_cnt;// num[np]=1LL;//此行为计数用，标记出现过几次 sam[np].len=sam[p].len+1; for(;p&amp;&amp;!sam[p].ch[c];p=sam[p].fa) sam[p].ch[c]=np; if(!p) sam[np].fa=1; else{ int q=sam[p].ch[c]; if(sam[q].len==sam[p].len+1) sam[np].fa=q; else{ int nq=++sam_cnt;sam[nq]=sam[q]; sam[nq].len=sam[p].len+1; sam[q].fa=sam[np].fa=nq; for(;p&amp;&amp;sam[p].ch[c]==q;p=sam[p].fa) sam[p].ch[c]=nq; } }} 区间本质不同子串个数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;bits/stdc++.h&gt;#define Inf 0x3f3f3f3f3f3f3f3fusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int MAXX=100005;int n,m,pos[MAXX];char s[MAXX];struct SamNode{ int ch[26]; int len,fa; SamNode(){memset(ch,0,sizeof(ch));len=0;}}sam[MAXX&lt;&lt;1];int las=1,sam_cnt=1;//LL num[MAXX&lt;&lt;1];void add(int c){ int p=las;int np=las=++sam_cnt;// num[np]=1LL;//此行为计数用，标记出现过几次 sam[np].len=sam[p].len+1; for(;p&amp;&amp;!sam[p].ch[c];p=sam[p].fa) sam[p].ch[c]=np; if(!p) sam[np].fa=1; else{ int q=sam[p].ch[c]; if(sam[q].len==sam[p].len+1) sam[np].fa=q; else{ int nq=++sam_cnt;sam[nq]=sam[q]; sam[nq].len=sam[p].len+1; sam[q].fa=sam[np].fa=nq; for(;p&amp;&amp;sam[p].ch[c]==q;p=sam[p].fa) sam[p].ch[c]=nq; } }}struct Seg{ LL val[MAXX&lt;&lt;2],tag[MAXX&lt;&lt;2]; Seg(){memset(val,0,sizeof(val));memset(tag,0,sizeof(tag));} void push_down(int rt,int l,int r){ if(tag[rt]){ int mid=(l+r)&gt;&gt;1; tag[rt&lt;&lt;1]+=tag[rt],tag[rt&lt;&lt;1|1]+=tag[rt]; val[rt&lt;&lt;1]+=tag[rt]*(mid-l+1);val[rt&lt;&lt;1|1]+=tag[rt]*(r-(mid+1)+1); tag[rt]=0; } } void push_up(int rt){ val[rt]=val[rt&lt;&lt;1]+val[rt&lt;&lt;1|1]; } void add(int l,int r,int rt,int tl,int tr,LL w){ if(tl&gt;tr) return; if(tl&lt;=l&amp;&amp;r&lt;=tr){ tag[rt]+=w;val[rt]+=w*(r-l+1);return; } push_down(rt,l,r); int mid=(l+r)&gt;&gt;1; if(tl&lt;=mid)add(l,mid,rt&lt;&lt;1,tl,tr,w); if(tr&gt;=mid+1)add(mid+1,r,rt&lt;&lt;1|1,tl,tr,w); push_up(rt); } LL getsum(int l,int r,int rt,int tl,int tr){ if(tl&lt;=l&amp;&amp;r&lt;=tr){return val[rt];} push_down(rt,l,r); int mid=(l+r)&gt;&gt;1;LL ans=0; if(tl&lt;=mid)ans+=getsum(l,mid,rt&lt;&lt;1,tl,tr); if(tr&gt;=mid+1)ans+=getsum(mid+1,r,rt&lt;&lt;1|1,tl,tr); return ans; }}seg;//add(1,n,1,l,r,v);struct LCT{ struct node{ int fa,left,right,val,cov; }s[MAXX&lt;&lt;1]; inline void pushdown(int i){ if(s[i].cov){ if(s[i].left) s[s[i].left].val=s[s[i].left].cov=s[i].cov; if(s[i].right) s[s[i].right].val=s[s[i].right].cov=s[i].cov; s[i].cov=0; } } inline int identify(int i){ if(s[s[i].fa].left==i) return 0; if(s[s[i].fa].right==i) return 1; return -1; } inline void connect(int i,int f,int op){ s[i].fa=f; if(op==1) s[f].right=i; if(op==0) s[f].left=i; } inline void rotate(int x){ int y=s[x].fa; int z=s[y].fa; int opy=identify(y); int opx=identify(x); int u=0; if(opx==1) u=s[x].left; if(opx==0) u=s[x].right; connect(u,y,opx); connect(y,x,opx^1); connect(x,z,opy); } void pushall(int x){ if(identify(x)!=-1) pushall(s[x].fa); pushdown(x); } inline void splay(int i){ pushall(i); while(identify(i)!=-1){ int up=s[i].fa; if(identify(up)==-1) rotate(i); else if(identify(i)==identify(up)) rotate(up),rotate(i); else rotate(i),rotate(i); } } inline int access(int k,int id){ int temp=0; while(k){ splay(k); if(s[k].val){ // printf(\"*%d %d %d\\n\",s[k].val-sam[k].len+1,s[k].val-sam[s[k].fa].len,-1);// seg.add(1,n,1,s[k].val-sam[k].len+1,s[k].val-sam[s[k].fa].len,-1); } s[k].right=temp; temp=k; k=s[k].fa; } // printf(\"*1 %d 1\\n\",id);// seg.add(1,n,1,1,id,1); s[temp].val=s[temp].cov=id; return temp; }}lct;struct QQ{ int l,r,id;}a[MAXX*2];bool cmp(QQ jj,QQ kk){return (jj.r&lt;kk.r);}LL ans[MAXX*2];inline void solve(){ scanf(\"%s\\n%d\",s+1,&amp;m); for(int i=1;i&lt;=m;++i){ scanf(\"%d%d\",&amp;a[i].l,&amp;a[i].r); a[i].id=i; } n=strlen(s+1); sort(a+1,a+m+1,cmp); for(int i=1;i&lt;=n;++i){ add(s[i]-'a'); pos[i]=las; } for(int i=2;i&lt;=sam_cnt;++i){ lct.s[i].fa=sam[i].fa; } int p=1; for(int i=1;i&lt;=n;++i){ lct.access(pos[i],i); while(a[p].r==i) ans[a[p].id]=seg.getsum(1,n,1,a[p].l,a[p].r),++p; } for(int i=1;i&lt;=m;++i) printf(\"%lld\\n\",ans[i]);}signed main(){// LL t;scanf(\"%lld\",&amp;t);// while(t--) solve(); return 0;} 图论堆优化dijkstra最短路1234567891011121314151617181920212223242526272829struct rode{ int to,len;};int n,dij[MAXX];vector&lt;rode&gt; ro[MAXX];typedef pair&lt;int,int&gt; P;void dijkstra(int st){ memset(dij,Inf,sizeof(dij)); priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q; q.emplace(P(0,st)); dij[st]=0; while(!q.empty()){ P p=q.top();q.pop(); int mid=p.second; if(dij[mid]&lt;p.first) continue; //括号条件与(dij[mid]!=p.first)等价 int si=ro[mid].size(); for(int i=0;i&lt;si;++i){ int too=ro[mid][i].to,lenn=ro[mid][i].len; if(dij[too]&gt;dij[mid]+lenn){ dij[too]=dij[mid]+lenn; q.emplace(P(dij[too],too)); } } } } Spfa1234567891011121314151617181920212223242526272829303132333435struct rode{ int to,len;};int n,in[MAXX],dij[MAXX];bool vis[MAXX];vector&lt;rode&gt; ro[MAXX];bool spfa(int st){ memset(vis,0,sizeof(vis)); memset(in,0,sizeof(in)); memset(dij,Inf,sizeof(dij)); queue&lt;int&gt; q; q.emplace(st); vis[st]=true;++in[st];dij[st]=0; while(!q.empty()){ int p=q.front();q.pop(); vis[p]=false; int si=ro[p].size(); for(int i=0;i&lt;si;++i){ int too=ro[p][i].to,lenn=ro[p][i].len; if(dij[too]&gt;dij[p]+lenn){ dij[too]=dij[p]+lenn; ++in[too]; if(in[too]&gt;=n) return false; if(!vis[too]){ vis[too]=true; q.emplace(too); } } } } return false;} tarjan割点(不是缩点)1234567891011121314151617181920212223int n,m,dfn[MAXX],low[MAXX],dfn_cnt;vector&lt;int&gt; to[MAXX];int root;set&lt;int&gt; cut;void tarjan(int now){ //每次调用的时候需要更新root的值 dfn[now]=low[now]=++dfn_cnt; int si=to[now].size(),flag=0; for(int i=0;i&lt;si;++i){ int jj=to[now][i]; if(!dfn[jj]){ tarjan(jj); low[now]=min(low[now],low[jj]); if(low[jj]&gt;=dfn[now]){ ++flag; if(now!=root||flag&gt;1) cut.emplace(now); } } else low[now]=min(low[now],low[jj]); }} tarjan桥12345678910111213141516171819202122typedef pair&lt;int,int&gt; P;int n,m,dfn[MAXX],dfn_cnt,low[MAXX];vector&lt;int&gt; to[MAXX];set&lt;P&gt; ans;void tarjan(int now,int last){ //桥 dfn[now]=low[now]=++dfn_cnt; int si=to[now].size(); for(int i=0;i&lt;si;++i){ int jj=to[now][i]; if(!dfn[jj]){ tarjan(jj,now); low[now]=min(low[now],low[jj]); if(low[jj]&gt;dfn[now]){ ans.emplace(P(min(now,jj),max(now,jj))); } } else if(jj!=last){ low[now]=min(low[now],dfn[jj]); } }} tarjan缩点(不是割点)(有向图)12345678910111213141516171819202122232425262728293031int n,m,dfn[MAXX],low[MAXX],dfn_cnt;vector&lt;int&gt; to[MAXX];stack&lt;int&gt; sta;bool in_sta[MAXX];vector&lt;int&gt; scc[MAXX];int scc_cnt,belong[MAXX];void tarjan(int now){ dfn[now]=low[now]=++dfn_cnt; sta.emplace(now);in_sta[now]=true; int si=to[now].size(); for(int i=0;i&lt;si;++i){ int jj=to[now][i]; if(!dfn[jj]){ tarjan(jj); low[now]=min(low[now],low[jj]); } else if(in_sta[jj]) low[now]=min(low[now],low[jj]); } if(dfn[now]==low[now]){ ++scc_cnt; int jj=0; while(jj!=now){ jj=sta.top();sta.pop(); scc[scc_cnt].emplace_back(jj); in_sta[jj]=false; belong[jj]=scc_cnt; } }} Kruskal(并查集)1234567891011121314151617181920212223242526272829struct Edge{ int st,en,len;};int n,m,sum,dad[MAXX]; //n个顶点，m条边 sum为生成树的边的权值之和 Edge a[MAXX];bool cmp(Edge jj,Edge kk){return jj.len&lt;kk.len;}inline int root(int jj){ return dad[jj]==jj?jj:dad[jj]=root(dad[jj]);}inline void unit(int jj,int kk){ dad[root(jj)]=root(kk);}void kruskal(){ sort(a+1,a+m+1,cmp); for(int i=1;i&lt;=n;++i) dad[i]=i; sum=0; for(int i=1;i&lt;=m;++i){ if(root(a[i].st)!=root(a[i].en)){ unit(a[i].st,a[i].en); sum+=a[i].len; } }} LCA(最近公共祖先)1234567891011121314151617181920212223242526272829303132int n,m,root;int fa[MAXX][22],depth[MAXX];vector&lt;int&gt; to[MAXX];int lg[MAXX];inline void init(){ for(int i=1;i&lt;MAXX;++i) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i);}void dfs(int now,int last){ fa[now][0]=last;depth[now]=depth[last]+1; for(int i=1;i&lt;=lg[depth[now]];++i) fa[now][i]=fa[fa[now][i-1]][i-1]; int si=to[now].size(); for(int i=0;i&lt;si;++i) if(to[now][i]!=last) dfs(to[now][i],now);}int LCA(int jj,int kk){ if(depth[jj]&gt;depth[kk]) swap(jj,kk); while(depth[jj]&lt;depth[kk]) kk=fa[kk][lg[depth[kk]-depth[jj]]-1]; if(jj==kk) return jj; for(int i=lg[depth[jj]]-1;i&gt;=0;--i) if(fa[jj][i]!=fa[kk][i]) jj=fa[jj][i],kk=fa[kk][i]; return fa[jj][0];} 匈牙利算法1234567891011121314151617181920212223242526272829int n,m,e; // n个点和m个点,e条边 int match[MAXX]; // 第二个集合的点i的匹配点为第一个集合的点match[i] bool vis[MAXX]; // 第二个集合的点i是否被访问过 set&lt;int&gt; to[MAXX]; // 邻接表存图，在这里用set是为了防止重边，平时用vector即可 // 这里只记录从左到右的边即可 bool find(int now){ for(int jj:to[now]){ if(!vis[jj]){ vis[jj]=true; if(match[jj]==0||find(match[jj])){ match[jj]=now; return true; } } } return false;}int Hungarian(){ int ret=0; for(int i=1;i&lt;=n;++i){ memset(vis,0,sizeof(vis)); if(find(i)) ++ret; } return ret;}//int ans=HunGaria(); // ans即为最大匹配数 树状数组+树剖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//树状数组+树剖int n;LL mod,a[MAXX];vector&lt;int&gt; to[MAXX];//树状数组LL c1[MAXX],c2[MAXX];inline int lowbit(int x){ return x&amp;(-x);}inline void add(int l,int r,int x){ x %= mod; int ad1 = (LL)(l-1)*x%mod; int ad2 = (LL)r*x%mod; for(int t=l;t&lt;=n;t+=lowbit(t)){ c1[t] = (c1[t]+x)%mod; c2[t] = (c2[t]+ad1)%mod; } for(int t=r+1;t&lt;=n;t+=lowbit(t)){ c1[t] = (c1[t]-x)%mod; c1[t] = (c1[t]+mod)%mod; c2[t] = (c2[t]-ad2)%mod; c2[t] = (c2[t]+mod)%mod; }}inline int qwq(int i){ //qwq int res = 0; for(int t=i;t&gt;0;t-=lowbit(t)){ res = (res+(LL)i*c1[t]%mod)%mod; res = (res-c2[t])%mod; res = (res+mod)%mod; } return res;}inline int query(int l,int r){ int res = (qwq(r)-qwq(l-1))%mod; return (res+mod)%mod;}//树剖int depth[MAXX],num[MAXX],son[MAXX],fa[MAXX];int top[MAXX],id[MAXX];void dfs1(int now,int fa){ depth[now]=depth[::fa[now]=fa]+1; num[now]=1; int maxnum=0; for(int jj:to[now]){ if(jj==fa) continue; dfs1(jj,now); num[now]+=num[jj]; if(num[jj]&gt;maxnum){ son[now]=jj; maxnum=num[jj]; } }}int cnt=0;void dfs2(int now,int t){ top[now]=t; id[now]=++cnt; if(a[now]) add(id[now],id[now],a[now]); if(son[now]) dfs2(son[now],t); for(int jj:to[now]){ if(jj==son[now]||jj==fa[now]) continue; dfs2(jj,jj); }}inline void init(int root){//root为根节点 dfs1(root,0); dfs2(root,root);}void addpath(int l,int r,LL jk){//从l到r的最短路上的所有节点都加上jk while(top[l]!=top[r]){ if(depth[top[l]]&lt;depth[top[r]]) swap(l,r); add(id[top[l]],id[l],jk); l=fa[top[l]]; } if(depth[l]&gt;depth[r]) swap(l,r); add(id[l],id[r],jk);}LL getsum(int l,int r){//求从l到r的最短路上的所有节点的和 LL ret=0LL; while(top[l]!=top[r]){ if(depth[top[l]]&lt;depth[top[r]]) swap(l,r); ret=(ret+query(id[top[l]],id[l]))%mod; l=fa[top[l]]; } if(depth[l]&gt;depth[r]) swap(l,r); ret=(ret+query(id[l],id[r]))%mod; return ret;}void addtree(int x,LL jk){//x的子树的所有节点都加上jk add(id[x],id[x]+num[x]-1,jk);}LL getsum(int x){//求x的子树的所有节点的和 return query(id[x],id[x]+num[x]-1);} 数论欧拉筛存(&lt;=nn)的素数123456789101112131415int a[MAXX],m;bool vis[MAXX]; //vis[i]=true; 表示i为合数 void ola(int nn){ m=0; for(int i=2;i&lt;=nn;++i){ if(!vis[i]) a[++m]=i; for(int j=1;j&lt;=m&amp;&amp;i*a[j]&lt;=nn;++j){ vis[i*a[j]]=true; if(i%a[j]==0) break; } }} 快速幂123456789LL fastpow(LL jj,LL kk){ LL ret=1; while(kk){ if(kk&amp;1) ret=ret*jj%mod; jj=jj*jj%mod; kk&gt;&gt;=1; } return ret;} 线性基(解决最大最小异或和问题)12345678910111213141516171819202122232425262728LL d[70];inline void init(){ for(int i=0;i&lt;=62;++i) d[i]=0LL;}inline void add(LL jj){ for(int i=62;i&gt;=0;--i){ if(jj&amp;(1LL&lt;&lt;i)){ if(!d[i]){ d[i]=jj; break; } jj^=d[i]; } }}inline LL getmax(){ LL ret=0LL; for(int i=62;i&gt;=0;--i) ret=max(ret,ret^d[i]); return ret;}inline LL geimin(){ for(int i=0;i&lt;=62;++i) if(d[i]) return d[i]; return 0;} 模意义下的逆元12345678910111213141516//模意义下的逆元 const LL mod=1000000007;LL fastpow(LL jj,LL kk){ LL ret=1; while(kk){ if(kk&amp;1) ret=ret*jj%mod; jj=jj*jj%mod; kk&gt;&gt;=1; } return ret;}LL rev(LL jj){ return fastpow(jj,mod-2);}//(1/2)%mod=rev(2) 错位排序公式12d[1]=0;d[2]=1;d[i]=(n-1)*(d[i-1]+d[i-2]); 数据结构树状数组12345678910111213141516171819int n,c[MAXX];int lowbit(int jj){return (jj)&amp;(-jj);}void updata(int jj,int kk){ while(jj&lt;=n){ c[jj]+=kk; jj+=lowbit(jj); }}int getsum(int jj){ int ret=0; while(jj&gt;0){ ret+=c[jj]; jj-=lowbit(jj); } return ret;} 线段树sum123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct Seg{ LL tr[MAXX&lt;&lt;2],lazy[MAXX&lt;&lt;2]; inline void build(LL* a,int n){ build(a,1,1,n); } //sum inline void pushup(int now){ tr[now]=tr[now&lt;&lt;1]+tr[now&lt;&lt;1|1]; } void build(LL* a,int now,int l,int r){ if(l==r){ tr[now]=a[l]; return; } int mid=(l+r)&gt;&gt;1; build(a,now&lt;&lt;1,l,mid); build(a,now&lt;&lt;1|1,mid+1,r); pushup(now); } inline void pushdown(int now,int l,int r){ if(lazy[now]){ int mid=(l+r)&gt;&gt;1; lazy[now&lt;&lt;1]+=lazy[now]; lazy[now&lt;&lt;1|1]+=lazy[now]; tr[now&lt;&lt;1]+=lazy[now]*(mid-l+1); tr[now&lt;&lt;1|1]+=lazy[now]*(r-mid); lazy[now]=0; } } //add void updata(int now,int l,int r,int ll,int rr,LL val){ if(l&gt;=ll&amp;&amp;r&lt;=rr){ lazy[now]+=val; tr[now]+=val*(r-l+1); return; } pushdown(now,l,r); int mid=(l+r)&gt;&gt;1; if(mid&gt;=ll) updata(now&lt;&lt;1,l,mid,ll,rr,val); if(mid&lt;rr) updata(now&lt;&lt;1|1,mid+1,r,ll,rr,val); pushup(now); } //sum LL getsum(int now,int l,int r,int ll,int rr){ if(l&gt;=ll&amp;&amp;r&lt;=rr) return tr[now]; pushdown(now,l,r); LL ret=0; int mid=(l+r)&gt;&gt;1; if(mid&gt;=ll) ret+=getsum(now&lt;&lt;1,l,mid,ll,rr); if(mid&lt;rr) ret+=getsum(now&lt;&lt;1|1,mid+1,r,ll,rr); return ret; }};//seg.updata(1,1,n,l,r,val);//seg.getsum(1,1,n,l,r); 线段树sum(包含两种区间修改(*和+))(%mod)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283LL mod=571373;struct Seg{ LL tr[MAXX&lt;&lt;2],lazy1[MAXX&lt;&lt;2],lazy2[MAXX&lt;&lt;2]; inline void build(LL* a,int n){ build(a,1,1,n); int si=MAXX&lt;&lt;2; for(int i=0;i&lt;si;++i) lazy1[i]=1,lazy2[i]=0; } //sum inline void pushup(int now){ tr[now]=tr[now&lt;&lt;1]+tr[now&lt;&lt;1|1]; tr[now]%=mod; } void build(LL* a,int now,int l,int r){ if(l==r){ tr[now]=a[l]; return; } int mid=(l+r)&gt;&gt;1; build(a,now&lt;&lt;1,l,mid); build(a,now&lt;&lt;1|1,mid+1,r); pushup(now); } inline void pushdown(int now,int l,int r){ if(lazy1[now]!=1||lazy2[now]){ int mid=(l+r)&gt;&gt;1; lazy1[now&lt;&lt;1]*=lazy1[now];lazy1[now&lt;&lt;1]%=mod; lazy1[now&lt;&lt;1|1]*=lazy1[now];lazy1[now&lt;&lt;1|1]%=mod; lazy2[now&lt;&lt;1]=lazy2[now&lt;&lt;1]*lazy1[now]+lazy2[now];lazy2[now&lt;&lt;1]%=mod; lazy2[now&lt;&lt;1|1]=lazy2[now&lt;&lt;1|1]*lazy1[now]+lazy2[now];lazy2[now&lt;&lt;1|1]%=mod; tr[now&lt;&lt;1]=tr[now&lt;&lt;1]*lazy1[now]+lazy2[now]*(mid-l+1);tr[now&lt;&lt;1]%=mod; tr[now&lt;&lt;1|1]=tr[now&lt;&lt;1|1]*lazy1[now]+lazy2[now]*(r-mid);tr[now&lt;&lt;1|1]%=mod; lazy1[now]=1;lazy2[now]=0; } } //mul void updata1(int now,int l,int r,int ll,int rr,LL val){ if(l&gt;=ll&amp;&amp;r&lt;=rr){ lazy1[now]*=val;lazy1[now]%=mod; lazy2[now]*=val;lazy2[now]%=mod; tr[now]*=val;tr[now]%=mod; return; } pushdown(now,l,r); int mid=(l+r)&gt;&gt;1; if(mid&gt;=ll) updata1(now&lt;&lt;1,l,mid,ll,rr,val); if(mid&lt;rr) updata1(now&lt;&lt;1|1,mid+1,r,ll,rr,val); pushup(now); } //add void updata2(int now,int l,int r,int ll,int rr,LL val){ if(l&gt;=ll&amp;&amp;r&lt;=rr){ lazy2[now]+=val;lazy2[now]%=mod; tr[now]+=val*(r-l+1);tr[now]%=mod; return; } pushdown(now,l,r); int mid=(l+r)&gt;&gt;1; if(mid&gt;=ll) updata2(now&lt;&lt;1,l,mid,ll,rr,val); if(mid&lt;rr) updata2(now&lt;&lt;1|1,mid+1,r,ll,rr,val); pushup(now); } //sum LL getsum(int now,int l,int r,int ll,int rr){ if(l&gt;=ll&amp;&amp;r&lt;=rr) return tr[now]; pushdown(now,l,r); LL ret=0; int mid=(l+r)&gt;&gt;1; if(mid&gt;=ll) ret+=getsum(now&lt;&lt;1,l,mid,ll,rr),ret%=mod; if(mid&lt;rr) ret+=getsum(now&lt;&lt;1|1,mid+1,r,ll,rr),ret%=mod; return ret; }}seg;//seg.updata(1,1,n,l,r,val);//seg.getsum(1,1,n,l,r); 矩阵线段树(当前为求区间斐波那契之和)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899const LL mod=1e9+7;const int nn=2,mm=2;struct Matrix{ LL c[nn][mm]; Matrix(){memset(c,0,sizeof(c));} friend Matrix operator+(const Matrix &amp;jj,const Matrix &amp;kk){ Matrix ret; for(int i=0;i&lt;nn;++i) for(int j=0;j&lt;mm;++j) ret.c[i][j]=(jj.c[i][j]+kk.c[i][j])%mod; return ret; } friend Matrix operator*(const Matrix &amp;jj,const Matrix &amp;kk){ Matrix ret; for(int i=0;i&lt;nn;++i) for(int j=0;j&lt;mm;++j) for(int k=0;k&lt;mm;++k) ret.c[i][j]+=jj.c[i][k]*kk.c[k][j],ret.c[i][j]%=mod; return ret; }}st;void init(){//斐波那契数列的初始矩阵 st.c[0][0]=st.c[0][1]=st.c[1][0]=1;}Matrix fastpow(Matrix jj,LL kk){ Matrix ret; for(int i=0;i&lt;nn;++i) ret.c[i][i]=1; while(kk){ if(kk&amp;1) ret=ret*jj; jj=jj*jj; kk&gt;&gt;=1; } return ret;}struct Seg{ Matrix tr[MAXX&lt;&lt;2]; LL lazy[MAXX&lt;&lt;2]; inline void build(LL* a,int n){ build(a,1,1,n); } //sum inline void pushup(int now){ tr[now]=tr[now&lt;&lt;1]+tr[now&lt;&lt;1|1]; } void build(LL* a,int now,int l,int r){ if(l==r){ tr[now]=fastpow(st,a[l]-1); return; } int mid=(l+r)&gt;&gt;1; build(a,now&lt;&lt;1,l,mid); build(a,now&lt;&lt;1|1,mid+1,r); pushup(now); } //add void updata(int now,int l,int r,int ll,int rr,LL val){ if(l&gt;=ll&amp;&amp;r&lt;=rr){ lazy[now]+=val; tr[now]=fastpow(st,val)*tr[now]; return; } pushdown(now,l,r); int mid=(l+r)&gt;&gt;1; if(mid&gt;=ll) updata(now&lt;&lt;1,l,mid,ll,rr,val); if(mid&lt;rr) updata(now&lt;&lt;1|1,mid+1,r,ll,rr,val); pushup(now); } inline void pushdown(int now,int l,int r){ if(lazy[now]){ int mid=(l+r)&gt;&gt;1; lazy[now&lt;&lt;1]+=lazy[now]; lazy[now&lt;&lt;1|1]+=lazy[now]; tr[now&lt;&lt;1]=fastpow(st,lazy[now])*tr[now&lt;&lt;1]; tr[now&lt;&lt;1|1]=fastpow(st,lazy[now])*tr[now&lt;&lt;1|1]; lazy[now]=0; } } //sum LL getsum(int now,int l,int r,int ll,int rr){ if(l&gt;=ll&amp;&amp;r&lt;=rr) return tr[now].c[0][0]; pushdown(now,l,r); LL ret=0; int mid=(l+r)&gt;&gt;1; if(mid&gt;=ll) ret+=getsum(now&lt;&lt;1,l,mid,ll,rr),ret%=mod; if(mid&lt;rr) ret+=getsum(now&lt;&lt;1|1,mid+1,r,ll,rr),ret%=mod; return ret; }}seg;//seg.updata(1,1,n,l,r,val);//seg.getsum(1,1,n,l,r); st表(max)123456789101112131415161718int n,a[MAXX];int mn[MAXX],stmax[MAXX][22];void init(){ mn[0]=-1; for(int i=1;i&lt;=n;++i){ mn[i]=((i&amp;(i-1))==0)?mn[i-1]+1:mn[i-1]; stmax[i][0]=a[i]; } for(int j=1;j&lt;=mn[n];++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) stmax[i][j]=max(stmax[i][j-1],stmax[i+(1&lt;&lt;(j-1))][j-1]);}int getstmax(int l,int r){ int k=mn[r-l+1]; return max(stmax[l][k],stmax[r-(1&lt;&lt;k)+1][k]);} LCT(封装成类)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117struct LCT{ struct node{ int fa,left,right,val,sum,lazy; }s[MAXX]; //根据需要维护什么进行改动(大概) inline void pushup(int i){ s[i].sum=s[s[i].left].sum^s[s[i].right].sum^s[i].val; } inline void pushdown(int i){ if(s[i].lazy){ swap(s[i].left,s[i].right); if(s[i].left) s[s[i].left].lazy^=1; if(s[i].right) s[s[i].right].lazy^=1; s[i].lazy=0; } } inline int identify(int i){ if(s[s[i].fa].left==i) return 0; if(s[s[i].fa].right==i) return 1; return -1; } inline void connect(int i,int f,int op){ s[i].fa=f; if(op==1) s[f].right=i; if(op==0) s[f].left=i; } inline void rotate(int x){ int y=s[x].fa; int z=s[y].fa; int opy=identify(y); int opx=identify(x); int u=0; if(opx==1) u=s[x].left; if(opx==0) u=s[x].right; connect(u,y,opx); connect(y,x,opx^1); connect(x,z,opy); pushup(y); pushup(x); } void pushall(int x){ if(identify(x)!=-1) pushall(s[x].fa); pushdown(x); } inline void splay(int i){ pushall(i); while(identify(i)!=-1){ int up=s[i].fa; if(identify(up)==-1) rotate(i); else if(identify(i)==identify(up)) rotate(up),rotate(i); else rotate(i),rotate(i); } } //以上为splay的一些基本操作 //下面是LCT的操作 //构建一条从根到k的一条重链 inline int access(int k){ int temp=0; while(k){ splay(k); s[k].right=temp; pushup(k); temp=k; k=s[k].fa; } return temp; } inline void makeroot(int k){ access(k); splay(k); swap(s[k].left,s[k].right); if(s[k].left) s[s[k].left].lazy^=1; if(s[k].right) s[s[k].right].lazy^=1; } inline int findroot(int k){ access(k); splay(k); while(s[k].left){ pushdown(k); k=s[k].left; } splay(k); return k; } //询问或操作从x到y这条链 //将从x到y这条链单独提出来，并将y变成根 inline void split(int x,int y){ makeroot(x); access(y); splay(y); } //返回x和y的lca inline int lca(int x,int y){ access(x); return access(y); } //返回以r为根的情况下的x和y的lca inline int lca(int r,int x,int y){ makeroot(r); access(x); return access(y); } inline bool link(int x,int y){ makeroot(x); if(findroot(y)==x) return false; s[x].fa=y; return true; } inline bool cut(int x,int y){ if(findroot(x)!=findroot(y)) return false; split(x,y); if(s[x].fa!=y||s[x].right) return false; s[x].fa=s[y].left=0; pushup(x); return true; }}; $LCT$ 适用场景 可以支持动态维护一个树结构，具体来说就是支持加边和删除边。 可以用来求无根树的lca，就是可以多次随意指定一个根来求lca。 这个东西还可以当作一个动态并查集来使用。即可以加边也可以删边的并查集。 一些技巧 如果给出了固定的树的结构，那么建图可以使用 123for(int i=2;i&lt;=sam_cnt;++i){ lct.s[i].fa=sam[i].fa;} 其他fread快读12345678static char buf[100000],*pa=buf,*pd=buf;#define gc pa==pd&amp;&amp;(pd=(pa=buf)+fread(buf,1,100000,stdin),pa==pd)?EOF:*pa++inline int read(){ int x(0);char c(gc); while(c&lt;'0'||c&gt;'9')c=gc; while(c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=gc; return x;} 数位dp12345678910111213141516171819202122LL num[20],dp[20][20];LL dfs(LL now,bool limit,bool nozero,LL sum,LL d){ if(!now) return sum; if(!limit&amp;&amp;nozero&amp;&amp;dp[now][sum]!=-1) return dp[now][sum]; LL ret=0LL; LL up=limit?num[now]:9; for(LL i=0;i&lt;=up;++i) ret+=dfs(now-1,limit&amp;&amp;(i==up),nozero||i,sum+(bool)((nozero||i)&amp;&amp;(i==d)),d); if(!limit&amp;&amp;nozero) dp[now][sum]=ret; return ret;}LL getans(LL x,LL d){//从1到x的所有数中数字d出现的次数 LL p=0LL; memset(dp,-1,sizeof(dp)); while(x){ num[++p]=x%10; x/=10; } return dfs(p,true,false,0LL,d);} 二分(左闭右开)12345678int l=1,r=n+1,mid;//[l,r)while(l&lt;r){ mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid;} 离散化(最终包含重复元素)1234567891011scanf(\"%d\",&amp;n);for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]);//包含重复元素 for(int i=1;i&lt;=n;++i) s[i]=a[i];//a[]为原数组 sort(a+1,a+n+1);int len=unique(a+1,a+n+1)-a-1;//去重之后的数组长度 for(int i=1;i&lt;=n;++i) s[i]=lower_bound(a+1,a+len+1,s[i])-a;//s[]即为离散化之后的数组 离散化(最终不包含重复元素)12345678scanf(\"%d\",&amp;n);for(int i=1;i&lt;=n;++i){ scanf(\"%d\",&amp;a[i].first);//P a[MAXX] a[i].second=i;}sort(a+1,a+n+1);for(int i=1;i&lt;=n;++i) s[a[i].second]=i;//s[]即为离散化之后的结果 unordered_map中存pair123456789struct hashfunc{ template&lt;typename T, typename U&gt; size_t operator() (const pair&lt;T, U&gt; &amp;i) const { //根据题目数据写一个hash函数 return (LL)(i.first)*1000000LL+(LL)(i.second); }};unordered_map&lt;P,int,hashfunc&gt; dij; LIS(最长上升子序列)1234567891011121314int lis[MAXX],len;int LIS(int a[],int n){ if(!n) return 0; memset(lis,Inf,sizeof(lis));len=1; lis[1]=a[1]; for(int i=2;i&lt;=n;++i){ int j=lower_bound(lis+1,lis+len+1,a[i])-lis; if(j&gt;len) lis[++len]=a[i]; else if(a[i]&lt;lis[j]) lis[j]=a[i]; } return len;}","categories":[{"name":"个人板子总结","slug":"个人板子总结","permalink":"http://shaun-2314.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%9D%BF%E5%AD%90%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"板子","slug":"板子","permalink":"http://shaun-2314.github.io/tags/%E6%9D%BF%E5%AD%90/"}]},{"title":"纪念第一次AK","slug":"cfRound-784-Div-4-Summary","date":"2022-04-21T16:16:55.000Z","updated":"2022-04-29T16:28:56.764Z","comments":true,"path":"2022/04/22/cfround-784-div-4-summary/","link":"","permalink":"http://shaun-2314.github.io/2022/04/22/cfround-784-div-4-summary/","excerpt":"","text":"Codeforces Round 784(Div.4)CONTEST传送门 前言本次cf是我打cf以来第一次AK，虽然是div.4，难度较低，不过对我而言有很大的纪念意义，于是写下本篇用来纪念。 战况 在距离比赛结束还剩26分钟时成功AK，罚时334。","categories":[{"name":"cf总结","slug":"cf总结","permalink":"http://shaun-2314.github.io/categories/cf%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"cf","slug":"cf","permalink":"http://shaun-2314.github.io/tags/cf/"}]},{"title":"博客的评论系统的搭建","slug":"contact-system-building","date":"2022-04-16T10:45:00.000Z","updated":"2022-04-22T06:09:47.128Z","comments":true,"path":"2022/04/16/contact-system-building/","link":"","permalink":"http://shaun-2314.github.io/2022/04/16/contact-system-building/","excerpt":"","text":"对博客进行评论系统的搭建 选择了使用Waline进行搭建 步骤我是按照官方文档中的快速上手作为教程进行搭建的。 LeanCloud 设置(数据库) 使用lendcloud，可以在此进行数据储存等操作，评论的数据管理就在此 Vercel 部署(服务端) 在此进行服务端的部署，连接到github，Vercel会基于Waline模板帮助你新建并初始化仓库 HTML 引入(客户端) 先试一下能不能自动配置 尝试了之后发现 在主题中直接输入相关参数即可自动配置 流程感觉挺简便的","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://shaun-2314.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://shaun-2314.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"评论系统","slug":"评论系统","permalink":"http://shaun-2314.github.io/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"network_orders","slug":"network-order","date":"2022-04-15T05:37:01.000Z","updated":"2022-04-20T14:44:39.192Z","comments":true,"path":"2022/04/15/network-order/","link":"","permalink":"http://shaun-2314.github.io/2022/04/15/network-order/","excerpt":"","text":"在计网学习中遇到的可操作的命令Traceroute 诊断程序： 原理：提供从源端，经过路由器，到目的的延时测量 沿着目的的路径，向每个路由器发送3个探测分组 路由器 i 将向发送方返回一个分组 发送方对发送和回复之间间隔计时 使用方法： 在命令行中输入以下指令 Linux: 1traceroute shaun-2314.github.io Windows: 1tracert shaun-2314.github.io 例子 telnet 建立连接工具(TCP) 通过TCP协议进行连接请求 连接确认后，可通过HTTP等协议进行沟通 使用方法 1telnet shaun-2314.github.io 80 在连接成功后可以使用HTTP等协议进行报文交换。 12GET / HTTP/1.0HOST:shaun-2314.github.io //(此行可以不需要写) 例子","categories":[{"name":"计网学习","slug":"计网学习","permalink":"http://shaun-2314.github.io/categories/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://shaun-2314.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"命令","slug":"命令","permalink":"http://shaun-2314.github.io/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"每日总结-1月20日","slug":"1-20","date":"2022-01-20T11:02:59.000Z","updated":"2022-04-15T07:10:25.553Z","comments":true,"path":"2022/01/20/1-20/","link":"","permalink":"http://shaun-2314.github.io/2022/01/20/1-20/","excerpt":"","text":"数据结构进阶 splay树 主席树 今日战况 前言今天看了好长时间的splay树和主席树的相关内容，但还是看的不明白，又去看训练的题目集，发现F题又可以用set写，之后，又从伍老师那里知道了A题也可以用set写，于是，就又用set A了这两道题。 部分题目F题: 宠物收养所题目传送门 题目 最近，阿 Q 开了一间宠物收养所。收养所提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。 每个领养者都希望领养到自己满意的宠物，阿 Q 根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值 a（a 是一个正整数，a &lt; 2^31），而他也给每个处在收养所的宠物一个特点值，这样他就能够很方便的处理整个领养宠物的过程了。 宠物收养所总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少： 被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为 a，那么它将会领养一只目前未被领养的宠物中特点值最接近 a 的一只宠物。任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的。如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为 a-b 和 a+b，那么领养者将会领养特点值为 a-b 的那只宠物； 收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为 a，存在两个领养者他们希望领养宠物的特点值分别为 a-b 和 a+b，那么特点值为 a-b 的那个领养者将成功领养该宠物。一个领养者领养了一个特点值为 a 的宠物，而它本身希望领养的宠物的特点值为 b，那么这个领养者的不满意程度为 |a-b|。 你得到了一年当中，领养者和被收养宠物到来收养所的情况，希望你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。 输入格式 第一行为一个正整数 n，表示一年当中来到收养所的宠物和领养者的总数； 接下来的 n 行，按到来时间的先后顺序描述了一年当中来到收养所的宠物和领养者的情况。每行有两个整数 a, b，其中 a=0 表示宠物，a=1 表示领养者，正数 b 表示宠物的特点值或是领养者希望领养宠物的特点值。 同一时间呆在收养所中的，要么全是宠物，要么全是领养者，这些宠物和领养者的个数不会超过 10^4 个。 输出格式 仅有一个正整数，表示一年当中所有收养了宠物的领养者的不满意程度的总和对 10^6 取模以后的结果。 样例 Input 12345650 20 41 31 21 5 Output 13 数据范围与提示 对于全部数据，有 1&lt;=n&lt;=8*10^4。 思路这道题就是一道模拟，用set进行存储，用 lower_bound 进行查找比他大一点的，再减一就是比他小一点的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;cstdio&gt;#include&lt;set&gt;using namespace std;int n,ans=0,sipet=0,sipeo=0;set&lt;int&gt; pet,peo;inline void solve(){ scanf(\"%d\",&amp;n); int flag,a; while(n--){ scanf(\"%d%d\",&amp;flag,&amp;a); if(flag==0){ if(sipet&gt;=sipeo){ pet.emplace(a); ++sipet; } else{ auto it1=peo.lower_bound(a); if(it1==peo.end()){ --it1; int jj=*it1; ans+=a-jj;ans%=1000000; --sipeo; peo.erase(it1); } else{ if(it1==peo.begin()){ int jj=*it1; ans+=jj-a;ans%=1000000; --sipeo; peo.erase(it1); } else{ auto it2=it1;--it2; int jj=*it1,kk=*it2; if(a-kk&lt;=jj-a){ ans+=a-kk;ans%=1000000; --sipeo; peo.erase(it2); } else{ ans+=jj-a;ans%=1000000; --sipeo; peo.erase(it1); } } } } } else{ if(sipeo&gt;=sipet){ peo.emplace(a); ++sipeo; } else{ auto it1=pet.lower_bound(a); if(it1==pet.end()){ --it1; int jj=*it1; ans+=a-jj;ans%=1000000; --sipet; pet.erase(it1); } else{ if(it1==pet.begin()){ int jj=*it1; ans+=jj-a;ans%=1000000; --sipet; pet.erase(it1); } else{ auto it2=it1;--it2; int jj=*it1,kk=*it2; if(a-kk&lt;=jj-a){ ans+=a-kk;ans%=1000000; --sipet; pet.erase(it2); } else{ ans+=jj-a;ans%=1000000; --sipet; pet.erase(it1); } } } } } } printf(\"%d\\n\",ans);}int main(){ solve(); return 0;} A题: Double Queue题目传送门 题目 The new founded Balkan Investment Group Bank (BIG-Bank) opened a new office in Bucharest, equipped with a modern computing environment provided by IBM Romania, and using modern information technologies. As usual, each client of the bank is identified by a positive integer K and, upon arriving to the bank for some services, he or she receives a positive integer priority P. One of the inventions of the young managers of the bank shocked the software engineer of the serving system. They proposed to break the tradition by sometimes calling the serving desk with the lowest priority instead of that with the highest priority. Thus, the system will receive the following types of request: 0 The system needs to stop serving 1 K P Add client K to the waiting list with priority P 2 Serve the client with the highest priority and drop him or her from the waiting list 3 Serve the client with the lowest priority and drop him or her from the waiting list Your task is to help the software engineer of the bank by writing a program to implement the requested serving policy. Input Each line of the input contains one of the possible requests; only the last line contains the stop-request (code 0). You may assume that when there is a request to include a new client in the list (code 1), there is no other request in the list of the same client or with the same priority. An identifier K is always less than 10^6 , and a priority P is less than 10^7 . The client may arrive for being served multiple times, and each time may obtain a different priority. Output For each request with code 2 or 3, the program has to print, in a separate line of the standard output, the identifier of the served client. If the request arrives when the waiting list is empty, then the program prints zero (0) to the output. Sample Input 12345678921 20 141 30 321 10 993220 Sample Output 1234502030100 思路可以使用 set&lt;pair&lt;int,int&gt; &gt; 进行存储数据，根据优先级进行排序，若 set&lt; int &gt; a，则 a.begin() 即为 a 中最小值的迭代器， a.end() - 1 即为 a 中最大值的迭代器(不越界的情况下)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;set&gt;using namespace std;struct P{ int pri,num; friend bool operator&lt;(P jj,P kk){ return jj.pri&lt;kk.pri; }};set&lt;P&gt; se;inline void solve(){ int flag; while(~scanf(\"%d\",&amp;flag)&amp;&amp;flag){ if(flag==1){ P jj; scanf(\"%d%d\",&amp;jj.num,&amp;jj.pri); se.insert(jj); } else if(flag==2){ if(se.size()==0) printf(\"0\\n\"); else{ set&lt;P&gt;::iterator it=se.end();--it; printf(\"%d\\n\",it-&gt;num); se.erase(it); } } else{ if(se.size()==0) printf(\"0\\n\"); else{ set&lt;P&gt;::iterator it=se.begin(); printf(\"%d\\n\",it-&gt;num); se.erase(it); } } } }int main(){ solve(); return 0;} 总结splay树和主席树确实是还没看懂，用set水了三道题，尽量掌握 set 的各种用法吧。","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shaun-2314.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"每日总结-1月19日","slug":"1-19","date":"2022-01-19T12:09:35.000Z","updated":"2022-04-15T07:10:18.737Z","comments":true,"path":"2022/01/19/1-19/","link":"","permalink":"http://shaun-2314.github.io/2022/01/19/1-19/","excerpt":"","text":"数据结构进阶 splay树 主席树 今日战况 前言今天的内容个人感觉难度很大，一时间难以接受，只写出了一道题，还是用的stl中的set写的 部分题目E题: 营业额统计题目传送门 题目 原题来自：HNOI 2002 Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。 Tiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。 经济管理学上定义了一种最小波动值来衡量这种情况：记该天以前某一天的营业额为 a_i，该天营业额为 b，则该天的最小波动值 ，当最小波动值越大时，就说明营业情况越不稳定。而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。 你的任务就是编写一个程序帮助 Tiger 来计算这一个值，第一天的最小波动值为第一天的营业额。 一句话题意 输入格式 第一行为正整数，表示该公司从成立一直到现在的天数； 接下来的 n 行每行有一个整数，表示第 i 天公司的营业额 a_i。 输出格式 仅有一个正整数，即每一天最小波动的和，结果不超过 2^31. 样例 Input 12345676512546 Output 112 5+∣1−5∣+∣2−1∣+∣5−5∣+∣4−5∣+∣6−5∣= 5 + 4 + 1 + 0 + 1 + 1 = 12 数据范围与提示 题目大意 思路由于数据量过大，我们需要使用splay树数据结构进行解题，但是，这道题也可以使用stl里的set进行解题 set里面有内置的 lower_bound 函数和 upper_bound 函数，可以在极短的时间查找到大于或大于等于一个数的数的迭代器，这个迭代器减一即为小于等于这个数的数的迭代器。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;cstring&gt;using namespace std;int n;set&lt;int&gt; se;void solve(){ scanf(\"%d\",&amp;n); int jj,ans=0; scanf(\"%d\",&amp;jj); se.emplace(jj); ans+=jj; for(int i=1;i&lt;n;++i){ scanf(\"%d\",&amp;jj); int temp; auto kk=se.lower_bound(jj); if(kk==se.end()){ --kk; temp=jj-*kk; } else{ temp=*kk-jj; if(kk!=se.begin()){ --kk; temp=min(temp,jj-*kk); } } ans+=temp; se.emplace(jj); } printf(\"%d\\n\",ans);}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) solve(); return 0;} 总结明天再好好理解理解。","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shaun-2314.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"每日总结-1月18日","slug":"1-18","date":"2022-01-18T11:46:58.000Z","updated":"2022-04-15T07:10:08.436Z","comments":true,"path":"2022/01/18/1-18/","link":"","permalink":"http://shaun-2314.github.io/2022/01/18/1-18/","excerpt":"","text":"博弈论今日战况 前言&amp;总结今天并没有A题，上午在给21级队员讲课，下午时不时观看一下21级做题情况，没有认真进行自己的训练","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"博弈论","slug":"博弈论","permalink":"http://shaun-2314.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"每日总结-1月17日","slug":"1-17","date":"2022-01-17T11:53:31.000Z","updated":"2022-04-15T07:10:01.249Z","comments":true,"path":"2022/01/17/1-17/","link":"","permalink":"http://shaun-2314.github.io/2022/01/17/1-17/","excerpt":"","text":"博弈论 Nim游戏 SG函数 SG定理 mex运算 Wythoff Game 今日战况 前言这个博弈论要远比我想象中的复杂，SG函数以及状态转移等等，很是复杂，感觉这部分需要的代码能力非常高，有好多时候，我有点思路，但是我的大脑却不够用，不知道改如何实现这个东西，或者说思考的方向错了。这部分急需大脑 部分题目E题: 取石子游戏题目传送门 题目 有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。 Input 输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。 Output 输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。 Sample Input 1232 18 44 7 Sample Output 123010 思路这是一个典型的 Wythoff Game ，这里面有一个结论 先手必败当且仅当$$abs(a-b)*(1+sqrt{5})/2==min(a,b)$$(a,b为两堆石子的石子数量) 即两堆石子数量的差值与黄金分割率的乘积是否与两堆石子数量较小数量相等。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=205;const double eps=0.0000001;int a,s,jj,kk;double fi=(1.0+sqrt(5.0))*0.5;void solve_it(){ while(~scanf(\"%d%d\",&amp;a,&amp;s)){ jj=min(a,s);kk=max(a,s); if(jj==(int)(((double)(kk-jj))*fi)) printf(\"0\\n\"); else printf(\"1\\n\"); }}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) solve_it(); return 0;} B题: Georgia and Bob题目传送门 题目 Georgia and Bob decide to play a self-invented game. They draw a row of grids on paper, number the grids from left to right by 1, 2, 3, …, and place N chessmen on different grids, as shown in the following figure for example: Georgia and Bob move the chessmen in turn. Every time a player will choose a chessman, and move it to the left without going over any other chessmen or across the left edge. The player can freely choose number of steps the chessman moves, with the constraint that the chessman must be moved at least ONE step and one grid can at most contains ONE single chessman. The player who cannot make a move loses the game. Georgia always plays first since “Lady first”. Suppose that Georgia and Bob both do their best in the game, i.e., if one of them knows a way to win the game, he or she will be able to carry it out. Given the initial positions of the n chessmen, can you predict who will finally win the game? Input The first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. Each test case contains two lines. The first line consists of one integer N (1 &lt;= N &lt;= 1000), indicating the number of chessmen. The second line contains N different integers P1, P2 … Pn (1 &lt;= Pi &lt;= 10000), which are the initial positions of the n chessmen. Output For each test case, prints a single line, “Georgia will win”, if Georgia will win the game; “Bob will win”, if Bob will win the game; otherwise ‘Not sure’. Sample Input 12345231 2 381 5 6 7 9 12 14 17 Sample Output 12Bob will winGeorgia will win 思路先把棋子升序排列，我们可以将这些棋子两两绑定，如果棋子个数是奇数，那就把第一个和边界绑定，在同一对棋子中，如果对手移动前面那个，那么我们总能移动后面那个相同的距离，相当于移动前面那个将毫无意义，看的是同一对中，后面的那个棋子能移动的距离，即两个棋子之间的距离，谁先把这些距离移动完谁就会赢，这时，这个问题就已经演变成了经典的取石子游戏，直接应用取石子游戏中的结论，所有石子堆的数量的异或值是否为零，为零则先手必败，否则先手必胜。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=1005;const double eps=0.0000001;int n,a[MAXX],s[MAXX];inline void solve_it(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); sort(a+1,a+n+1); int p=0,pp=0; if(n%2) s[++p]=a[++pp]-1; while(1){ if(pp&gt;=n) break; s[++p]=a[pp+2]-a[pp+1]-1; pp+=2; } int n2=(n+1)/2; int ans=0; for(int i=1;i&lt;=n2;++i) ans^=s[i]; if(ans) printf(\"Georgia will win\\n\"); else printf(\"Bob will win\\n\");}int main(){ int t;scanf(\"%d\",&amp;t); while(t--) solve_it(); return 0;} 总结这部分感觉是真的好难理解，只是记了两个结论，取石子游戏和 wythoff game 的结论，这部分仍然需要多练。","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"博弈论","slug":"博弈论","permalink":"http://shaun-2314.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"每日总结-1月15日","slug":"1-15","date":"2022-01-15T02:37:04.000Z","updated":"2022-04-15T07:09:53.801Z","comments":true,"path":"2022/01/15/1-15/","link":"","permalink":"http://shaun-2314.github.io/2022/01/15/1-15/","excerpt":"","text":"图论进阶网络流 最大流 最小费用流 今日战况 前言今天主要就是把 MCMF(最小费用最大流) 给理解了，不过还不够熟练，自己写应该还是写不出板子。 部分题目B题: 分配问题题目传送门 题目 有 n 件工作要分配给 n 个人做。第 i 个人做第 j 件工作产生的效益为 c_ij 。试设计一个将 n 件工作分配给 n 个人做的分配方案，使产生的总效益最大。 输入格式 文件的第 1 行有 1 个正整数 n ，表示有 n 件工作要分配给 n 个人做。 接下来的 n 行中，每行有 n 个整数 c_ij ，表示第 i 个人做第 j 件工作产生的效益为 c_ij 。 输出格式 两行分别输出最小总效益和最大总效益。 样例 Input 12345652 2 2 1 22 3 1 2 42 0 1 1 12 3 4 3 33 2 1 2 1 Output 12514 数据范围与提示 1 &lt;= n &lt;= 100 思路可构建一个二分图，一边是人，一边是工作，用一遍 MCMF(最小费用最大流)可求出最小总效益，之后，把所有边都删掉，再重新建一个图，里面的 cost 全部变为原来的负数，再用一遍 MCMF 可求出最大总效益的相反数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=205;const double eps=0.0000001;struct rode{ int st,en,flow,cap,cost;};vector&lt;rode&gt; ro;vector&lt;int&gt; to[MAXX];int n,m;int cur[MAXX],d[MAXX],guanxi[MAXX][MAXX],a[MAXX],p[MAXX];bool vis[MAXX],inq[MAXX];inline void add(int st,int en,int cap,int cost){ rode re;int si=ro.size(); re.st=st;re.en=en;re.flow=0;re.cap=cap;re.cost=cost; ro.push_back(re);to[st].push_back(si); re.st=en;re.en=st;re.flow=0;re.cap=0;re.cost=-cost; ro.push_back(re);to[en].push_back(si+1);}bool bfss(int st,int en,int&amp; flow,LL&amp; cost){ for(int i=st;i&lt;=en;++i){ d[i]=Inf; inq[i]=0; } queue&lt;int&gt; qq;qq.push(st); d[st]=0;inq[st]=true;p[st]=0;a[st]=Inf; while(!qq.empty()){ int jj=qq.front();qq.pop(); inq[jj]=false; int si=to[jj].size(); for(int i=0;i&lt;si;++i){ rode&amp; kk=ro[to[jj][i]]; if(kk.cap&gt;kk.flow&amp;&amp;d[kk.en]&gt;d[jj]+kk.cost){ d[kk.en]=d[jj]+kk.cost; p[kk.en]=to[jj][i]; a[kk.en]=min(a[jj],kk.cap-kk.flow); if(!inq[kk.en]){ qq.push(kk.en); inq[kk.en]=true; } } } } if(d[en]==Inf) return false; cost+=(LL)d[en]*(LL)a[en]; flow+=a[en]; int jj=en; while(jj!=st){ ro[p[jj]].flow+=a[en]; ro[p[jj]^1].flow-=a[en]; jj=ro[p[jj]].st; } return true;}int mcmf(int st,int en,LL&amp; cost){ int flow=0;cost=0; while(bfss(st,en,flow,cost)); return flow;}void solve_it(){ scanf(\"%d\",&amp;n); int n1=2*n+1; LL minans,maxans; int ff; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j){ scanf(\"%d\",&amp;guanxi[i][j]); add(i,n+j,1,guanxi[i][j]); } for(int i=1;i&lt;=n;++i){ add(0,i,1,0); add(i+n,n1,1,0); } ff=mcmf(0,n1,minans); printf(\"%lld\\n\",minans); ro.clear(); for(int i=0;i&lt;=n1;++i) to[i].clear(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j){ add(i,n+j,1,-guanxi[i][j]); } for(int i=1;i&lt;=n;++i){ add(0,i,1,0); add(i+n,n1,1,0); } ff=mcmf(0,n1,maxans); printf(\"%lld\\n\",-maxans);}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) solve_it(); return 0;} 总结这次课到现在是看代码的能看懂，但是自己写的话还是写不出来，代码能力还是不行，需要多练，记住模板，需要能够随时都能写出模板才行。","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"图论","slug":"图论","permalink":"http://shaun-2314.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"每日总结-1月14日","slug":"1-14","date":"2022-01-14T12:28:17.000Z","updated":"2022-04-15T07:08:54.280Z","comments":true,"path":"2022/01/14/1-14/","link":"","permalink":"http://shaun-2314.github.io/2022/01/14/1-14/","excerpt":"","text":"图论进阶网络流 最大流 最小费用最大流 今日战况 前言感觉今天的主题，挺难的，上午听课的时候也是没有跟上节奏，然后又去反复看课件和查找资料，才把最大流差不多理解，最小费用最大流就留给明天了 部分题目A题: Drainage Ditches题目传送门 题目 Every time it rains on Farmer John’s fields, a pond forms over Bessie’s favorite clover patch. This means that the clover is covered by water for awhile and takes quite a long time to regrow. Thus, Farmer John has built a set of drainage ditches so that Bessie’s clover patch is never covered in water. Instead, the water is drained to a nearby stream. Being an ace engineer, Farmer John has also installed regulators at the beginning of each ditch, so he can control at what rate water flows into that ditch.Farmer John knows not only how many gallons of water each ditch can transport per minute but also the exact layout of the ditches, which feed out of the pond and into each other and stream in a potentially complex network.Given all this information, determine the maximum rate at which water can be transported out of the pond and into the stream. For any given ditch, water flows in only one direction, but there might be a way that water can flow in a circle. Input The input includes several cases. For each case, the first line contains two space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the ditch. Output For each case, output a single integer, the maximum rate at which water may emptied from the pond. Sample Input 1234565 41 2 401 4 202 4 202 3 303 4 10 Sample Output 150 题目大意有个排水系统，有 n 条单向通道和 m 个位置，问从位置 1 到位置 m 的最大流速是多大。 思路是一道很典型的最大流模板题，通过单向通道进行建图，之后进行一遍 dinic 算法即可求出答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=205;const double eps=0.0000001;struct rode{ int st,en,flow,cap;};vector&lt;rode&gt; ro;vector&lt;int&gt; to[MAXX];int n,m;int cur[MAXX],d[MAXX];bool vis[MAXX];inline void add(int st,int en,int cap){ rode re;int si=ro.size(); re.st=st;re.en=en;re.flow=0;re.cap=cap; ro.push_back(re);to[st].push_back(si); re.st=en;re.en=st;re.flow=0;re.cap=0; ro.push_back(re);to[en].push_back(si+1);}bool bfs(int st,int en){ memset(vis,0,sizeof(vis)); queue&lt;int&gt; qq; qq.push(st); d[st]=0;vis[st]=true; while(!qq.empty()){ int jj=qq.front();qq.pop(); int si=to[jj].size(); for(int i=0;i&lt;si;++i){ rode kk=ro[to[jj][i]]; if(!vis[kk.en]&amp;&amp;(kk.cap-kk.flow)&gt;0){ vis[kk.en]=true; d[kk.en]=d[jj]+1; qq.push(kk.en); } } } return vis[en];}int dfs(int now,int en,int flow){ if(now==en||flow==0) return flow; int re=0,f=0,si=to[now].size(); for(int&amp; i=cur[now];i&lt;si;++i){ rode&amp; jj=ro[to[now][i]]; if(d[jj.en]==d[jj.st]+1){ f=dfs(jj.en,en,min(flow,jj.cap-jj.flow)); if(f){ jj.flow+=f; ro[to[now][i]^1].flow-=f; re+=f; flow-=f; if(flow==0) break; } } } return re;}int dinic(int st,int en){ int re=0; while(bfs(st,en)){ memset(cur,0,sizeof(cur)); re+=dfs(st,en,Inf); } return re;}void solve_it(){ for(int i=1;i&lt;=m;++i){ int st,en,cap; scanf(\"%d%d%d\",&amp;st,&amp;en,&amp;cap); add(st,en,cap); } printf(\"%d\\n\",dinic(1,n)); ro.clear(); for(int i=1;i&lt;=n;++i) to[i].clear();}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) while(~scanf(\"%d%d\",&amp;m,&amp;n)) solve_it(); return 0;} C题: 假期的宿舍题目传送门 题目 学校放假了······有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。比如A和B都是学校的学生，A要回家，而C来看B，C与A不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是B睡A的床而C睡B的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。我们已知一共有n个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。 输入格式 第一行一个数T表示数据组数。接下来T组数据，每组数据第一行一个数n表示涉及到的总人数。接下来一行n个数，第i个数表示第i个人是否是在校学生(0表示不是，1表示是)。再接下来一行n个数，第i个数表示第i个人是否回家(0表示不回家，1表示回家，注意如果第i个人不是在校学生，那么这个位置上的数是一个随机的数，你应该在读入以后忽略它)。接下来n行每行n个数，第i行第j个数表示i和j是否认识(1表示认识，0表示不认识，第i行i个的值为0，但是显然自己还是可以睡自己的床)，认识的关系是相互的。1 ≤ n ≤ 50,1 ≤ T ≤ 20 输出格式 对于每组数据，如果存在一个方案则输出“^_^”(不含引号)否则输出“T_T”(不含引号)。(注意输出的都是半角字符，即三个符号的ASCII码分别为94,84,95) Sample Input 1234567891011131 1 00 1 00 1 11 0 01 0 0 Output 1^_^ 题目大意学校放假了……有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。 比如 A 和 B 都是学校的学生，A 要回家，而 C 来看B，C 与 A 不认识。我们假设每个人只能睡和自己直 接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的 人可能认识好多在校学生，在校学生之间也不一定都互相认识。 我们已知一共有 n个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否 存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。 思路典型的二分图最大匹配问题，可以用最大流进行求解，主要就是建图，先创造出一个原点和汇点，接着原点连接人，汇点连接床，人和床之间再连接，只有直接认识的人才能睡到朋友床上，接着进行一次最大流即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=205;const double eps=0.0000001;struct rode{ int st,en,flow,cap;};vector&lt;rode&gt; ro;vector&lt;int&gt; to[MAXX];int n,m;int cur[MAXX],d[MAXX];bool vis[MAXX],isStu[MAXX];inline void add(int st,int en,int cap){ rode re;int si=ro.size(); re.st=st;re.en=en;re.flow=0;re.cap=cap; ro.push_back(re);to[st].push_back(si); re.st=en;re.en=st;re.flow=0;re.cap=0; ro.push_back(re);to[en].push_back(si+1);}bool bfs(int st,int en){ memset(vis,0,sizeof(vis)); queue&lt;int&gt; qq; qq.push(st); d[st]=0;vis[st]=true; while(!qq.empty()){ int jj=qq.front();qq.pop(); int si=to[jj].size(); for(int i=0;i&lt;si;++i){ rode kk=ro[to[jj][i]]; if(!vis[kk.en]&amp;&amp;(kk.cap-kk.flow)&gt;0){ vis[kk.en]=true; d[kk.en]=d[jj]+1; qq.push(kk.en); } } } return vis[en];}int dfs(int now,int en,int flow){ if(now==en||flow==0) return flow; int re=0,f=0,si=to[now].size(); for(int&amp; i=cur[now];i&lt;si;++i){ rode&amp; jj=ro[to[now][i]]; if(d[jj.en]==d[jj.st]+1){ f=dfs(jj.en,en,min(flow,jj.cap-jj.flow)); if(f){ jj.flow+=f; ro[to[now][i]^1].flow-=f; re+=f; flow-=f; if(flow==0) break; } } } return re;}int dinic(int st,int en){ int re=0; while(bfs(st,en)){ memset(cur,0,sizeof(cur)); re+=dfs(st,en,Inf); } return re;}void solve_it(){ scanf(\"%d\",&amp;n); int en=2*n+1,num=n; for(int i=1;i&lt;=n;++i){ int jj;scanf(\"%d\",&amp;jj); if(jj){ isStu[i]=true; add(i,n+i,1); add(n+i,en,1); } } for(int i=1;i&lt;=n;++i){ int jj;scanf(\"%d\",&amp;jj); if(isStu[i]&amp;&amp;jj==0) add(0,i,1); else if(!isStu[i]) add(0,i,1); else if(isStu[i]&amp;&amp;jj==1) --num; } for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=n;++j){ int jj;scanf(\"%d\",&amp;jj); if(jj&amp;&amp;isStu[j]){ add(i,j+n,1); } } } if(dinic(0,en)&gt;=num) printf(\"%c%c%c\\n\",94,95,94); else printf(\"%c%c%c\\n\",84,95,84); ro.clear(); for(int i=0;i&lt;MAXX;++i){ to[i].clear(); isStu[i]=false; }}int main(){ int t;scanf(\"%d\",&amp;t); while(t--) solve_it(); return 0;} E题: 飞行员配对题目传送门 题目 第二次世界大战时期，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2名飞行员，其中1名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空 军一次能派出最多的飞机 。对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案， 使皇家空军一次能派出最多的飞机。 Input 第1行有2个正整数 m 和 n。n 是皇家空军的飞行 员总数(n&lt;100);m 是外籍飞行员数。外籍飞行员编号为 1m;英国飞行员编号为 m+1n。接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。输入最后以 2 个-1 结束。 Output 第 1 行是最佳飞行 员配对方案一次能派出的最多的飞机数 M。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。 Sample Input 1234567891011125 101 71 82 62 92 103 73 84 74 85 10-1 -1 Sample Output 14 题目大意看题吧，都是中文 思路构建一个二分图，左边是外籍飞行员，右边是英国飞行员，接着把能够进行配合的飞行员进行连接，在左边构建一个原点，连接所有外籍飞行员，在右边构建一个汇点，连接所有英国飞行员。接着进行一次最大流即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=205;const double eps=0.0000001;struct rode{ int st,en,flow,cap;};vector&lt;rode&gt; ro;vector&lt;int&gt; to[MAXX];int n,m;int cur[MAXX],d[MAXX];bool vis[MAXX];inline void add(int st,int en,int cap){ rode re;int si=ro.size(); re.st=st;re.en=en;re.flow=0;re.cap=cap; ro.push_back(re);to[st].push_back(si); re.st=en;re.en=st;re.flow=0;re.cap=0; ro.push_back(re);to[en].push_back(si+1);}bool bfs(int st,int en){ memset(vis,0,sizeof(vis)); queue&lt;int&gt; qq; qq.push(st); d[st]=0;vis[st]=true; while(!qq.empty()){ int jj=qq.front();qq.pop(); int si=to[jj].size(); for(int i=0;i&lt;si;++i){ rode kk=ro[to[jj][i]]; if(!vis[kk.en]&amp;&amp;(kk.cap-kk.flow)&gt;0){ vis[kk.en]=true; d[kk.en]=d[jj]+1; qq.push(kk.en); } } } return vis[en];}int dfs(int now,int en,int flow){ if(now==en||flow==0) return flow; int re=0,f=0,si=to[now].size(); for(int&amp; i=cur[now];i&lt;si;++i){ rode&amp; jj=ro[to[now][i]]; if(d[jj.en]==d[jj.st]+1){ f=dfs(jj.en,en,min(flow,jj.cap-jj.flow)); if(f){ jj.flow+=f; ro[to[now][i]^1].flow-=f; re+=f; flow-=f; if(flow==0) break; } } } return re;}int dinic(int st,int en){ int re=0; while(bfs(st,en)){ memset(cur,0,sizeof(cur)); re+=dfs(st,en,Inf); } return re;}void solve_it(){ scanf(\"%d%d\",&amp;m,&amp;n); int n1=n+1; int jj,kk; while(~scanf(\"%d%d\",&amp;jj,&amp;kk)){ if(jj==-1) break; add(jj,kk,1); } for(int i=1;i&lt;=m;++i) add(0,i,1); for(int i=m+1;i&lt;=n;++i) add(i,n1,1); int ans=dinic(0,n1); if(ans) printf(\"%d\\n\",ans); else printf(\"No Solution!\\n\");}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) solve_it(); return 0;} 总结这一部分难度比较大，进行了一天的练习，也算是差不多理解了，但是练习还是太少，并不能熟练运用，仍需多加练习，明天进行最小费用最大流。","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"图论","slug":"图论","permalink":"http://shaun-2314.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"每日总结-1月13日","slug":"1-13","date":"2022-01-13T11:39:34.000Z","updated":"2022-04-15T07:09:37.306Z","comments":true,"path":"2022/01/13/1-13/","link":"","permalink":"http://shaun-2314.github.io/2022/01/13/1-13/","excerpt":"","text":"搜索进阶dfs&amp;bfs&amp;迭代加深&amp;A*算法 今日战况 部分题目题解B题: Sticks题目传送门 题目 George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero. Input The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero. Output The output should contains the smallest possible length of original sticks, one per line. Sample Input 1234595 2 1 5 2 1 5 2 141 2 3 40 Sample Output 1265 题目大意大致就是给你n根长度小于50的木棍，要把他们拼成若干根相同长度的原始木棍，求这个长度的最小值 思路n&lt;65，考虑从小到大枚举每一种可能的原始木棍长度len，显然，len应该是所有木棍长度总和sum的约数(长度只能为整数），并且原始木棍的根数就应该是sum/len，然后对于每一种len，我们依次搜索每根原始木棍由哪些分散的木棍拼接而成即可. 加上各种优化 优化搜索顺序 考虑到长度短的木棍比起长度长的木棍来说，拼接更为灵活，因此对木棍长度进行排序，从长到短搜索 排除等效冗余 先拼上 x 和先拼上 y 是等效的，只需要搜索一次这种情况 记录最近一次尝试拼接的小木棍的长度，如果分支搜索失败的话，不再尝试其他相同长度的木棍（相同长度的木棍都是等效的，该分支失败意味着所有相同长度的木棍必定会拼接失败） 如果在拼接某个原始木棍时拼接第一根木棍的搜索分支就以失败返回，直接判定该分支无解，如果拼接第一根木棍就失败了的话，说明这根木棍拼不成长度为len的原始木棍，而如果继续搜索其他长度的小木棍的话，为了拼成所有的原始木棍，这根小木棍在后面是必须要用到的，如果它拼接失败，拼在其他原始木棍上也一定失败，不用继续往下搜索，因此可以直接判定无解 其他优化 使用二分查找的方式来寻找解(代码中未使用) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=105;const double eps=0.0000001;int n,a[MAXX],st,en,num,lenn;bool vis[MAXX];bool dfs(int now,int len,int id){ if(now&gt;num) return true; if(len==lenn) return dfs(now+1,0,0); int temp=0; for(int i=id+1;i&lt;=n;++i){ if(!vis[i]&amp;&amp;len+a[i]&lt;=lenn&amp;&amp;a[i]!=temp){ vis[i]=true; if(dfs(now,len+a[i],id)) return true; temp=a[i]; vis[i]=false; if(len==0) return false; } } return false;}bool cmp(int jj,int kk){return jj&gt;kk;}void solve_it(){ st=0;en=0; for(int i=1;i&lt;=n;++i){ scanf(\"%d\",&amp;a[i]); st=max(st,a[i]); en+=a[i]; } sort(a+1,a+n+1,cmp); int ans; for(int i=st;i&lt;=en;++i){ if(en%i) continue; num=en/i;lenn=i; ans=i; for(int j=1;j&lt;=n;++j) vis[j]=false; if(dfs(1,0,0)) break; } printf(\"%d\\n\",ans);}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) while(~scanf(\"%d\",&amp;n)&amp;&amp;n) solve_it(); return 0;} G题: Addition Chains题目传送门 题目 An addition chain for n is an integer sequence with the following four properties:a_0 = 1a_m = na_0 &lt; a_1 &lt; a_2 &lt; … &lt; a_m-1 &lt; a_mFor each k (1&lt;=k&lt;=m) there exist two (not necessarily different) integers i and j (0&lt;=i, j&lt;=k-1) with a_k=a_i+a_jYou are given an integer n. Your job is to construct an addition chain for n with minimal length. If there is more than one such sequence, any one is acceptable.For example, &lt;1,2,3,5&gt; and &lt;1,2,4,5&gt; are both valid solutions when you are asked for an addition chain for 5. Input The input will contain one or more test cases. Each test case consists of one line containing one integer n (1&lt;=n&lt;=100). Input is terminated by a value of zero (0) for n. Output For each test case, print one line containing the required integer sequence. Separate the numbers by one blank.Hint: The problem is a little time-critical, so use proper break conditions where necessary to reduce the search space. Sample Input 123456571215770 Sample Output 123451 2 4 51 2 4 6 71 2 4 8 121 2 4 5 10 151 2 4 8 9 17 34 68 77 题目大意有一个严格递增的序列，a_0=1，且对于每一个k(k&gt;=1)，存在两个可以相同也可以不同的数i,j(0&lt;=i,j&lt;=k-1)，使得a_k=a_i+a_j 输入一个数n，求能得到数字n的最短的该序列 思路使用迭代加深的思路，逐步加深搜索的层数，再利用贪心，每次都倒序进行搜索，即从k-1搜索到1，直到得到结果即为答案 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=20;const double eps=0.0000001;int n,a[MAXX],depth;bool has;void output(){ for(int i=1;i&lt;MAXX;++i){ if(a[i]==n){ printf(\"%d\\n\",a[i]); break; } printf(\"%d \",a[i]); }}void dfs(int now){ if(now&gt;depth) return; for(int i=now-1;i&gt;=1;--i){ for(int j=i;j&gt;=1;--j){ a[now]=a[i]+a[j]; if(a[now]&lt;=a[now-1]) break; if(a[now]==n){ output(); has=true;return; } dfs(now+1); if(has) return; } if(has) return; }}void solve_it(){ if(n==1){ output(); return; } has=false; for(int i=2;i&lt;=12;++i){ depth=i; dfs(2); if(has) break; }}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) a[1]=1; while(~scanf(\"%d\",&amp;n)){ if(n==0) break; solve_it(); } return 0;} H题: 打开灯泡 Switch the Lamp On题目传送门 题目就不放了，比较简单，就是一个bfs求最短路，不过是双向队列的bfs，和用优先队列一样的，感觉就是建图有点麻烦 就直接放代码了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=505;const double eps=0.0000001;struct rode{ int tox,toy,len; bool vis;};struct point{ int x,y,len;};int n,m,n1,m1,ans;char s[MAXX][MAXX];vector&lt;rode&gt; ro[MAXX][MAXX];void bfs(){ deque&lt;point&gt; qq; point pt;pt.x=1;pt.y=1;pt.len=0; qq.emplace_front(pt); while(!qq.empty()){ point pp=qq.front();qq.pop_front(); if(pp.x==n1&amp;&amp;pp.y==m1){ ans=pp.len; break; } int si=ro[pp.x][pp.y].size(); for(int i=0;i&lt;si;++i){ if(!ro[pp.x][pp.y][i].vis){ ro[pp.x][pp.y][i].vis=true; pt.x=ro[pp.x][pp.y][i].tox; pt.y=ro[pp.x][pp.y][i].toy; pt.len=pp.len+ro[pp.x][pp.y][i].len; if(ro[pp.x][pp.y][i].len==0) qq.emplace_front(pt); else qq.emplace_back(pt); } } } }void solve_it(){ scanf(\"%d%d\",&amp;n,&amp;m); n1=n+1;m1=m+1; for(int i=1;i&lt;=n;++i){ getchar(); scanf(\"%s\",s[i]+1); } ans=Inf; rode temp;temp.vis=false; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j){ temp.len=(s[i][j]=='\\\\'); temp.tox=i;temp.toy=j+1; ro[i+1][j].emplace_back(temp); temp.tox=i+1;temp.toy=j; ro[i][j+1].emplace_back(temp); temp.len=1-temp.len; temp.tox=i+1;temp.toy=j+1; ro[i][j].emplace_back(temp); temp.tox=i;temp.toy=j; ro[i+1][j+1].emplace_back(temp); } bfs(); if(ans==Inf) printf(\"NO SOLUTION\\n\"); else printf(\"%d\\n\",ans);}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) solve_it(); return 0;} J题: Bloxorz l题目传送门 一个比较繁琐的bfs求最短路题目 题目 Little Tom loves playing games. One day he downloads a little computer game called ‘Bloxorz’ which makes him excited. It’s a game about rolling a box to a specific position on a special plane. Precisely, the plane, which is composed of several unit cells, is a rectangle shaped area. And the box, consisting of two perfectly aligned unit cube, may either lies down and occupies two neighbouring cells or stands up and occupies one single cell. One may move the box by picking one of the four edges of the box on the ground and rolling the box 90 degrees around that edge, which is counted as one move. There are three kinds of cells, rigid cells, easily broken cells and empty cells. A rigid cell can support full weight of the box, so it can be either one of the two cells that the box lies on or the cell that the box fully stands on. A easily broken cells can only support half the weight of the box, so it cannot be the only cell that the box stands on. An empty cell cannot support anything, so there cannot be any part of the box on that cell. The target of the game is to roll the box standing onto the only target cell on the plane with minimum moves. The box stands on a single cell ↑ The box lies on two neighbouring cells, horizontally ↑ The box lies on two neighbouring cells, vertically ↑ After Little Tom passes several stages of the game, he finds it much harder than he expected. So he turns to your help. Input Input contains multiple test cases. Each test case is one single stage of the game. It starts with two integers R and C(3 ≤ R, C ≤ 500) which stands for number of rows and columns of the plane. That follows the plane, which contains R lines and C characters for each line, with ‘O’ (Oh) for target cell, ‘X’ for initial position of the box, ‘.’ for a rigid cell, ‘#’ for a empty cell and ‘E’ for a easily broken cell. A test cases starts with two zeros ends the input. It guarantees that There’s only one ‘O’ in a plane. There’s either one ‘X’ or neighbouring two ‘X’s in a plane. The first(and last) row(and column) must be ‘#’(empty cell). Cells covered by ‘O’ and ‘X’ are all rigid cells. Output For each test cases output one line with the minimum number of moves or “Impossible” (without quote) when there’s no way to achieve the target cell. Sample Input 1234567897 7########..X####..##O##....E##....E##.....########0 0 Sample Output 110 题目大意有一个 1 * 1 * 2 大小的长方体，在一个棋盘上，有初始位置，有一个目标位置，问走几步能到达目标位置，棋盘上有几种方块地皮 ‘.’ 坚硬的地面，可以立在上面 ‘E’ 易碎的(玻璃?)，不能立在上面，但是可以躺一半在上面 ‘#’ 上面不能存在东西，(虚空?) ‘X’ 起始位置，可能是平躺的 ‘O’ 目标位置，只能是立着的 输入棋盘大小和整个棋盘，输出最少需要走几步能到目标位置。 思路从起点开始bfs，和普通的dfs相比，就是麻烦，需要记录长方体的位置和状态（立着，横着平躺，竖着平躺），每个状态对应的下一步还都不一样。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int Inf=0x3f3f3f3f;const int MAXX=505;const double eps=0.0000001;struct point{ int x,y,kind;//0:立起来 1:竖着 2:横着 point(int xx=0,int yy=0,int kk=0):x(xx),y(yy),kind(kk){} friend bool operator&lt;(point jj,point kk){return jj.kind&lt;kk.kind;}};struct PP{ point pos; int len; friend bool operator&lt;(PP jj,PP kk){ return jj.len&gt;kk.len; }};int n,m,ans;char a[MAXX][MAXX],vis[MAXX][MAXX][4];void bfs(){ int enx=0,eny=0; queue&lt;PP&gt; pq; point p;PP pp; pp.len=0; bool findst=false,finden=false; for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=m;++j){ if(!findst&amp;&amp;a[i][j]=='X'){ findst=true; pp.pos.x=i;pp.pos.y=j; bool two=false; if(a[i+1][j]=='X'){ two=true; pp.pos.kind=1; } else if(a[i][j+1]=='X'){ two=true; pp.pos.kind=2; } if(!two){ pp.pos.kind=0; } pq.push(pp); vis[pp.pos.x][pp.pos.y][pp.pos.kind]=true; } if(!finden&amp;&amp;a[i][j]=='O'){ finden=true; enx=i;eny=j; } } if(findst&amp;&amp;finden) break; } //bfs while(!pq.empty()){ PP now=pq.front();pq.pop(); int i=now.pos.x,j=now.pos.y; if(now.pos.kind==0){ if(now.pos.x==enx&amp;&amp;now.pos.y==eny){ ans=now.len; break; } if(i-2&gt;=1) if(a[i-1][j]!='#'&amp;&amp;a[i-2][j]!='#'){ p.kind=1;p.x=i-2;p.y=j; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } if(i+2&lt;=n) if(a[i+1][j]!='#'&amp;&amp;a[i+2][j]!='#'){ p.kind=1;p.x=i+1;p.y=j; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } if(j-2&gt;=1) if(a[i][j-1]!='#'&amp;&amp;a[i][j-2]!='#'){ p.kind=2;p.x=i;p.y=j-2; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } if(j+2&lt;=m) if(a[i][j+1]!='#'&amp;&amp;a[i][j+2]!='#'){ p.kind=2;p.x=i;p.y=j+1; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } } else if(now.pos.kind==1){ if(i-1&gt;=1) if(a[i-1][j]!='#'&amp;&amp;a[i-1][j]!='E'){ p.kind=0;p.x=i-1;p.y=j; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } if(i+2&lt;=n) if(a[i+2][j]!='#'&amp;&amp;a[i+2][j]!='E'){ p.kind=0;p.x=i+2;p.y=j; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } if(j-1&gt;=1) if(a[i][j-1]!='#'&amp;&amp;a[i+1][j-1]!='#'){ p.kind=1;p.x=i;p.y=j-1; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } if(j+1&lt;=m) if(a[i][j+1]!='#'&amp;&amp;a[i+1][j+1]!='#'){ p.kind=1;p.x=i;p.y=j+1; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } } else if(now.pos.kind==2){ if(i-1&gt;=1) if(a[i-1][j]!='#'&amp;&amp;a[i-1][j+1]!='#'){ p.kind=2;p.x=i-1;p.y=j; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } if(i+1&lt;=n) if(a[i+1][j]!='#'&amp;&amp;a[i+1][j+1]!='#'){ p.kind=2;p.x=i+1;p.y=j; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } if(j-1&gt;=1) if(a[i][j-1]!='#'&amp;&amp;a[i][j-1]!='E'){ p.kind=0;p.x=i;p.y=j-1; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } if(j+2&lt;=m) if(a[i][j+2]!='#'&amp;&amp;a[i][j+2]!='E'){ p.kind=0;p.x=i;p.y=j+2; if(!vis[p.x][p.y][p.kind]){ vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); } } } }}void solve_it(){ for(int i=1;i&lt;=n;++i){ getchar(); scanf(\"%s\",a[i]+1); } ans=-1; bfs(); if(ans==-1) printf(\"Impossible\\n\"); else printf(\"%d\\n\",ans); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) for(int k=0;k&lt;=2;++k) vis[i][j][k]=false;}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) while(~scanf(\"%d%d\",&amp;n,&amp;m)){ if(n==0&amp;&amp;m==0) break; solve_it(); } return 0;} 总结搜索的优化还是比较难的，优化永无止境。","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"搜索","slug":"搜索","permalink":"http://shaun-2314.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"每日总结-1月12日","slug":"1-12","date":"2022-01-12T12:47:08.000Z","updated":"2022-04-15T07:09:30.067Z","comments":true,"path":"2022/01/12/1-12/","link":"","permalink":"http://shaun-2314.github.io/2022/01/12/1-12/","excerpt":"","text":"搜索进阶dfs&amp;bfs&amp;迭代加深&amp;A*算法 剪枝优化 优化搜索顺序 排除等效冗余 可行性剪枝 最优性剪枝 记忆化搜索 常数优化 今日战况 前言我个人感觉我的搜索应该还是差不多的，但是今天的题目让我觉得我的剪枝方面的水平还有待提升，以及自己的构造能力不强，有时候在脑子里面能想出来一些东西，但是无法马上构思出代码，还得想亿会才能(也可能想不出来)。 部分题目题解C题: Soduku (最简单版本的)题目传送门 题目 Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task. Input The input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0. Output For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them. Sample Input 123456789101103000509002109400000704000300502006060000050700803004000401000009205800804000107 Sample Output 123456789143628579572139468986754231391542786468917352725863914237481695619275843854396127 题目大意有t个测试样例，每个样例都有一个9*9的数独，里面的0表示未确定的数，编程写这个数独，输出写好之后的数独。 思路暴力的话就是用搜索遍历每一行每一个位置，枚举每一个可能的结果，直到得到结果。 此题数据比较水，暴力就直接能AC。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;int a[10][10],belong[10][10];bool r[10][10],c[10][10],d[10][10],can;void output(){ for(int i=1;i&lt;=9;++i){ for(int j=1;j&lt;=9;++j) printf(\"%d\",a[i][j]); printf(\"\\n\"); }}void dfs(int jj,int kk){ if(can) return; if(a[jj][kk]){ if(kk&lt;9) dfs(jj,kk+1); else if(jj&lt;9) dfs(jj+1,1); else{ output(); can=true; } return; } for(int i=1;i&lt;=9;++i){ if(r[jj][i]||c[kk][i]||d[belong[jj][kk]][i]) continue; a[jj][kk]=i; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=true; if(kk&lt;9) dfs(jj,kk+1); else if(jj&lt;9) dfs(jj+1,1); else{ output(); can=true; return; } if(can) return; a[jj][kk]=0; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=false; }}void solve_it(){ for(int i=1;i&lt;=9;++i){ char jj; getchar(); for(int j=1;j&lt;=9;++j){ scanf(\"%c\",&amp;jj); a[i][j]=jj-'0'; if(a[i][j]!=0){ r[i][a[i][j]]=true; c[j][a[i][j]]=true; d[belong[i][j]][a[i][j]]=true; } } } can=false; dfs(1,1); for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j){ a[i][j]=0; r[i][j]=c[i][j]=d[i][j]=false; }}int main(){ for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j) belong[i][j]=(i-1)/3*3+(j-1)/3+1; int t;scanf(\"%d\",&amp;t); while(t--) solve_it(); return 0;} D题: Soduku (变态数据版本的)(未做出来)题目传送门 题目 In the game of Sudoku, you are given a large 9 × 9 grid divided into smaller 3 × 3 subgrids. For example, Given some of the numbers in the grid, your goal is to determine the remaining numbers such that the numbers 1 through 9 appear exactly once in (1) each of nine 3 × 3 subgrids, (2) each of the nine rows, and (3) each of the nine columns. Input The input test file will contain multiple cases. Each test case consists of a single line containing 81 characters, which represent the 81 squares of the Sudoku grid, given one row at a time. Each character is either a digit (from 1 to 9) or a period (used to indicate an unfilled square). You may assume that each puzzle in the input will have exactly one solution. The end-of-file is denoted by a single line containing the word “end”. Output For each test case, print a line representing the completed Sudoku puzzle. Sample Input 123.2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.end Sample Output 12527389416819426735436751829375692184194538267268174593643217958951843672782965341416837529982465371735129468571298643293746185864351297647913852359682714128574936 题目大意和上道题大意一样，输入一个数独，输出填充完整的数独。但是测试数据要比C题离谱的多。 思路各种优化 我目前的代码只进行了搜索顺序的优化，常熟优化还没学会。 附上进行了搜索顺序优化的代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;struct row{ int id,num;}cnt[10];int a[10][10],belong[10][10],rate[10];string s;bool r[10][10],c[10][10],d[10][10],can;bool cmp(row jj,row kk){return jj.num&lt;kk.num;}void output(){ for(int i=1;i&lt;=9;++i){ for(int j=1;j&lt;=9;++j) printf(\"%d\",a[i][j]); } printf(\"\\n\");}void dfs(int jj,int kk){// printf(\"%d %d\\n\",jj,rate[jj]); if(can) return; if(a[jj][kk]){ if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else{ output(); can=true; } return; } for(int i=1;i&lt;=9;++i){ if(r[jj][i]||c[kk][i]||d[belong[jj][kk]][i]) continue; a[jj][kk]=i; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=true; if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else{ output(); can=true; return; } if(can) return; a[jj][kk]=0; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=false; }}void solve_it(){ int p=-1; for(int i=1;i&lt;=9;++i){ cnt[i].id=i; cnt[i].num=0; for(int j=1;j&lt;=9;++j){ if(s[++p]=='.'){ a[i][j]=0; ++cnt[i].num; continue; } a[i][j]=s[p]-'0'; r[i][a[i][j]]=true; c[j][a[i][j]]=true; d[belong[i][j]][a[i][j]]=true; } } sort(cnt+1,cnt+10,cmp); for(int i=1;i&lt;=9;++i) rate[cnt[i].id]=i; can=false; dfs(cnt[1].id,1); for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j){ a[i][j]=0; r[i][j]=c[i][j]=d[i][j]=false; }}int main(){ for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j) belong[i][j]=(i-1)/3*3+(j-1)/3+1; // int t;scanf(\"%d\",&amp;t);// while(t--) while(true){ cin&gt;&gt;s; if(s==\"end\") break; solve_it(); } return 0;} F题: 靶形数独题目传送门 这里就不放题目了，思路和上面的数独的题一样，通过优化搜索顺序即可AC 枚举出每种可能的最终结果，取最大值即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;struct row{ int id,num;}cnt[10];int a[10][10],belong[10][10],rate[10],ans;bool r[10][10],c[10][10],d[10][10];bool cmp(row jj,row kk){return jj.num&lt;kk.num;}void output(){ for(int i=1;i&lt;=9;++i){ for(int j=1;j&lt;=9;++j) printf(\"%d \",a[i][j]); } printf(\"\\n\");}int getans(){ int re=10*a[5][5]; for(int i=1;i&lt;=4;++i){ int st=5-i,en=5+i; int fen=10-i; for(int j=st;j&lt;=en;++j){ re+=a[st][j]*fen; re+=a[en][j]*fen; } for(int j=st+1;j&lt;en;++j){ re+=a[j][st]*fen; re+=a[j][en]*fen; } } return re;}void dfs(int jj,int kk){ if(a[jj][kk]){ if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else{// output(); ans=max(ans,getans()); } return; } for(int i=1;i&lt;=9;++i){ if(r[jj][i]||c[kk][i]||d[belong[jj][kk]][i]) continue; a[jj][kk]=i; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=true; if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else{// output(); ans=max(ans,getans()); } a[jj][kk]=0; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=false; }}void solve_it(){ for(int i=1;i&lt;=9;++i){ cnt[i].id=i; cnt[i].num=0; for(int j=1;j&lt;=9;++j){ scanf(\"%d\",&amp;a[i][j]); if(a[i][j]==0){ ++cnt[i].num; continue; } r[i][a[i][j]]=true; c[j][a[i][j]]=true; d[belong[i][j]][a[i][j]]=true; } } sort(cnt+1,cnt+10,cmp); for(int i=1;i&lt;=9;++i) rate[cnt[i].id]=i; ans=-1; dfs(cnt[1].id,1); printf(\"%d\\n\",ans); }int main(){ for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j) belong[i][j]=(i-1)/3*3+(j-1)/3+1; // int t;scanf(\"%d\",&amp;t);// while(t--) solve_it(); return 0;} 总结今天的搜索进阶听课和写题都挺有收获，知道了搜索的各种优化思路，以及了解到了迭代加深的思路，并成功依此A题。 今天先总结这三道题，明天再总结其他题目","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"搜索","slug":"搜索","permalink":"http://shaun-2314.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"cfRound#764(Div.3)Summary","slug":"cfRound-764-Div-3-Summary","date":"2022-01-11T13:36:07.000Z","updated":"2022-04-21T16:27:32.969Z","comments":true,"path":"2022/01/11/cfround-764-div-3-summary/","link":"","permalink":"http://shaun-2314.github.io/2022/01/11/cfround-764-div-3-summary/","excerpt":"","text":"Codeforces Round 764(Div. 3)CONTEST传送门 战况Standing Rating 补题D - Palindromes Coloring题目 time limit per test: 2 seconds memory limit per test: 256 megabytes input: standard input output: standard output You have a string s consisting of lowercase Latin alphabet letters. You can color some letters in colors from 1 to k. It is not necessary to paint all the letters. But for each color, there must be a letter painted in that color. Then you can swap any two symbols painted in the same color as many times as you want. After that, k strings will be created, i-th of them will contain all the characters colored in the color i, written in the order of their sequence in the string s. Your task is to color the characters of the string so that all the resulting k strings are palindromes, and the length of the shortest of these k strings is as large as possible. Read the note for the first test case of the example if you need a clarification. Recall that a string is a palindrome if it reads the same way both from left to right and from right to left. For example, the strings abacaba, cccc, z and dxd are palindromes, but the strings abab and aaabaa — are not. Input The first line of input data contains a single integer t (1 ≤ t ≤ 10⁴ ) — the number of input data sets in the test. The descriptions of the input data sets follow. The first line of the description of each input data set contains two integers n and k ( 1 ≤ k ≤ n ≤ 2⋅10⁵ ) — the length of the string and the number of colors in which its letters can be painted. The second line of the description of each input data set contains a string s of length n consisting of lowercase letters of the Latin alphabet. It is guaranteed that the sum of n over all test cases does not exceed 2⋅10⁵ . Output For each set of input data, output a single integer — the maximum length of the shortest palindrome string that can be obtained. Example input 108 2bxyaxzay6 3aaaaaa6 1abcdef6 6abcdef3 2dxd11 2abcabcabcac6 6sipkic7 2eatoohd3 1llw6 2bfvfbv output 3211151133 Note In the first test case, s =”bxyaxzay”, k=2. We use indices in the string from 1 to 8. The following coloring will work: bxyaxzaybxyaxzay (the letter z remained uncolored). After painting: swap two red characters (with the indices 1 and 4), we get axybxzay; swap two blue characters (with the indices 5 and 8), we get axybyzax. Now, for each of the two colors we write out the corresponding characters from left to right, we get two strings aba and xyyx. Both of them are palindromes, the length of the shortest is 3. It can be shown that the greatest length of the shortest palindrome cannot be achieved. In the second set of input data, the following coloring is suitable: [1,1,2,2,3,3]. There is no need to swap characters. Both received strings are equal to aa, they are palindromes and their length is 2. In the third set of input data, you can color any character and take it into a string. In the fourth set of input data, you can color the i-th character in the color i. In the fifth set of input data can be colored in each of the colors of one character. In the sixth set of input data, the following coloring is suitable: [1,1,1,1,1,2,2,2,2,2,0]. Rearrange the characters so as to get the palindromes abcba and acbca. 大概意思输入一个长度为 n 的由小写字母组成的字符串，取其中的字母组成 k 个回文字符串，每个字母(位置不同的每个字母)最多只能属于一个字符串。问怎样取能使得取得的 k 个回文字符串中的最短的那一个尽量长。输出这个长度。 我当时的思路在一个回文串中，若该回文串的长度为偶数，则每个字母出现的次数都是偶数(即成对出现)，若该回文串的长度为奇数，则有且只有一个字母出现的次数为奇数，且其他字母出现的次数为偶数(成对出现)。 记录下原字符串中每个字母出现的次数，接着，记录下成对出现的字母有几组(记两个相同的字母为一组)和单个出现的字母有几个。 接着，就是对每一种情况的分析及枚举(详见代码)。 当时的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=200005;const double eps=0.0000001;int n,k,num[200];char a[MAXX];void solve_it(){ scanf(\"%d%d\",&amp;n,&amp;k); getchar(); scanf(\"%s\",a+1); int len=strlen(a+1); for(int i=1;i&lt;=len;++i){ ++num[a[i]]; } int sum=0,dan=0; for(int i='a';i&lt;='z';++i){ if(num[i]%2==1){ sum+=num[i]-1; ++dan; } else sum+=num[i]; } sum/=2; int ans; if(k&gt;n/2) ans=1; else if(sum&lt;k) ans=1; else{ ans=sum/k*2; if(sum%k==0){ if(dan&gt;=k) ++ans; } else{ int s=sum%k; dan+=s*2; if(dan&lt;k) ans=ans; else ++ans; } } printf(\"%d\\n\",ans); for(int i='a';i&lt;='z';++i) num[i]=0;}int main(){ int t;scanf(\"%d\",&amp;t); while(t--) solve_it(); return 0;} 现在想的思路最小值最大化，典型的二分。(但是当时我不会写二分😭,而且看着E题和F题都好像要用到二分) 现在的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=200005;const double eps=0.0000001;int n,k,num[200];int sum=0,dan=0,can;char a[MAXX];bool check(int jj){ if(jj&lt;=sum/k*2+can) return true; else return false;}void solve_it(){ scanf(\"%d%d\",&amp;n,&amp;k); getchar(); scanf(\"%s\",a+1); int len=strlen(a+1); for(int i=1;i&lt;=len;++i){ ++num[a[i]]; } for(int i='a';i&lt;='z';++i){ sum+=num[i]/2; dan+=num[i]%2; } if(sum%k*2+dan&gt;=k) can=1; else can=0; int l=1,r=n,mid; while(l&lt;r){ mid=(l+r+1)/2; if(check(mid)) l=mid; else r=mid-1; } printf(\"%d\\n\",r); for(int i='a';i&lt;='z';++i) num[i]=0; sum=dan=0;}int main(){ int t;scanf(\"%d\",&amp;t); while(t--) solve_it(); return 0;} 总结二分杀我","categories":[{"name":"cf总结","slug":"cf总结","permalink":"http://shaun-2314.github.io/categories/cf%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"cf","slug":"cf","permalink":"http://shaun-2314.github.io/tags/cf/"}]},{"title":"每日总结-1月11日","slug":"1-11","date":"2022-01-11T13:17:05.000Z","updated":"2022-04-15T07:09:23.909Z","comments":true,"path":"2022/01/11/1-11/","link":"","permalink":"http://shaun-2314.github.io/2022/01/11/1-11/","excerpt":"","text":"dp进阶区间dp&amp;树形dp&amp;概率dp&amp;数位dp 今日战况 前言vj上的题好难啊， 第一题我看着和昨天的那道”石子合并”挺像的，但就是不知道怎么类比过去，看了半天就是不知道该怎么写。其他题看着也都好难，思路也都想不出来。 关于昨晚的CFCF Round #764 (Div. 3)总结 总结进阶dp(还有基础dp)现在还是软肋，仍需大量练习理解。","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://shaun-2314.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"每日总结-1月10日","slug":"1-10","date":"2022-01-10T12:05:24.000Z","updated":"2022-04-15T07:09:17.613Z","comments":true,"path":"2022/01/10/1-10/","link":"","permalink":"http://shaun-2314.github.io/2022/01/10/1-10/","excerpt":"","text":"dp进阶区间dp&amp;树形dp&amp;概率dp&amp;数位dp 前言今天没有弄题目，就在网上找资料学习和做题。 感觉这一部分好难，不太好理解，难以运用。需要大量的练习。 区间dp区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。 令状态 f(i,j) 表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 f(i,j)=max{f(i,k)+f(k+1,j)+cost} ， cost 为将这两组元素合并起来的代价。 特点 合并：将两个或多个部分进行整合，当然也可以反过来。 特征：能将问题分解为能两两合并的形式。 求解：对整个问题设最优质，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。 例题石子合并 题目将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。 请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算： 选择一种合并石子的方案，使得做 n-1 次合并得分总和最大。 选择一种合并石子的方案，使得做 n-1 次合并得分总和最小。 输入格式 输入第一行一个整数 n ，表示有 n 堆石子。 第二行 n 个整数，表示每堆石子的数量。 输出格式 输出共两行： 第一行为合并得分总和最小值， 第二行为合并得分总和最大值。 样例 输入 1244 5 9 4 输出 124354 数据范围与提示 对于 100% 的数据，有 1 ≤ n ≤ 200 。 思路状态转移方程 环的处理 将链延长至两倍，变成 2*n 堆，其中第 i 堆与第 n+i 堆相同，用动态规划求解后，取 f(1,n),f(2,n+1),…,f(i,n+i-1) 中的最优值，即为最后的答案。 时间复杂度 O(n³) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=210;const double eps=0.0000001;int n,a[2*MAXX],sum[2*MAXX],dpmax[2*MAXX][2*MAXX],dpmin[2*MAXX][2*MAXX];void solve_it(){ scanf(\"%d\",&amp;n); int n2=n*2; for(int i=1;i&lt;=n;++i){ scanf(\"%d\",&amp;a[i]); a[n+i]=a[i]; } for(int i=1;i&lt;=n2;++i) sum[i]=sum[i-1]+a[i]; memset(dpmin,Inf,sizeof(dpmin)); for(int i=1;i&lt;=n2;++i) dpmin[i][i]=0; for(int c=2;c&lt;=n;++c){ for(int i=1;i&lt;n2;++i){ int j=i+c-1; for(int k=i;k&lt;j&amp;&amp;k&lt;n2;++k){ dpmax[i][j]=max(dpmax[i][j],dpmax[i][k]+dpmax[k+1][j]+sum[j]-sum[i-1]); dpmin[i][j]=min(dpmin[i][j],dpmin[i][k]+dpmin[k+1][j]+sum[j]-sum[i-1]); } } } int ansmax=dpmax[1][n],ansmin=dpmin[1][n]; for(int i=2;i&lt;=n;++i){ ansmax=max(ansmax,dpmax[i][i+n-1]); ansmin=min(ansmin,dpmin[i][i+n-1]); } printf(\"%d\\n%d\\n\",ansmin,ansmax); }int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) solve_it(); return 0;} 树形dp就是在树上进行的dp(确信) 一般为递归实现 例题没有上司的舞会 题目某大学有 n 个职员，编号为 1…n 。 他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。 现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 r_i，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。 所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 输入格式 输入的第一行是一个整数 n。 第 22 到第 (n + 1) 行，每行一个整数，第 (i + 1) 行的整数表示 ii 号职员的快乐指数 r_i 。 第 (n + 2) 到第 2n2n 行，每行输入一对整数 l , k ，代表 k 是 l 的直接上司。 输出格式 输出一行一个整数代表最大的快乐指数。 输入输出样例 输入 1234567891011121314711111111 32 36 47 44 53 5 输出 15 数据范围 对于 100% 的数据，保证 1 ≤ n ≤ 6 * 10³ , -128 ≤ r_i ≤ 127 , 1 ≤ l,k ≤ n，且给出的关系一定是一棵树。 思路用 f(i,0/1) 代表以 i 为根的子树的最优解 (0表示 i 不参加舞会，1表示 i 参加舞会)。 状态转移方程 f(i,0) = ∑max{f(x,1),f(x,0)} (上司不参加舞会，下属可参加可不参加) f(i,1) = ∑f(x,0) + a_i (上司参加舞会，下属不参加) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;int n,a[MAXX],ans[MAXX][2],in[MAXX];vector&lt;int&gt; son[MAXX];int dfs(int now,int flag){ if(ans[now][flag]!=Inf) return ans[now][flag]; if(flag==1){ int re=a[now]; int si=son[now].size(); for(int i=0;i&lt;si;++i) re+=dfs(son[now][i],0); return ans[now][flag]=re; } else{ int re=0; int si=son[now].size(); for(int i=0;i&lt;si;++i) re+=max(dfs(son[now][i],1),dfs(son[now][i],0)); return ans[now][flag]=re; }}void solve_it(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); for(int i=1;i&lt;n;++i){ int jj,kk;scanf(\"%d%d\",&amp;jj,&amp;kk); son[kk].emplace_back(jj); in[jj]=1; } memset(ans,Inf,sizeof(ans)); int ans=0; for(int i=1;i&lt;=n;++i){ if(!in[i]){ ans=max(dfs(i,0),dfs(i,1)); } } printf(\"%d\\n\",ans);}int main(){// int t;scanf(\"%d\",&amp;t);// while(t--) solve_it(); return 0;}","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://shaun-2314.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"每日总结-1月8日","slug":"1-8","date":"2022-01-08T15:33:25.000Z","updated":"2022-04-22T06:10:20.257Z","comments":true,"path":"2022/01/08/1-8/","link":"","permalink":"http://shaun-2314.github.io/2022/01/08/1-8/","excerpt":"","text":"高斯消元与线性基高斯消元与线性基(×) 疯狂查资料搭建博客(√) 使用的是hexo框架+github的方法搭建的博客 前言今天上午去做核酸，请了假，在做完核酸回来之后一直在搞博客，没有进行训练；下午也是大部分时间都在进行个人博客的一个搭建；晚上依然是搭建博客😭。 到了1点钟左右，终于是搭建好了自己的博客。 当然，十分感谢我的好朋友的帮助。不然不知道到什么时候才能搭建好。 慢的原因(其一)我刚开始是跟着我朋友给我发的链接进行一步一步操作的，但是，在进行了无数次的重复操作并且每次都是以失败告终后，我感觉，有问题。 之后去各种地方查找相关资料，最后，在(今晚🤔忘了几点了，总之就很晚，可能快12点吧)的时候，我终于在B站的这个视频中取到了真经。 具体原因就是我刚开始看的教程都是老版的教程，但是最近github有进行这方面的更新 在上传到github上时不能用密钥进行验证了 默认的分支进行修改了 解决方法(其一)(和原版教程相比) 将 _config.yml 文件中的 branch 选项改为 main (之前的教程中这里都是master) 在输入用户名密码验证的输入密码时，不能输入账户的密码，应该输入令牌(令牌设置在下一条)或者使用其他方法进行验证。 令牌的设置 在github中进入 settings 点击 Developer settings 点击 Personal access tokens 新建一个令牌 即可 慢的原因(其二)我在写昨天的那片博客的时候，需要在里面复制一张图片，但是，不管是使用绝对路径还是使用相对路径，在本地的.md文件中可以正常看到图片，但是到网页端就看不到图片。 解决方法(其二)我是看B站上的这个视频进行操作的。 具体的就是 将 _config.yml 文件中的 post_asset_folder 选项设置为 true 下载一个插件 在 \\source\\_posts 路径下进行 Git Bash 输入 npm add https://github.com/CodeFalling/hexo-asset-image 进行下载 之后在.md文件中需要使用图片时，使用相对路径即可 结语不管怎么样，也算是把博客搭建好了，之后会进行博客的美化工作。","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"数论","slug":"数论","permalink":"http://shaun-2314.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://shaun-2314.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"每日总结:1月7日","slug":"1-7","date":"2022-01-08T14:25:04.000Z","updated":"2022-04-15T07:09:03.320Z","comments":true,"path":"2022/01/08/1-7/","link":"","permalink":"http://shaun-2314.github.io/2022/01/08/1-7/","excerpt":"","text":"高斯消元与线性基感觉就是线代里面的矩阵，还有线性相关，这两部分。 今日战况 今日总结A题快要写吐了，但是在写A题的时候把高斯消元理解了不少。甚至快把矩阵类(结构体)给封装好了(bushi)。 把差不多写好的浮点数的矩阵结构体代码放到这里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081struct Matrix{ vector&lt;vector&lt;double&gt; &gt; c; int nn,mm; Matrix(){ nn=0;mm=0; } Matrix(int nnn,int mmm){ nn=nnn;mm=mmm; c.resize(nnn+1); for(int i=1;i&lt;=nn;++i) c[i].resize(mm+1); } friend Matrix operator*(const Matrix&amp; x,const Matrix&amp; y){ Matrix re(x.nn,y.mm); for(int i=1;i&lt;=x.nn;++i){ for(int j=1;j&lt;=y.mm;++j){ for(int k=1;k&lt;=x.mm;++k){ re.c[i][j]+=(double)((LL)(x.c[i][k]*y.c[k][j])%MOD)+x.c[i][k]*y.c[k][j]-(LL)(x.c[i][k]*y.c[k][j]); re.c[i][j]=(double)((LL)(re.c[i][j])%MOD)+re.c[i][j]-(LL)(re.c[i][j]); } } } return re; } void elimination(){ int nm=min(nn,mm); for(int cc=1,r=1;cc&lt;=nm;++cc){ int t=r; for(int i=r+1;i&lt;=nn;++i) if(fabs(c[i][cc])&gt;fabs(c[t][cc])) t=i; if(fabs(c[t][cc])&lt;eps) continue; if(t!=r){ for(int j=cc;j&lt;=mm;++j) swap(c[t][j],c[r][j]); } for(int j=mm;j&gt;=cc;--j) c[r][j]/=c[r][cc]; for(int i=1;i&lt;=nn;++i){ if(i==r) continue; if(fabs(c[i][cc])&gt;eps) for(int j=mm;j&gt;=cc;--j) c[i][j]=c[i][j]-c[i][cc]*c[r][j]; } ++r; } } Matrix inverse() const{ Matrix re(this-&gt;nn,this-&gt;mm),temp=*this; temp.mm*=2; for(int i=1;i&lt;=temp.nn;++i){ temp.c[i].resize(temp.mm+1,0); } for(int i=1;i&lt;=temp.nn;++i){ temp.c[i][temp.nn+i]=1; } temp.elimination(); for(int i=1;i&lt;=re.nn;++i) for(int j=1;j&lt;=re.mm;++j){ re.c[i][j]=temp.c[i][re.nn+j]; } return re; } void output(){ for(int i=1;i&lt;=nn;++i){ for(int j=1;j&lt;mm;++j){ printf(\"%lf \",c[i][j]); } printf(\"%lf\\n\",c[i][mm]); } }}; 在后面线性基的学习中，在网上查了不少，也理解的差不多了，感觉就跟线代里面的最大线性不相关向量组(好像叫这名)很像，只不过是变成了二进制的形式。 然后G题里有一个坑(可能并不算坑)，当线性基的元素个数等于n的时候，他们异或得不到0这个结果。 这部分感觉主要就是熟悉理解模板。但是C题实在是看不出来和高斯消元有什么关系，A题也是一直WA，用了两种方法，都是WA。现在也没想出比较好的解决方法。","categories":[{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"数论","slug":"数论","permalink":"http://shaun-2314.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-01-08T14:04:51.654Z","updated":"2022-01-08T14:04:51.654Z","comments":true,"path":"2022/01/08/hello-world/","link":"","permalink":"http://shaun-2314.github.io/2022/01/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"redis","slug":"redis","permalink":"http://shaun-2314.github.io/categories/redis/"},{"name":"python爬虫学习","slug":"python爬虫学习","permalink":"http://shaun-2314.github.io/categories/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"},{"name":"sql","slug":"sql","permalink":"http://shaun-2314.github.io/categories/sql/"},{"name":"面试","slug":"面试","permalink":"http://shaun-2314.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"cs162","slug":"cs162","permalink":"http://shaun-2314.github.io/categories/cs162/"},{"name":"2022牛客多校","slug":"2022牛客多校","permalink":"http://shaun-2314.github.io/categories/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"},{"name":"狂刷字符串","slug":"狂刷字符串","permalink":"http://shaun-2314.github.io/categories/%E7%8B%82%E5%88%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"算法学习","slug":"算法学习","permalink":"http://shaun-2314.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"2022杭电多校","slug":"2022杭电多校","permalink":"http://shaun-2314.github.io/categories/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"},{"name":"cf总结","slug":"cf总结","permalink":"http://shaun-2314.github.io/categories/cf%E6%80%BB%E7%BB%93/"},{"name":"一些感悟","slug":"一些感悟","permalink":"http://shaun-2314.github.io/categories/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/"},{"name":"个人板子总结","slug":"个人板子总结","permalink":"http://shaun-2314.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%9D%BF%E5%AD%90%E6%80%BB%E7%BB%93/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://shaun-2314.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"计网学习","slug":"计网学习","permalink":"http://shaun-2314.github.io/categories/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0/"},{"name":"2021ACM寒假集训","slug":"2021ACM寒假集训","permalink":"http://shaun-2314.github.io/categories/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://shaun-2314.github.io/tags/redis/"},{"name":"数据库","slug":"数据库","permalink":"http://shaun-2314.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"python","slug":"python","permalink":"http://shaun-2314.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://shaun-2314.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"scrapy","slug":"scrapy","permalink":"http://shaun-2314.github.io/tags/scrapy/"},{"name":"sql","slug":"sql","permalink":"http://shaun-2314.github.io/tags/sql/"},{"name":"sqlite3","slug":"sqlite3","permalink":"http://shaun-2314.github.io/tags/sqlite3/"},{"name":"面试","slug":"面试","permalink":"http://shaun-2314.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"阿里巴巴","slug":"阿里巴巴","permalink":"http://shaun-2314.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"},{"name":"cs162","slug":"cs162","permalink":"http://shaun-2314.github.io/tags/cs162/"},{"name":"操作系统","slug":"操作系统","permalink":"http://shaun-2314.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"shell","slug":"shell","permalink":"http://shaun-2314.github.io/tags/shell/"},{"name":"acm","slug":"acm","permalink":"http://shaun-2314.github.io/tags/acm/"},{"name":"字符串","slug":"字符串","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"LCT","slug":"LCT","permalink":"http://shaun-2314.github.io/tags/LCT/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://shaun-2314.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"线段树","slug":"线段树","permalink":"http://shaun-2314.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"扫描线","slug":"扫描线","permalink":"http://shaun-2314.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"离线","slug":"离线","permalink":"http://shaun-2314.github.io/tags/%E7%A6%BB%E7%BA%BF/"},{"name":"树剖","slug":"树剖","permalink":"http://shaun-2314.github.io/tags/%E6%A0%91%E5%89%96/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://shaun-2314.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"},{"name":"二分","slug":"二分","permalink":"http://shaun-2314.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"cf","slug":"cf","permalink":"http://shaun-2314.github.io/tags/cf/"},{"name":"扩展KMP","slug":"扩展KMP","permalink":"http://shaun-2314.github.io/tags/%E6%89%A9%E5%B1%95KMP/"},{"name":"最长公共子串","slug":"最长公共子串","permalink":"http://shaun-2314.github.io/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://shaun-2314.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Trie 树","slug":"Trie-树","permalink":"http://shaun-2314.github.io/tags/Trie-%E6%A0%91/"},{"name":"KMP","slug":"KMP","permalink":"http://shaun-2314.github.io/tags/KMP/"},{"name":"梦想","slug":"梦想","permalink":"http://shaun-2314.github.io/tags/%E6%A2%A6%E6%83%B3/"},{"name":"板子","slug":"板子","permalink":"http://shaun-2314.github.io/tags/%E6%9D%BF%E5%AD%90/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://shaun-2314.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"评论系统","slug":"评论系统","permalink":"http://shaun-2314.github.io/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://shaun-2314.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"命令","slug":"命令","permalink":"http://shaun-2314.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shaun-2314.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"博弈论","slug":"博弈论","permalink":"http://shaun-2314.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"图论","slug":"图论","permalink":"http://shaun-2314.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"搜索","slug":"搜索","permalink":"http://shaun-2314.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"动态规划","slug":"动态规划","permalink":"http://shaun-2314.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数论","slug":"数论","permalink":"http://shaun-2314.github.io/tags/%E6%95%B0%E8%AE%BA/"}]}