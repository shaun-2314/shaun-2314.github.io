{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"æ¯æ—¥æ€»ç»“-1æœˆ13æ—¥","slug":"1-13","date":"2022-01-13T11:39:34.000Z","updated":"2022-01-13T12:35:34.051Z","comments":true,"path":"2022/01/13/1-13/","link":"","permalink":"http://example.com/2022/01/13/1-13/","excerpt":"","text":"æœç´¢è¿›é˜¶dfs&amp;bfs&amp;è¿­ä»£åŠ æ·±&amp;A*ç®—æ³• ä»Šæ—¥æˆ˜å†µéƒ¨åˆ†é¢˜ç›®é¢˜è§£Bé¢˜: Sticksé¢˜ç›®ä¼ é€é—¨ é¢˜ç›® George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero. Input The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero. Output The output should contains the smallest possible length of original sticks, one per line. Sample Input 1234595 2 1 5 2 1 5 2 141 2 3 40 Sample Output 1265 é¢˜ç›®å¤§æ„å¤§è‡´å°±æ˜¯ç»™ä½ næ ¹é•¿åº¦å°äº50çš„æœ¨æ£ï¼Œè¦æŠŠä»–ä»¬æ‹¼æˆè‹¥å¹²æ ¹ç›¸åŒé•¿åº¦çš„åŸå§‹æœ¨æ£ï¼Œæ±‚è¿™ä¸ªé•¿åº¦çš„æœ€å°å€¼ æ€è·¯n&lt;65ï¼Œè€ƒè™‘ä»å°åˆ°å¤§æšä¸¾æ¯ä¸€ç§å¯èƒ½çš„åŸå§‹æœ¨æ£é•¿åº¦lenï¼Œæ˜¾ç„¶ï¼Œlenåº”è¯¥æ˜¯æ‰€æœ‰æœ¨æ£é•¿åº¦æ€»å’Œsumçš„çº¦æ•°(é•¿åº¦åªèƒ½ä¸ºæ•´æ•°ï¼‰ï¼Œå¹¶ä¸”åŸå§‹æœ¨æ£çš„æ ¹æ•°å°±åº”è¯¥æ˜¯sum/lenï¼Œç„¶åå¯¹äºæ¯ä¸€ç§lenï¼Œæˆ‘ä»¬ä¾æ¬¡æœç´¢æ¯æ ¹åŸå§‹æœ¨æ£ç”±å“ªäº›åˆ†æ•£çš„æœ¨æ£æ‹¼æ¥è€Œæˆå³å¯. åŠ ä¸Šå„ç§ä¼˜åŒ– ä¼˜åŒ–æœç´¢é¡ºåº è€ƒè™‘åˆ°é•¿åº¦çŸ­çš„æœ¨æ£æ¯”èµ·é•¿åº¦é•¿çš„æœ¨æ£æ¥è¯´ï¼Œæ‹¼æ¥æ›´ä¸ºçµæ´»ï¼Œå› æ­¤å¯¹æœ¨æ£é•¿åº¦è¿›è¡Œæ’åºï¼Œä»é•¿åˆ°çŸ­æœç´¢ æ’é™¤ç­‰æ•ˆå†—ä½™ å…ˆæ‹¼ä¸Š x å’Œå…ˆæ‹¼ä¸Š y æ˜¯ç­‰æ•ˆçš„ï¼Œåªéœ€è¦æœç´¢ä¸€æ¬¡è¿™ç§æƒ…å†µ è®°å½•æœ€è¿‘ä¸€æ¬¡å°è¯•æ‹¼æ¥çš„å°æœ¨æ£çš„é•¿åº¦ï¼Œå¦‚æœåˆ†æ”¯æœç´¢å¤±è´¥çš„è¯ï¼Œä¸å†å°è¯•å…¶ä»–ç›¸åŒé•¿åº¦çš„æœ¨æ£ï¼ˆç›¸åŒé•¿åº¦çš„æœ¨æ£éƒ½æ˜¯ç­‰æ•ˆçš„ï¼Œè¯¥åˆ†æ”¯å¤±è´¥æ„å‘³ç€æ‰€æœ‰ç›¸åŒé•¿åº¦çš„æœ¨æ£å¿…å®šä¼šæ‹¼æ¥å¤±è´¥ï¼‰ å¦‚æœåœ¨æ‹¼æ¥æŸä¸ªåŸå§‹æœ¨æ£æ—¶æ‹¼æ¥ç¬¬ä¸€æ ¹æœ¨æ£çš„æœç´¢åˆ†æ”¯å°±ä»¥å¤±è´¥è¿”å›ï¼Œç›´æ¥åˆ¤å®šè¯¥åˆ†æ”¯æ— è§£ï¼Œå¦‚æœæ‹¼æ¥ç¬¬ä¸€æ ¹æœ¨æ£å°±å¤±è´¥äº†çš„è¯ï¼Œè¯´æ˜è¿™æ ¹æœ¨æ£æ‹¼ä¸æˆé•¿åº¦ä¸ºlençš„åŸå§‹æœ¨æ£ï¼Œè€Œå¦‚æœç»§ç»­æœç´¢å…¶ä»–é•¿åº¦çš„å°æœ¨æ£çš„è¯ï¼Œä¸ºäº†æ‹¼æˆæ‰€æœ‰çš„åŸå§‹æœ¨æ£ï¼Œè¿™æ ¹å°æœ¨æ£åœ¨åé¢æ˜¯å¿…é¡»è¦ç”¨åˆ°çš„ï¼Œå¦‚æœå®ƒæ‹¼æ¥å¤±è´¥ï¼Œæ‹¼åœ¨å…¶ä»–åŸå§‹æœ¨æ£ä¸Šä¹Ÿä¸€å®šå¤±è´¥ï¼Œä¸ç”¨ç»§ç»­å¾€ä¸‹æœç´¢ï¼Œå› æ­¤å¯ä»¥ç›´æ¥åˆ¤å®šæ— è§£ å…¶ä»–ä¼˜åŒ– ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ–¹å¼æ¥å¯»æ‰¾è§£(ä»£ç ä¸­æœªä½¿ç”¨) ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=105;const double eps=0.0000001;int n,a[MAXX],st,en,num,lenn;bool vis[MAXX];bool dfs(int now,int len,int id)&#123; if(now&gt;num) return true; if(len==lenn) return dfs(now+1,0,0); int temp=0; for(int i=id+1;i&lt;=n;++i)&#123; if(!vis[i]&amp;&amp;len+a[i]&lt;=lenn&amp;&amp;a[i]!=temp)&#123; vis[i]=true; if(dfs(now,len+a[i],id)) return true; temp=a[i]; vis[i]=false; if(len==0) return false; &#125; &#125; return false;&#125;bool cmp(int jj,int kk)&#123;return jj&gt;kk;&#125;void solve_it()&#123; st=0;en=0; for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;a[i]); st=max(st,a[i]); en+=a[i]; &#125; sort(a+1,a+n+1,cmp); int ans; for(int i=st;i&lt;=en;++i)&#123; if(en%i) continue; num=en/i;lenn=i; ans=i; for(int j=1;j&lt;=n;++j) vis[j]=false; if(dfs(1,0,0)) break; &#125; printf(&quot;%d\\n&quot;,ans);&#125;int main()&#123;// int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) solve_it(); return 0;&#125; Gé¢˜: Addition Chainsé¢˜ç›®ä¼ é€é—¨ é¢˜ç›® An addition chain for n is an integer sequence with the following four properties:a_0 = 1a_m = na_0 &lt; a_1 &lt; a_2 &lt; â€¦ &lt; a_m-1 &lt; a_mFor each k (1&lt;=k&lt;=m) there exist two (not necessarily different) integers i and j (0&lt;=i, j&lt;=k-1) with a_k=a_i+a_jYou are given an integer n. Your job is to construct an addition chain for n with minimal length. If there is more than one such sequence, any one is acceptable.For example, &lt;1,2,3,5&gt; and &lt;1,2,4,5&gt; are both valid solutions when you are asked for an addition chain for 5. Input The input will contain one or more test cases. Each test case consists of one line containing one integer n (1&lt;=n&lt;=100). Input is terminated by a value of zero (0) for n. Output For each test case, print one line containing the required integer sequence. Separate the numbers by one blank.Hint: The problem is a little time-critical, so use proper break conditions where necessary to reduce the search space. Sample Input 123456571215770 Sample Output 123451 2 4 51 2 4 6 71 2 4 8 121 2 4 5 10 151 2 4 8 9 17 34 68 77 é¢˜ç›®å¤§æ„æœ‰ä¸€ä¸ªä¸¥æ ¼é€’å¢çš„åºåˆ—ï¼Œa_0=1ï¼Œä¸”å¯¹äºæ¯ä¸€ä¸ªk(k&gt;=1)ï¼Œå­˜åœ¨ä¸¤ä¸ªå¯ä»¥ç›¸åŒä¹Ÿå¯ä»¥ä¸åŒçš„æ•°i,j(0&lt;=i,j&lt;=k-1)ï¼Œä½¿å¾—a_k=a_i+a_j è¾“å…¥ä¸€ä¸ªæ•°nï¼Œæ±‚èƒ½å¾—åˆ°æ•°å­—nçš„æœ€çŸ­çš„è¯¥åºåˆ— æ€è·¯ä½¿ç”¨è¿­ä»£åŠ æ·±çš„æ€è·¯ï¼Œé€æ­¥åŠ æ·±æœç´¢çš„å±‚æ•°ï¼Œå†åˆ©ç”¨è´ªå¿ƒï¼Œæ¯æ¬¡éƒ½å€’åºè¿›è¡Œæœç´¢ï¼Œå³ä»k-1æœç´¢åˆ°1ï¼Œç›´åˆ°å¾—åˆ°ç»“æœå³ä¸ºç­”æ¡ˆ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=20;const double eps=0.0000001;int n,a[MAXX],depth;bool has;void output()&#123; for(int i=1;i&lt;MAXX;++i)&#123; if(a[i]==n)&#123; printf(&quot;%d\\n&quot;,a[i]); break; &#125; printf(&quot;%d &quot;,a[i]); &#125;&#125;void dfs(int now)&#123; if(now&gt;depth) return; for(int i=now-1;i&gt;=1;--i)&#123; for(int j=i;j&gt;=1;--j)&#123; a[now]=a[i]+a[j]; if(a[now]&lt;=a[now-1]) break; if(a[now]==n)&#123; output(); has=true;return; &#125; dfs(now+1); if(has) return; &#125; if(has) return; &#125;&#125;void solve_it()&#123; if(n==1)&#123; output(); return; &#125; has=false; for(int i=2;i&lt;=12;++i)&#123; depth=i; dfs(2); if(has) break; &#125;&#125;int main()&#123;// int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) a[1]=1; while(~scanf(&quot;%d&quot;,&amp;n))&#123; if(n==0) break; solve_it(); &#125; return 0;&#125; Hé¢˜: æ‰“å¼€ç¯æ³¡ Switch the Lamp Oné¢˜ç›®ä¼ é€é—¨ é¢˜ç›®å°±ä¸æ”¾äº†ï¼Œæ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯ä¸€ä¸ªbfsæ±‚æœ€çŸ­è·¯ï¼Œä¸è¿‡æ˜¯åŒå‘é˜Ÿåˆ—çš„bfsï¼Œå’Œç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¸€æ ·çš„ï¼Œæ„Ÿè§‰å°±æ˜¯å»ºå›¾æœ‰ç‚¹éº»çƒ¦ å°±ç›´æ¥æ”¾ä»£ç äº† ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=505;const double eps=0.0000001;struct rode&#123; int tox,toy,len; bool vis;&#125;;struct point&#123; int x,y,len;&#125;;int n,m,n1,m1,ans;char s[MAXX][MAXX];vector&lt;rode&gt; ro[MAXX][MAXX];void bfs()&#123; deque&lt;point&gt; qq; point pt;pt.x=1;pt.y=1;pt.len=0; qq.emplace_front(pt); while(!qq.empty())&#123; point pp=qq.front();qq.pop_front(); if(pp.x==n1&amp;&amp;pp.y==m1)&#123; ans=pp.len; break; &#125; int si=ro[pp.x][pp.y].size(); for(int i=0;i&lt;si;++i)&#123; if(!ro[pp.x][pp.y][i].vis)&#123; ro[pp.x][pp.y][i].vis=true; pt.x=ro[pp.x][pp.y][i].tox; pt.y=ro[pp.x][pp.y][i].toy; pt.len=pp.len+ro[pp.x][pp.y][i].len; if(ro[pp.x][pp.y][i].len==0) qq.emplace_front(pt); else qq.emplace_back(pt); &#125; &#125; &#125; &#125;void solve_it()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); n1=n+1;m1=m+1; for(int i=1;i&lt;=n;++i)&#123; getchar(); scanf(&quot;%s&quot;,s[i]+1); &#125; ans=Inf; rode temp;temp.vis=false; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; temp.len=(s[i][j]==&#x27;\\\\&#x27;); temp.tox=i;temp.toy=j+1; ro[i+1][j].emplace_back(temp); temp.tox=i+1;temp.toy=j; ro[i][j+1].emplace_back(temp); temp.len=1-temp.len; temp.tox=i+1;temp.toy=j+1; ro[i][j].emplace_back(temp); temp.tox=i;temp.toy=j; ro[i+1][j+1].emplace_back(temp); &#125; bfs(); if(ans==Inf) printf(&quot;NO SOLUTION\\n&quot;); else printf(&quot;%d\\n&quot;,ans);&#125;int main()&#123;// int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) solve_it(); return 0;&#125; Jé¢˜: Bloxorz lé¢˜ç›®ä¼ é€é—¨ ä¸€ä¸ªæ¯”è¾ƒç¹ççš„bfsæ±‚æœ€çŸ­è·¯é¢˜ç›® é¢˜ç›® Little Tom loves playing games. One day he downloads a little computer game called â€˜Bloxorzâ€™ which makes him excited. Itâ€™s a game about rolling a box to a specific position on a special plane. Precisely, the plane, which is composed of several unit cells, is a rectangle shaped area. And the box, consisting of two perfectly aligned unit cube, may either lies down and occupies two neighbouring cells or stands up and occupies one single cell. One may move the box by picking one of the four edges of the box on the ground and rolling the box 90 degrees around that edge, which is counted as one move. There are three kinds of cells, rigid cells, easily broken cells and empty cells. A rigid cell can support full weight of the box, so it can be either one of the two cells that the box lies on or the cell that the box fully stands on. A easily broken cells can only support half the weight of the box, so it cannot be the only cell that the box stands on. An empty cell cannot support anything, so there cannot be any part of the box on that cell. The target of the game is to roll the box standing onto the only target cell on the plane with minimum moves. The box stands on a single cell â†‘ The box lies on two neighbouring cells, horizontally â†‘ The box lies on two neighbouring cells, vertically â†‘ After Little Tom passes several stages of the game, he finds it much harder than he expected. So he turns to your help. Input Input contains multiple test cases. Each test case is one single stage of the game. It starts with two integers R and C(3 â‰¤ R, C â‰¤ 500) which stands for number of rows and columns of the plane. That follows the plane, which contains R lines and C characters for each line, with â€˜Oâ€™ (Oh) for target cell, â€˜Xâ€™ for initial position of the box, â€˜.â€™ for a rigid cell, â€˜#â€™ for a empty cell and â€˜Eâ€™ for a easily broken cell. A test cases starts with two zeros ends the input. It guarantees that Thereâ€™s only one â€˜Oâ€™ in a plane. Thereâ€™s either one â€˜Xâ€™ or neighbouring two â€˜Xâ€™s in a plane. The first(and last) row(and column) must be â€˜#â€™(empty cell). Cells covered by â€˜Oâ€™ and â€˜Xâ€™ are all rigid cells. Output For each test cases output one line with the minimum number of moves or â€œImpossibleâ€ (without quote) when thereâ€™s no way to achieve the target cell. Sample Input 1234567897 7########..X####..##O##....E##....E##.....########0 0 Sample Output 110 é¢˜ç›®å¤§æ„æœ‰ä¸€ä¸ª 1 * 1 * 2 å¤§å°çš„é•¿æ–¹ä½“ï¼Œåœ¨ä¸€ä¸ªæ£‹ç›˜ä¸Šï¼Œæœ‰åˆå§‹ä½ç½®ï¼Œæœ‰ä¸€ä¸ªç›®æ ‡ä½ç½®ï¼Œé—®èµ°å‡ æ­¥èƒ½åˆ°è¾¾ç›®æ ‡ä½ç½®ï¼Œæ£‹ç›˜ä¸Šæœ‰å‡ ç§æ–¹å—åœ°çš® â€˜.â€™ åšç¡¬çš„åœ°é¢ï¼Œå¯ä»¥ç«‹åœ¨ä¸Šé¢ â€˜Eâ€™ æ˜“ç¢çš„(ç»ç’ƒ?)ï¼Œä¸èƒ½ç«‹åœ¨ä¸Šé¢ï¼Œä½†æ˜¯å¯ä»¥èººä¸€åŠåœ¨ä¸Šé¢ â€˜#â€™ ä¸Šé¢ä¸èƒ½å­˜åœ¨ä¸œè¥¿ï¼Œ(è™šç©º?) â€˜Xâ€™ èµ·å§‹ä½ç½®ï¼Œå¯èƒ½æ˜¯å¹³èººçš„ â€˜Oâ€™ ç›®æ ‡ä½ç½®ï¼Œåªèƒ½æ˜¯ç«‹ç€çš„ è¾“å…¥æ£‹ç›˜å¤§å°å’Œæ•´ä¸ªæ£‹ç›˜ï¼Œè¾“å‡ºæœ€å°‘éœ€è¦èµ°å‡ æ­¥èƒ½åˆ°ç›®æ ‡ä½ç½®ã€‚ æ€è·¯ä»èµ·ç‚¹å¼€å§‹bfsï¼Œå’Œæ™®é€šçš„dfsç›¸æ¯”ï¼Œå°±æ˜¯éº»çƒ¦ï¼Œéœ€è¦è®°å½•é•¿æ–¹ä½“çš„ä½ç½®å’ŒçŠ¶æ€ï¼ˆç«‹ç€ï¼Œæ¨ªç€å¹³èººï¼Œç«–ç€å¹³èººï¼‰ï¼Œæ¯ä¸ªçŠ¶æ€å¯¹åº”çš„ä¸‹ä¸€æ­¥è¿˜éƒ½ä¸ä¸€æ ·ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int Inf=0x3f3f3f3f;const int MAXX=505;const double eps=0.0000001;struct point&#123; int x,y,kind;//0:ç«‹èµ·æ¥ 1:ç«–ç€ 2:æ¨ªç€ point(int xx=0,int yy=0,int kk=0):x(xx),y(yy),kind(kk)&#123;&#125; friend bool operator&lt;(point jj,point kk)&#123;return jj.kind&lt;kk.kind;&#125;&#125;;struct PP&#123; point pos; int len; friend bool operator&lt;(PP jj,PP kk)&#123; return jj.len&gt;kk.len; &#125;&#125;;int n,m,ans;char a[MAXX][MAXX],vis[MAXX][MAXX][4];void bfs()&#123; int enx=0,eny=0; queue&lt;PP&gt; pq; point p;PP pp; pp.len=0; bool findst=false,finden=false; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if(!findst&amp;&amp;a[i][j]==&#x27;X&#x27;)&#123; findst=true; pp.pos.x=i;pp.pos.y=j; bool two=false; if(a[i+1][j]==&#x27;X&#x27;)&#123; two=true; pp.pos.kind=1; &#125; else if(a[i][j+1]==&#x27;X&#x27;)&#123; two=true; pp.pos.kind=2; &#125; if(!two)&#123; pp.pos.kind=0; &#125; pq.push(pp); vis[pp.pos.x][pp.pos.y][pp.pos.kind]=true; &#125; if(!finden&amp;&amp;a[i][j]==&#x27;O&#x27;)&#123; finden=true; enx=i;eny=j; &#125; &#125; if(findst&amp;&amp;finden) break; &#125; //bfs while(!pq.empty())&#123; PP now=pq.front();pq.pop(); int i=now.pos.x,j=now.pos.y; if(now.pos.kind==0)&#123; if(now.pos.x==enx&amp;&amp;now.pos.y==eny)&#123; ans=now.len; break; &#125; if(i-2&gt;=1) if(a[i-1][j]!=&#x27;#&#x27;&amp;&amp;a[i-2][j]!=&#x27;#&#x27;)&#123; p.kind=1;p.x=i-2;p.y=j; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; if(i+2&lt;=n) if(a[i+1][j]!=&#x27;#&#x27;&amp;&amp;a[i+2][j]!=&#x27;#&#x27;)&#123; p.kind=1;p.x=i+1;p.y=j; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; if(j-2&gt;=1) if(a[i][j-1]!=&#x27;#&#x27;&amp;&amp;a[i][j-2]!=&#x27;#&#x27;)&#123; p.kind=2;p.x=i;p.y=j-2; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; if(j+2&lt;=m) if(a[i][j+1]!=&#x27;#&#x27;&amp;&amp;a[i][j+2]!=&#x27;#&#x27;)&#123; p.kind=2;p.x=i;p.y=j+1; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; &#125; else if(now.pos.kind==1)&#123; if(i-1&gt;=1) if(a[i-1][j]!=&#x27;#&#x27;&amp;&amp;a[i-1][j]!=&#x27;E&#x27;)&#123; p.kind=0;p.x=i-1;p.y=j; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; if(i+2&lt;=n) if(a[i+2][j]!=&#x27;#&#x27;&amp;&amp;a[i+2][j]!=&#x27;E&#x27;)&#123; p.kind=0;p.x=i+2;p.y=j; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; if(j-1&gt;=1) if(a[i][j-1]!=&#x27;#&#x27;&amp;&amp;a[i+1][j-1]!=&#x27;#&#x27;)&#123; p.kind=1;p.x=i;p.y=j-1; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; if(j+1&lt;=m) if(a[i][j+1]!=&#x27;#&#x27;&amp;&amp;a[i+1][j+1]!=&#x27;#&#x27;)&#123; p.kind=1;p.x=i;p.y=j+1; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; &#125; else if(now.pos.kind==2)&#123; if(i-1&gt;=1) if(a[i-1][j]!=&#x27;#&#x27;&amp;&amp;a[i-1][j+1]!=&#x27;#&#x27;)&#123; p.kind=2;p.x=i-1;p.y=j; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; if(i+1&lt;=n) if(a[i+1][j]!=&#x27;#&#x27;&amp;&amp;a[i+1][j+1]!=&#x27;#&#x27;)&#123; p.kind=2;p.x=i+1;p.y=j; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; if(j-1&gt;=1) if(a[i][j-1]!=&#x27;#&#x27;&amp;&amp;a[i][j-1]!=&#x27;E&#x27;)&#123; p.kind=0;p.x=i;p.y=j-1; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; if(j+2&lt;=m) if(a[i][j+2]!=&#x27;#&#x27;&amp;&amp;a[i][j+2]!=&#x27;E&#x27;)&#123; p.kind=0;p.x=i;p.y=j+2; if(!vis[p.x][p.y][p.kind])&#123; vis[p.x][p.y][p.kind]=true; pp.pos=p;pp.len=now.len+1; pq.push(pp); &#125; &#125; &#125; &#125;&#125;void solve_it()&#123; for(int i=1;i&lt;=n;++i)&#123; getchar(); scanf(&quot;%s&quot;,a[i]+1); &#125; ans=-1; bfs(); if(ans==-1) printf(&quot;Impossible\\n&quot;); else printf(&quot;%d\\n&quot;,ans); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) for(int k=0;k&lt;=2;++k) vis[i][j][k]=false;&#125;int main()&#123;// int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; if(n==0&amp;&amp;m==0) break; solve_it(); &#125; return 0;&#125; æ€»ç»“æœç´¢çš„ä¼˜åŒ–è¿˜æ˜¯æ¯”è¾ƒéš¾çš„ï¼Œä¼˜åŒ–æ°¸æ— æ­¢å¢ƒã€‚","categories":[],"tags":[{"name":"2021ACMå¯’å‡é›†è®­","slug":"2021ACMå¯’å‡é›†è®­","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"æ¯æ—¥æ€»ç»“-1æœˆ12æ—¥","slug":"1-12","date":"2022-01-12T12:47:08.000Z","updated":"2022-01-12T13:49:16.208Z","comments":true,"path":"2022/01/12/1-12/","link":"","permalink":"http://example.com/2022/01/12/1-12/","excerpt":"","text":"æœç´¢è¿›é˜¶dfs&amp;bfs&amp;è¿­ä»£åŠ æ·±&amp;A*ç®—æ³• å‰ªæä¼˜åŒ– ä¼˜åŒ–æœç´¢é¡ºåº æ’é™¤ç­‰æ•ˆå†—ä½™ å¯è¡Œæ€§å‰ªæ æœ€ä¼˜æ€§å‰ªæ è®°å¿†åŒ–æœç´¢ å¸¸æ•°ä¼˜åŒ– ä»Šæ—¥æˆ˜å†µ å‰è¨€æˆ‘ä¸ªäººæ„Ÿè§‰æˆ‘çš„æœç´¢åº”è¯¥è¿˜æ˜¯å·®ä¸å¤šçš„ï¼Œä½†æ˜¯ä»Šå¤©çš„é¢˜ç›®è®©æˆ‘è§‰å¾—æˆ‘çš„å‰ªææ–¹é¢çš„æ°´å¹³è¿˜æœ‰å¾…æå‡ï¼Œä»¥åŠè‡ªå·±çš„æ„é€ èƒ½åŠ›ä¸å¼ºï¼Œæœ‰æ—¶å€™åœ¨è„‘å­é‡Œé¢èƒ½æƒ³å‡ºæ¥ä¸€äº›ä¸œè¥¿ï¼Œä½†æ˜¯æ— æ³•é©¬ä¸Šæ„æ€å‡ºä»£ç ï¼Œè¿˜å¾—æƒ³äº¿ä¼šæ‰èƒ½(ä¹Ÿå¯èƒ½æƒ³ä¸å‡ºæ¥)ã€‚ éƒ¨åˆ†é¢˜ç›®é¢˜è§£Cé¢˜: Soduku (æœ€ç®€å•ç‰ˆæœ¬çš„)é¢˜ç›®ä¼ é€é—¨ é¢˜ç›® Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task. Input The input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0. Output For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them. Sample Input 123456789101103000509002109400000704000300502006060000050700803004000401000009205800804000107 Sample Output 123456789143628579572139468986754231391542786468917352725863914237481695619275843854396127 é¢˜ç›®å¤§æ„æœ‰tä¸ªæµ‹è¯•æ ·ä¾‹ï¼Œæ¯ä¸ªæ ·ä¾‹éƒ½æœ‰ä¸€ä¸ª9*9çš„æ•°ç‹¬ï¼Œé‡Œé¢çš„0è¡¨ç¤ºæœªç¡®å®šçš„æ•°ï¼Œç¼–ç¨‹å†™è¿™ä¸ªæ•°ç‹¬ï¼Œè¾“å‡ºå†™å¥½ä¹‹åçš„æ•°ç‹¬ã€‚ æ€è·¯æš´åŠ›çš„è¯å°±æ˜¯ç”¨æœç´¢éå†æ¯ä¸€è¡Œæ¯ä¸€ä¸ªä½ç½®ï¼Œæšä¸¾æ¯ä¸€ä¸ªå¯èƒ½çš„ç»“æœï¼Œç›´åˆ°å¾—åˆ°ç»“æœã€‚ æ­¤é¢˜æ•°æ®æ¯”è¾ƒæ°´ï¼Œæš´åŠ›å°±ç›´æ¥èƒ½ACã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;int a[10][10],belong[10][10];bool r[10][10],c[10][10],d[10][10],can;void output()&#123; for(int i=1;i&lt;=9;++i)&#123; for(int j=1;j&lt;=9;++j) printf(&quot;%d&quot;,a[i][j]); printf(&quot;\\n&quot;); &#125;&#125;void dfs(int jj,int kk)&#123; if(can) return; if(a[jj][kk])&#123; if(kk&lt;9) dfs(jj,kk+1); else if(jj&lt;9) dfs(jj+1,1); else&#123; output(); can=true; &#125; return; &#125; for(int i=1;i&lt;=9;++i)&#123; if(r[jj][i]||c[kk][i]||d[belong[jj][kk]][i]) continue; a[jj][kk]=i; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=true; if(kk&lt;9) dfs(jj,kk+1); else if(jj&lt;9) dfs(jj+1,1); else&#123; output(); can=true; return; &#125; if(can) return; a[jj][kk]=0; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=false; &#125;&#125;void solve_it()&#123; for(int i=1;i&lt;=9;++i)&#123; char jj; getchar(); for(int j=1;j&lt;=9;++j)&#123; scanf(&quot;%c&quot;,&amp;jj); a[i][j]=jj-&#x27;0&#x27;; if(a[i][j]!=0)&#123; r[i][a[i][j]]=true; c[j][a[i][j]]=true; d[belong[i][j]][a[i][j]]=true; &#125; &#125; &#125; can=false; dfs(1,1); for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j)&#123; a[i][j]=0; r[i][j]=c[i][j]=d[i][j]=false; &#125;&#125;int main()&#123; for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j) belong[i][j]=(i-1)/3*3+(j-1)/3+1; int t;scanf(&quot;%d&quot;,&amp;t); while(t--) solve_it(); return 0;&#125; Dé¢˜: Soduku (å˜æ€æ•°æ®ç‰ˆæœ¬çš„)(æœªåšå‡ºæ¥)é¢˜ç›®ä¼ é€é—¨ é¢˜ç›® In the game of Sudoku, you are given a large 9 Ã— 9 grid divided into smaller 3 Ã— 3 subgrids. For example, Given some of the numbers in the grid, your goal is to determine the remaining numbers such that the numbers 1 through 9 appear exactly once in (1) each of nine 3 Ã— 3 subgrids, (2) each of the nine rows, and (3) each of the nine columns. Input The input test file will contain multiple cases. Each test case consists of a single line containing 81 characters, which represent the 81 squares of the Sudoku grid, given one row at a time. Each character is either a digit (from 1 to 9) or a period (used to indicate an unfilled square). You may assume that each puzzle in the input will have exactly one solution. The end-of-file is denoted by a single line containing the word â€œendâ€. Output For each test case, print a line representing the completed Sudoku puzzle. Sample Input 123.2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.end Sample Output 12527389416819426735436751829375692184194538267268174593643217958951843672782965341416837529982465371735129468571298643293746185864351297647913852359682714128574936 é¢˜ç›®å¤§æ„å’Œä¸Šé“é¢˜å¤§æ„ä¸€æ ·ï¼Œè¾“å…¥ä¸€ä¸ªæ•°ç‹¬ï¼Œè¾“å‡ºå¡«å……å®Œæ•´çš„æ•°ç‹¬ã€‚ä½†æ˜¯æµ‹è¯•æ•°æ®è¦æ¯”Cé¢˜ç¦»è°±çš„å¤šã€‚ æ€è·¯å„ç§ä¼˜åŒ– æˆ‘ç›®å‰çš„ä»£ç åªè¿›è¡Œäº†æœç´¢é¡ºåºçš„ä¼˜åŒ–ï¼Œå¸¸ç†Ÿä¼˜åŒ–è¿˜æ²¡å­¦ä¼šã€‚ é™„ä¸Šè¿›è¡Œäº†æœç´¢é¡ºåºä¼˜åŒ–çš„ä»£ç ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;struct row&#123; int id,num;&#125;cnt[10];int a[10][10],belong[10][10],rate[10];string s;bool r[10][10],c[10][10],d[10][10],can;bool cmp(row jj,row kk)&#123;return jj.num&lt;kk.num;&#125;void output()&#123; for(int i=1;i&lt;=9;++i)&#123; for(int j=1;j&lt;=9;++j) printf(&quot;%d&quot;,a[i][j]); &#125; printf(&quot;\\n&quot;);&#125;void dfs(int jj,int kk)&#123;// printf(&quot;%d %d\\n&quot;,jj,rate[jj]); if(can) return; if(a[jj][kk])&#123; if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else&#123; output(); can=true; &#125; return; &#125; for(int i=1;i&lt;=9;++i)&#123; if(r[jj][i]||c[kk][i]||d[belong[jj][kk]][i]) continue; a[jj][kk]=i; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=true; if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else&#123; output(); can=true; return; &#125; if(can) return; a[jj][kk]=0; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=false; &#125;&#125;void solve_it()&#123; int p=-1; for(int i=1;i&lt;=9;++i)&#123; cnt[i].id=i; cnt[i].num=0; for(int j=1;j&lt;=9;++j)&#123; if(s[++p]==&#x27;.&#x27;)&#123; a[i][j]=0; ++cnt[i].num; continue; &#125; a[i][j]=s[p]-&#x27;0&#x27;; r[i][a[i][j]]=true; c[j][a[i][j]]=true; d[belong[i][j]][a[i][j]]=true; &#125; &#125; sort(cnt+1,cnt+10,cmp); for(int i=1;i&lt;=9;++i) rate[cnt[i].id]=i; can=false; dfs(cnt[1].id,1); for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j)&#123; a[i][j]=0; r[i][j]=c[i][j]=d[i][j]=false; &#125;&#125;int main()&#123; for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j) belong[i][j]=(i-1)/3*3+(j-1)/3+1; // int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) while(true)&#123; cin&gt;&gt;s; if(s==&quot;end&quot;) break; solve_it(); &#125; return 0;&#125; Fé¢˜: é¶å½¢æ•°ç‹¬é¢˜ç›®ä¼ é€é—¨ è¿™é‡Œå°±ä¸æ”¾é¢˜ç›®äº†ï¼Œæ€è·¯å’Œä¸Šé¢çš„æ•°ç‹¬çš„é¢˜ä¸€æ ·ï¼Œé€šè¿‡ä¼˜åŒ–æœç´¢é¡ºåºå³å¯AC æšä¸¾å‡ºæ¯ç§å¯èƒ½çš„æœ€ç»ˆç»“æœï¼Œå–æœ€å¤§å€¼å³å¯ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;struct row&#123; int id,num;&#125;cnt[10];int a[10][10],belong[10][10],rate[10],ans;bool r[10][10],c[10][10],d[10][10];bool cmp(row jj,row kk)&#123;return jj.num&lt;kk.num;&#125;void output()&#123; for(int i=1;i&lt;=9;++i)&#123; for(int j=1;j&lt;=9;++j) printf(&quot;%d &quot;,a[i][j]); &#125; printf(&quot;\\n&quot;);&#125;int getans()&#123; int re=10*a[5][5]; for(int i=1;i&lt;=4;++i)&#123; int st=5-i,en=5+i; int fen=10-i; for(int j=st;j&lt;=en;++j)&#123; re+=a[st][j]*fen; re+=a[en][j]*fen; &#125; for(int j=st+1;j&lt;en;++j)&#123; re+=a[j][st]*fen; re+=a[j][en]*fen; &#125; &#125; return re;&#125;void dfs(int jj,int kk)&#123; if(a[jj][kk])&#123; if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else&#123;// output(); ans=max(ans,getans()); &#125; return; &#125; for(int i=1;i&lt;=9;++i)&#123; if(r[jj][i]||c[kk][i]||d[belong[jj][kk]][i]) continue; a[jj][kk]=i; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=true; if(kk&lt;9) dfs(jj,kk+1); else if(rate[jj]&lt;9) dfs(cnt[rate[jj]+1].id,1); else&#123;// output(); ans=max(ans,getans()); &#125; a[jj][kk]=0; r[jj][i]=c[kk][i]=d[belong[jj][kk]][i]=false; &#125;&#125;void solve_it()&#123; for(int i=1;i&lt;=9;++i)&#123; cnt[i].id=i; cnt[i].num=0; for(int j=1;j&lt;=9;++j)&#123; scanf(&quot;%d&quot;,&amp;a[i][j]); if(a[i][j]==0)&#123; ++cnt[i].num; continue; &#125; r[i][a[i][j]]=true; c[j][a[i][j]]=true; d[belong[i][j]][a[i][j]]=true; &#125; &#125; sort(cnt+1,cnt+10,cmp); for(int i=1;i&lt;=9;++i) rate[cnt[i].id]=i; ans=-1; dfs(cnt[1].id,1); printf(&quot;%d\\n&quot;,ans); &#125;int main()&#123; for(int i=1;i&lt;=9;++i) for(int j=1;j&lt;=9;++j) belong[i][j]=(i-1)/3*3+(j-1)/3+1; // int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) solve_it(); return 0;&#125; æ€»ç»“ä»Šå¤©çš„æœç´¢è¿›é˜¶å¬è¯¾å’Œå†™é¢˜éƒ½æŒºæœ‰æ”¶è·ï¼ŒçŸ¥é“äº†æœç´¢çš„å„ç§ä¼˜åŒ–æ€è·¯ï¼Œä»¥åŠäº†è§£åˆ°äº†è¿­ä»£åŠ æ·±çš„æ€è·¯ï¼Œå¹¶æˆåŠŸä¾æ­¤Aé¢˜ã€‚ ä»Šå¤©å…ˆæ€»ç»“è¿™ä¸‰é“é¢˜ï¼Œæ˜å¤©å†æ€»ç»“å…¶ä»–é¢˜ç›®","categories":[],"tags":[{"name":"2021ACMå¯’å‡é›†è®­","slug":"2021ACMå¯’å‡é›†è®­","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"cfRound#764(Div.3)Summary","slug":"cfRound-764-Div-3-Summary","date":"2022-01-11T13:36:07.000Z","updated":"2022-01-11T16:49:05.829Z","comments":true,"path":"2022/01/11/cfRound-764-Div-3-Summary/","link":"","permalink":"http://example.com/2022/01/11/cfRound-764-Div-3-Summary/","excerpt":"","text":"Codeforces Round #764(Div. 3)CONTESTä¼ é€é—¨ æˆ˜å†µStanding Rating è¡¥é¢˜D - Palindromes Coloringé¢˜ç›® time limit per test: 2 seconds memory limit per test: 256 megabytes input: standard input output: standard output You have a string s consisting of lowercase Latin alphabet letters. You can color some letters in colors from 1 to k. It is not necessary to paint all the letters. But for each color, there must be a letter painted in that color. Then you can swap any two symbols painted in the same color as many times as you want. After that, k strings will be created, i-th of them will contain all the characters colored in the color i, written in the order of their sequence in the string s. Your task is to color the characters of the string so that all the resulting k strings are palindromes, and the length of the shortest of these k strings is as large as possible. Read the note for the first test case of the example if you need a clarification. Recall that a string is a palindrome if it reads the same way both from left to right and from right to left. For example, the strings abacaba, cccc, z and dxd are palindromes, but the strings abab and aaabaa â€” are not. Input The first line of input data contains a single integer t (1 â‰¤ t â‰¤ 10â´ ) â€” the number of input data sets in the test. The descriptions of the input data sets follow. The first line of the description of each input data set contains two integers n and k ( 1 â‰¤ k â‰¤ n â‰¤ 2â‹…10âµ ) â€” the length of the string and the number of colors in which its letters can be painted. The second line of the description of each input data set contains a string s of length n consisting of lowercase letters of the Latin alphabet. It is guaranteed that the sum of n over all test cases does not exceed 2â‹…10âµ . Output For each set of input data, output a single integer â€” the maximum length of the shortest palindrome string that can be obtained. Example input 108 2bxyaxzay6 3aaaaaa6 1abcdef6 6abcdef3 2dxd11 2abcabcabcac6 6sipkic7 2eatoohd3 1llw6 2bfvfbv output 3211151133 Note In the first test case, s =â€bxyaxzayâ€, k=2. We use indices in the string from 1 to 8. The following coloring will work: bxyaxzaybxyaxzay (the letter z remained uncolored). After painting: swap two red characters (with the indices 1 and 4), we get axybxzay; swap two blue characters (with the indices 5 and 8), we get axybyzax. Now, for each of the two colors we write out the corresponding characters from left to right, we get two strings aba and xyyx. Both of them are palindromes, the length of the shortest is 3. It can be shown that the greatest length of the shortest palindrome cannot be achieved. In the second set of input data, the following coloring is suitable: [1,1,2,2,3,3]. There is no need to swap characters. Both received strings are equal to aa, they are palindromes and their length is 2. In the third set of input data, you can color any character and take it into a string. In the fourth set of input data, you can color the i-th character in the color i. In the fifth set of input data can be colored in each of the colors of one character. In the sixth set of input data, the following coloring is suitable: [1,1,1,1,1,2,2,2,2,2,0]. Rearrange the characters so as to get the palindromes abcba and acbca. å¤§æ¦‚æ„æ€è¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸º n çš„ç”±å°å†™å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œå–å…¶ä¸­çš„å­—æ¯ç»„æˆ k ä¸ªå›æ–‡å­—ç¬¦ä¸²ï¼Œæ¯ä¸ªå­—æ¯(ä½ç½®ä¸åŒçš„æ¯ä¸ªå­—æ¯)æœ€å¤šåªèƒ½å±äºä¸€ä¸ªå­—ç¬¦ä¸²ã€‚é—®æ€æ ·å–èƒ½ä½¿å¾—å–å¾—çš„ k ä¸ªå›æ–‡å­—ç¬¦ä¸²ä¸­çš„æœ€çŸ­çš„é‚£ä¸€ä¸ªå°½é‡é•¿ã€‚è¾“å‡ºè¿™ä¸ªé•¿åº¦ã€‚ æˆ‘å½“æ—¶çš„æ€è·¯åœ¨ä¸€ä¸ªå›æ–‡ä¸²ä¸­ï¼Œè‹¥è¯¥å›æ–‡ä¸²çš„é•¿åº¦ä¸ºå¶æ•°ï¼Œåˆ™æ¯ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°éƒ½æ˜¯å¶æ•°(å³æˆå¯¹å‡ºç°)ï¼Œè‹¥è¯¥å›æ–‡ä¸²çš„é•¿åº¦ä¸ºå¥‡æ•°ï¼Œåˆ™æœ‰ä¸”åªæœ‰ä¸€ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°ä¸ºå¥‡æ•°ï¼Œä¸”å…¶ä»–å­—æ¯å‡ºç°çš„æ¬¡æ•°ä¸ºå¶æ•°(æˆå¯¹å‡ºç°)ã€‚ è®°å½•ä¸‹åŸå­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°ï¼Œæ¥ç€ï¼Œè®°å½•ä¸‹æˆå¯¹å‡ºç°çš„å­—æ¯æœ‰å‡ ç»„(è®°ä¸¤ä¸ªç›¸åŒçš„å­—æ¯ä¸ºä¸€ç»„)å’Œå•ä¸ªå‡ºç°çš„å­—æ¯æœ‰å‡ ä¸ªã€‚ æ¥ç€ï¼Œå°±æ˜¯å¯¹æ¯ä¸€ç§æƒ…å†µçš„åˆ†æåŠæšä¸¾(è¯¦è§ä»£ç )ã€‚ å½“æ—¶çš„ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=200005;const double eps=0.0000001;int n,k,num[200];char a[MAXX];void solve_it()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); getchar(); scanf(&quot;%s&quot;,a+1); int len=strlen(a+1); for(int i=1;i&lt;=len;++i)&#123; ++num[a[i]]; &#125; int sum=0,dan=0; for(int i=&#x27;a&#x27;;i&lt;=&#x27;z&#x27;;++i)&#123; if(num[i]%2==1)&#123; sum+=num[i]-1; ++dan; &#125; else sum+=num[i]; &#125; sum/=2; int ans; if(k&gt;n/2) ans=1; else if(sum&lt;k) ans=1; else&#123; ans=sum/k*2; if(sum%k==0)&#123; if(dan&gt;=k) ++ans; &#125; else&#123; int s=sum%k; dan+=s*2; if(dan&lt;k) ans=ans; else ++ans; &#125; &#125; printf(&quot;%d\\n&quot;,ans); for(int i=&#x27;a&#x27;;i&lt;=&#x27;z&#x27;;++i) num[i]=0;&#125;int main()&#123; int t;scanf(&quot;%d&quot;,&amp;t); while(t--) solve_it(); return 0;&#125; ç°åœ¨æƒ³çš„æ€è·¯æœ€å°å€¼æœ€å¤§åŒ–ï¼Œå…¸å‹çš„äºŒåˆ†ã€‚(ä½†æ˜¯å½“æ—¶æˆ‘ä¸ä¼šå†™äºŒåˆ†ğŸ˜­,è€Œä¸”çœ‹ç€Eé¢˜å’ŒFé¢˜éƒ½å¥½åƒè¦ç”¨åˆ°äºŒåˆ†) ç°åœ¨çš„ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=200005;const double eps=0.0000001;int n,k,num[200];int sum=0,dan=0,can;char a[MAXX];bool check(int jj)&#123; if(jj&lt;=sum/k*2+can) return true; else return false;&#125;void solve_it()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); getchar(); scanf(&quot;%s&quot;,a+1); int len=strlen(a+1); for(int i=1;i&lt;=len;++i)&#123; ++num[a[i]]; &#125; for(int i=&#x27;a&#x27;;i&lt;=&#x27;z&#x27;;++i)&#123; sum+=num[i]/2; dan+=num[i]%2; &#125; if(sum%k*2+dan&gt;=k) can=1; else can=0; int l=1,r=n,mid; while(l&lt;r)&#123; mid=(l+r+1)/2; if(check(mid)) l=mid; else r=mid-1; &#125; printf(&quot;%d\\n&quot;,r); for(int i=&#x27;a&#x27;;i&lt;=&#x27;z&#x27;;++i) num[i]=0; sum=dan=0;&#125;int main()&#123; int t;scanf(&quot;%d&quot;,&amp;t); while(t--) solve_it(); return 0;&#125; æ€»ç»“äºŒåˆ†æ€æˆ‘","categories":[],"tags":[{"name":"codeforces-practice","slug":"codeforces-practice","permalink":"http://example.com/tags/codeforces-practice/"}]},{"title":"æ¯æ—¥æ€»ç»“-1æœˆ11æ—¥","slug":"1-11","date":"2022-01-11T13:17:05.000Z","updated":"2022-01-11T14:01:18.297Z","comments":true,"path":"2022/01/11/1-11/","link":"","permalink":"http://example.com/2022/01/11/1-11/","excerpt":"","text":"dpè¿›é˜¶åŒºé—´dp&amp;æ ‘å½¢dp&amp;æ¦‚ç‡dp&amp;æ•°ä½dp ä»Šæ—¥æˆ˜å†µ å‰è¨€vjä¸Šçš„é¢˜å¥½éš¾å•Šï¼Œ ç¬¬ä¸€é¢˜æˆ‘çœ‹ç€å’Œæ˜¨å¤©çš„é‚£é“â€çŸ³å­åˆå¹¶â€æŒºåƒçš„ï¼Œä½†å°±æ˜¯ä¸çŸ¥é“æ€ä¹ˆç±»æ¯”è¿‡å»ï¼Œçœ‹äº†åŠå¤©å°±æ˜¯ä¸çŸ¥é“è¯¥æ€ä¹ˆå†™ã€‚å…¶ä»–é¢˜çœ‹ç€ä¹Ÿéƒ½å¥½éš¾ï¼Œæ€è·¯ä¹Ÿéƒ½æƒ³ä¸å‡ºæ¥ã€‚ å…³äºæ˜¨æ™šçš„CFCF Round #764 (Div. 3)æ€»ç»“ æ€»ç»“è¿›é˜¶dp(è¿˜æœ‰åŸºç¡€dp)ç°åœ¨è¿˜æ˜¯è½¯è‚‹ï¼Œä»éœ€å¤§é‡ç»ƒä¹ ç†è§£ã€‚","categories":[],"tags":[{"name":"2021ACMå¯’å‡é›†è®­","slug":"2021ACMå¯’å‡é›†è®­","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"æ¯æ—¥æ€»ç»“-1æœˆ10æ—¥","slug":"1-10","date":"2022-01-10T12:05:24.000Z","updated":"2022-01-11T13:51:12.251Z","comments":true,"path":"2022/01/10/1-10/","link":"","permalink":"http://example.com/2022/01/10/1-10/","excerpt":"","text":"dpè¿›é˜¶åŒºé—´dp&amp;æ ‘å½¢dp&amp;æ¦‚ç‡dp&amp;æ•°ä½dp å‰è¨€ä»Šå¤©æ²¡æœ‰å¼„é¢˜ç›®ï¼Œå°±åœ¨ç½‘ä¸Šæ‰¾èµ„æ–™å­¦ä¹ å’Œåšé¢˜ã€‚ æ„Ÿè§‰è¿™ä¸€éƒ¨åˆ†å¥½éš¾ï¼Œä¸å¤ªå¥½ç†è§£ï¼Œéš¾ä»¥è¿ç”¨ã€‚éœ€è¦å¤§é‡çš„ç»ƒä¹ ã€‚ åŒºé—´dpåŒºé—´ç±»åŠ¨æ€è§„åˆ’æ˜¯çº¿æ€§åŠ¨æ€è§„åˆ’çš„æ‰©å±•ï¼Œå®ƒåœ¨åˆ†é˜¶æ®µåœ°åˆ’åˆ†é—®é¢˜æ—¶ï¼Œä¸é˜¶æ®µä¸­å…ƒç´ å‡ºç°çš„é¡ºåºå’Œç”±å‰ä¸€é˜¶æ®µçš„å“ªäº›å…ƒç´ åˆå¹¶è€Œæ¥æœ‰å¾ˆå¤§çš„å…³ç³»ã€‚ ä»¤çŠ¶æ€ f(i,j) è¡¨ç¤ºå°†ä¸‹æ ‡ä½ç½® i åˆ° j çš„æ‰€æœ‰å…ƒç´ åˆå¹¶èƒ½è·å¾—çš„ä»·å€¼çš„æœ€å¤§å€¼ï¼Œé‚£ä¹ˆ f(i,j)=max&#123;f(i,k)+f(k+1,j)+cost&#125; ï¼Œ cost ä¸ºå°†è¿™ä¸¤ç»„å…ƒç´ åˆå¹¶èµ·æ¥çš„ä»£ä»·ã€‚ ç‰¹ç‚¹ åˆå¹¶ï¼šå°†ä¸¤ä¸ªæˆ–å¤šä¸ªéƒ¨åˆ†è¿›è¡Œæ•´åˆï¼Œå½“ç„¶ä¹Ÿå¯ä»¥åè¿‡æ¥ã€‚ ç‰¹å¾ï¼šèƒ½å°†é—®é¢˜åˆ†è§£ä¸ºèƒ½ä¸¤ä¸¤åˆå¹¶çš„å½¢å¼ã€‚ æ±‚è§£ï¼šå¯¹æ•´ä¸ªé—®é¢˜è®¾æœ€ä¼˜è´¨ï¼Œæšä¸¾åˆå¹¶ç‚¹ï¼Œå°†é—®é¢˜åˆ†è§£ä¸ºå·¦å³ä¸¤ä¸ªéƒ¨åˆ†ï¼Œæœ€ååˆå¹¶ä¸¤ä¸ªéƒ¨åˆ†çš„æœ€ä¼˜å€¼å¾—åˆ°åŸé—®é¢˜çš„æœ€ä¼˜å€¼ã€‚ ä¾‹é¢˜çŸ³å­åˆå¹¶ é¢˜ç›®å°† n å †çŸ³å­ç»•åœ†å½¢æ“åœºæ’æ”¾ï¼Œç°è¦å°†çŸ³å­æœ‰åºåœ°åˆå¹¶æˆä¸€å †ã€‚è§„å®šæ¯æ¬¡åªèƒ½é€‰ç›¸é‚»çš„ä¸¤å †åˆå¹¶æˆæ–°çš„ä¸€å †ï¼Œå¹¶å°†æ–°çš„ä¸€å †çš„çŸ³å­æ•°è®°åšè¯¥æ¬¡åˆå¹¶çš„å¾—åˆ†ã€‚ è¯·ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè¯»å…¥å †æ•° n åŠæ¯å †çš„çŸ³å­æ•°ï¼Œå¹¶è¿›è¡Œå¦‚ä¸‹è®¡ç®—ï¼š é€‰æ‹©ä¸€ç§åˆå¹¶çŸ³å­çš„æ–¹æ¡ˆï¼Œä½¿å¾—åš n-1 æ¬¡åˆå¹¶å¾—åˆ†æ€»å’Œæœ€å¤§ã€‚ é€‰æ‹©ä¸€ç§åˆå¹¶çŸ³å­çš„æ–¹æ¡ˆï¼Œä½¿å¾—åš n-1 æ¬¡åˆå¹¶å¾—åˆ†æ€»å’Œæœ€å°ã€‚ è¾“å…¥æ ¼å¼ è¾“å…¥ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•° n ï¼Œè¡¨ç¤ºæœ‰ n å †çŸ³å­ã€‚ ç¬¬äºŒè¡Œ n ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæ¯å †çŸ³å­çš„æ•°é‡ã€‚ è¾“å‡ºæ ¼å¼ è¾“å‡ºå…±ä¸¤è¡Œï¼š ç¬¬ä¸€è¡Œä¸ºåˆå¹¶å¾—åˆ†æ€»å’Œæœ€å°å€¼ï¼Œ ç¬¬äºŒè¡Œä¸ºåˆå¹¶å¾—åˆ†æ€»å’Œæœ€å¤§å€¼ã€‚ æ ·ä¾‹ è¾“å…¥ 1244 5 9 4 è¾“å‡º 124354 æ•°æ®èŒƒå›´ä¸æç¤º å¯¹äº 100% çš„æ•°æ®ï¼Œæœ‰ 1 â‰¤ n â‰¤ 200 ã€‚ æ€è·¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹ ç¯çš„å¤„ç† å°†é“¾å»¶é•¿è‡³ä¸¤å€ï¼Œå˜æˆ 2*n å †ï¼Œå…¶ä¸­ç¬¬ i å †ä¸ç¬¬ n+i å †ç›¸åŒï¼Œç”¨åŠ¨æ€è§„åˆ’æ±‚è§£åï¼Œå– f(1,n),f(2,n+1),â€¦,f(i,n+i-1) ä¸­çš„æœ€ä¼˜å€¼ï¼Œå³ä¸ºæœ€åçš„ç­”æ¡ˆã€‚ æ—¶é—´å¤æ‚åº¦ O(nÂ³) ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=210;const double eps=0.0000001;int n,a[2*MAXX],sum[2*MAXX],dpmax[2*MAXX][2*MAXX],dpmin[2*MAXX][2*MAXX];void solve_it()&#123; scanf(&quot;%d&quot;,&amp;n); int n2=n*2; for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;a[i]); a[n+i]=a[i]; &#125; for(int i=1;i&lt;=n2;++i) sum[i]=sum[i-1]+a[i]; memset(dpmin,Inf,sizeof(dpmin)); for(int i=1;i&lt;=n2;++i) dpmin[i][i]=0; for(int c=2;c&lt;=n;++c)&#123; for(int i=1;i&lt;n2;++i)&#123; int j=i+c-1; for(int k=i;k&lt;j&amp;&amp;k&lt;n2;++k)&#123; dpmax[i][j]=max(dpmax[i][j],dpmax[i][k]+dpmax[k+1][j]+sum[j]-sum[i-1]); dpmin[i][j]=min(dpmin[i][j],dpmin[i][k]+dpmin[k+1][j]+sum[j]-sum[i-1]); &#125; &#125; &#125; int ansmax=dpmax[1][n],ansmin=dpmin[1][n]; for(int i=2;i&lt;=n;++i)&#123; ansmax=max(ansmax,dpmax[i][i+n-1]); ansmin=min(ansmin,dpmin[i][i+n-1]); &#125; printf(&quot;%d\\n%d\\n&quot;,ansmin,ansmax); &#125;int main()&#123;// int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) solve_it(); return 0;&#125; æ ‘å½¢dpå°±æ˜¯åœ¨æ ‘ä¸Šè¿›è¡Œçš„dp(ç¡®ä¿¡) ä¸€èˆ¬ä¸ºé€’å½’å®ç° ä¾‹é¢˜æ²¡æœ‰ä¸Šå¸çš„èˆä¼š é¢˜ç›®æŸå¤§å­¦æœ‰ n ä¸ªèŒå‘˜ï¼Œç¼–å·ä¸º 1â€¦n ã€‚ ä»–ä»¬ä¹‹é—´æœ‰ä»å±å…³ç³»ï¼Œä¹Ÿå°±æ˜¯è¯´ä»–ä»¬çš„å…³ç³»å°±åƒä¸€æ£µä»¥æ ¡é•¿ä¸ºæ ¹çš„æ ‘ï¼Œçˆ¶ç»“ç‚¹å°±æ˜¯å­ç»“ç‚¹çš„ç›´æ¥ä¸Šå¸ã€‚ ç°åœ¨æœ‰ä¸ªå‘¨å¹´åº†å®´ä¼šï¼Œå®´ä¼šæ¯é‚€è¯·æ¥ä¸€ä¸ªèŒå‘˜éƒ½ä¼šå¢åŠ ä¸€å®šçš„å¿«ä¹æŒ‡æ•° r_iï¼Œä½†æ˜¯å‘¢ï¼Œå¦‚æœæŸä¸ªèŒå‘˜çš„ç›´æ¥ä¸Šå¸æ¥å‚åŠ èˆä¼šäº†ï¼Œé‚£ä¹ˆè¿™ä¸ªèŒå‘˜å°±æ— è®ºå¦‚ä½•ä¹Ÿä¸è‚¯æ¥å‚åŠ èˆä¼šäº†ã€‚ æ‰€ä»¥ï¼Œè¯·ä½ ç¼–ç¨‹è®¡ç®—ï¼Œé‚€è¯·å“ªäº›èŒå‘˜å¯ä»¥ä½¿å¿«ä¹æŒ‡æ•°æœ€å¤§ï¼Œæ±‚æœ€å¤§çš„å¿«ä¹æŒ‡æ•°ã€‚ è¾“å…¥æ ¼å¼ è¾“å…¥çš„ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´æ•° nã€‚ ç¬¬ 22 åˆ°ç¬¬ (n + 1) è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼Œç¬¬ (i + 1) è¡Œçš„æ•´æ•°è¡¨ç¤º ii å·èŒå‘˜çš„å¿«ä¹æŒ‡æ•° r_i ã€‚ ç¬¬ (n + 2) åˆ°ç¬¬ 2n2n è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸€å¯¹æ•´æ•° l , k ï¼Œä»£è¡¨ k æ˜¯ l çš„ç›´æ¥ä¸Šå¸ã€‚ è¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€è¡Œä¸€ä¸ªæ•´æ•°ä»£è¡¨æœ€å¤§çš„å¿«ä¹æŒ‡æ•°ã€‚ è¾“å…¥è¾“å‡ºæ ·ä¾‹ è¾“å…¥ 1234567891011121314711111111 32 36 47 44 53 5 è¾“å‡º 15 æ•°æ®èŒƒå›´ å¯¹äº 100% çš„æ•°æ®ï¼Œä¿è¯ 1 â‰¤ n â‰¤ 6 * 10Â³ , -128 â‰¤ r_i â‰¤ 127 , 1 â‰¤ l,k â‰¤ nï¼Œä¸”ç»™å‡ºçš„å…³ç³»ä¸€å®šæ˜¯ä¸€æ£µæ ‘ã€‚ æ€è·¯ç”¨ f(i,0/1) ä»£è¡¨ä»¥ i ä¸ºæ ¹çš„å­æ ‘çš„æœ€ä¼˜è§£ (0è¡¨ç¤º i ä¸å‚åŠ èˆä¼šï¼Œ1è¡¨ç¤º i å‚åŠ èˆä¼š)ã€‚ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ f(i,0) = âˆ‘max{f(x,1),f(x,0)} (ä¸Šå¸ä¸å‚åŠ èˆä¼šï¼Œä¸‹å±å¯å‚åŠ å¯ä¸å‚åŠ ) f(i,1) = âˆ‘f(x,0) + a_i (ä¸Šå¸å‚åŠ èˆä¼šï¼Œä¸‹å±ä¸å‚åŠ ) ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#define Inf 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; P;typedef long long LL;const int MAXX=6005;const double eps=0.0000001;int n,a[MAXX],ans[MAXX][2],in[MAXX];vector&lt;int&gt; son[MAXX];int dfs(int now,int flag)&#123; if(ans[now][flag]!=Inf) return ans[now][flag]; if(flag==1)&#123; int re=a[now]; int si=son[now].size(); for(int i=0;i&lt;si;++i) re+=dfs(son[now][i],0); return ans[now][flag]=re; &#125; else&#123; int re=0; int si=son[now].size(); for(int i=0;i&lt;si;++i) re+=max(dfs(son[now][i],1),dfs(son[now][i],0)); return ans[now][flag]=re; &#125;&#125;void solve_it()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;n;++i)&#123; int jj,kk;scanf(&quot;%d%d&quot;,&amp;jj,&amp;kk); son[kk].emplace_back(jj); in[jj]=1; &#125; memset(ans,Inf,sizeof(ans)); int ans=0; for(int i=1;i&lt;=n;++i)&#123; if(!in[i])&#123; ans=max(dfs(i,0),dfs(i,1)); &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125;int main()&#123;// int t;scanf(&quot;%d&quot;,&amp;t);// while(t--) solve_it(); return 0;&#125;","categories":[],"tags":[{"name":"2021ACMå¯’å‡é›†è®­","slug":"2021ACMå¯’å‡é›†è®­","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"æ¯æ—¥æ€»ç»“-1æœˆ8æ—¥","slug":"1-8","date":"2022-01-08T15:33:25.000Z","updated":"2022-01-10T12:55:12.676Z","comments":true,"path":"2022/01/08/1-8/","link":"","permalink":"http://example.com/2022/01/08/1-8/","excerpt":"","text":"é«˜æ–¯æ¶ˆå…ƒä¸çº¿æ€§åŸºé«˜æ–¯æ¶ˆå…ƒä¸çº¿æ€§åŸº(Ã—) ç–¯ç‹‚æŸ¥èµ„æ–™æ­å»ºåšå®¢(âˆš) ä½¿ç”¨çš„æ˜¯hexoæ¡†æ¶+githubçš„æ–¹æ³•æ­å»ºçš„åšå®¢ å‰è¨€ä»Šå¤©ä¸Šåˆå»åšæ ¸é…¸ï¼Œè¯·äº†å‡ï¼Œåœ¨åšå®Œæ ¸é…¸å›æ¥ä¹‹åä¸€ç›´åœ¨æåšå®¢ï¼Œæ²¡æœ‰è¿›è¡Œè®­ç»ƒï¼›ä¸‹åˆä¹Ÿæ˜¯å¤§éƒ¨åˆ†æ—¶é—´éƒ½åœ¨è¿›è¡Œä¸ªäººåšå®¢çš„ä¸€ä¸ªæ­å»ºï¼›æ™šä¸Šä¾ç„¶æ˜¯æ­å»ºåšå®¢ğŸ˜­ã€‚ åˆ°äº†1ç‚¹é’Ÿå·¦å³ï¼Œç»ˆäºæ˜¯æ­å»ºå¥½äº†è‡ªå·±çš„åšå®¢ã€‚ å½“ç„¶ï¼Œååˆ†æ„Ÿè°¢æˆ‘çš„å¥½æœ‹å‹çš„å¸®åŠ©ã€‚ä¸ç„¶ä¸çŸ¥é“åˆ°ä»€ä¹ˆæ—¶å€™æ‰èƒ½æ­å»ºå¥½ã€‚ æ…¢çš„åŸå› (å…¶ä¸€)æˆ‘åˆšå¼€å§‹æ˜¯è·Ÿç€æˆ‘æœ‹å‹ç»™æˆ‘å‘çš„é“¾æ¥è¿›è¡Œä¸€æ­¥ä¸€æ­¥æ“ä½œçš„ï¼Œä½†æ˜¯ï¼Œåœ¨è¿›è¡Œäº†æ— æ•°æ¬¡çš„é‡å¤æ“ä½œå¹¶ä¸”æ¯æ¬¡éƒ½æ˜¯ä»¥å¤±è´¥å‘Šç»ˆåï¼Œæˆ‘æ„Ÿè§‰ï¼Œæœ‰é—®é¢˜ã€‚ ä¹‹åå»å„ç§åœ°æ–¹æŸ¥æ‰¾ç›¸å…³èµ„æ–™ï¼Œæœ€åï¼Œåœ¨(ä»Šæ™šğŸ¤”å¿˜äº†å‡ ç‚¹äº†ï¼Œæ€»ä¹‹å°±å¾ˆæ™šï¼Œå¯èƒ½å¿«12ç‚¹å§)çš„æ—¶å€™ï¼Œæˆ‘ç»ˆäºåœ¨Bç«™çš„è¿™ä¸ªè§†é¢‘ä¸­å–åˆ°äº†çœŸç»ã€‚ å…·ä½“åŸå› å°±æ˜¯æˆ‘åˆšå¼€å§‹çœ‹çš„æ•™ç¨‹éƒ½æ˜¯è€ç‰ˆçš„æ•™ç¨‹ï¼Œä½†æ˜¯æœ€è¿‘githubæœ‰è¿›è¡Œè¿™æ–¹é¢çš„æ›´æ–° åœ¨ä¸Šä¼ åˆ°githubä¸Šæ—¶ä¸èƒ½ç”¨å¯†é’¥è¿›è¡ŒéªŒè¯äº† é»˜è®¤çš„åˆ†æ”¯è¿›è¡Œä¿®æ”¹äº† è§£å†³æ–¹æ³•(å…¶ä¸€)(å’ŒåŸç‰ˆæ•™ç¨‹ç›¸æ¯”) å°† _config.yml æ–‡ä»¶ä¸­çš„ branch é€‰é¡¹æ”¹ä¸º main (ä¹‹å‰çš„æ•™ç¨‹ä¸­è¿™é‡Œéƒ½æ˜¯master) åœ¨è¾“å…¥ç”¨æˆ·åå¯†ç éªŒè¯çš„è¾“å…¥å¯†ç æ—¶ï¼Œä¸èƒ½è¾“å…¥è´¦æˆ·çš„å¯†ç ï¼Œåº”è¯¥è¾“å…¥ä»¤ç‰Œ(ä»¤ç‰Œè®¾ç½®åœ¨ä¸‹ä¸€æ¡)æˆ–è€…ä½¿ç”¨å…¶ä»–æ–¹æ³•è¿›è¡ŒéªŒè¯ã€‚ ä»¤ç‰Œçš„è®¾ç½® åœ¨githubä¸­è¿›å…¥ settings ç‚¹å‡» Developer settings ç‚¹å‡» Personal access tokens æ–°å»ºä¸€ä¸ªä»¤ç‰Œ å³å¯ æ…¢çš„åŸå› (å…¶äºŒ)æˆ‘åœ¨å†™æ˜¨å¤©çš„é‚£ç‰‡åšå®¢çš„æ—¶å€™ï¼Œéœ€è¦åœ¨é‡Œé¢å¤åˆ¶ä¸€å¼ å›¾ç‰‡ï¼Œä½†æ˜¯ï¼Œä¸ç®¡æ˜¯ä½¿ç”¨ç»å¯¹è·¯å¾„è¿˜æ˜¯ä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼Œåœ¨æœ¬åœ°çš„.mdæ–‡ä»¶ä¸­å¯ä»¥æ­£å¸¸çœ‹åˆ°å›¾ç‰‡ï¼Œä½†æ˜¯åˆ°ç½‘é¡µç«¯å°±çœ‹ä¸åˆ°å›¾ç‰‡ã€‚ è§£å†³æ–¹æ³•(å…¶äºŒ)æˆ‘æ˜¯çœ‹Bç«™ä¸Šçš„è¿™ä¸ªè§†é¢‘è¿›è¡Œæ“ä½œçš„ã€‚ å…·ä½“çš„å°±æ˜¯ å°† _config.yml æ–‡ä»¶ä¸­çš„ post_asset_folder é€‰é¡¹è®¾ç½®ä¸º true ä¸‹è½½ä¸€ä¸ªæ’ä»¶ åœ¨ \\source\\_posts è·¯å¾„ä¸‹è¿›è¡Œ Git Bash è¾“å…¥ npm add https://github.com/CodeFalling/hexo-asset-image è¿›è¡Œä¸‹è½½ ä¹‹ååœ¨.mdæ–‡ä»¶ä¸­éœ€è¦ä½¿ç”¨å›¾ç‰‡æ—¶ï¼Œä½¿ç”¨ç›¸å¯¹è·¯å¾„å³å¯ ç»“è¯­ä¸ç®¡æ€ä¹ˆæ ·ï¼Œä¹Ÿç®—æ˜¯æŠŠåšå®¢æ­å»ºå¥½äº†ï¼Œä¹‹åä¼šè¿›è¡Œåšå®¢çš„ç¾åŒ–å·¥ä½œã€‚ å¦‚æœé‡åˆ°äº†ç±»ä¼¼çš„å›°éš¾ï¼Œå¯ä»¥å°†æœ¬ç¯‡åšå®¢è½¬å‘ã€‚","categories":[],"tags":[{"name":"2021ACMå¯’å‡é›†è®­","slug":"2021ACMå¯’å‡é›†è®­","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"æ¯æ—¥æ€»ç»“:1æœˆ7æ—¥","slug":"1-7","date":"2022-01-08T14:25:04.000Z","updated":"2022-01-10T12:08:38.040Z","comments":true,"path":"2022/01/08/1-7/","link":"","permalink":"http://example.com/2022/01/08/1-7/","excerpt":"","text":"é«˜æ–¯æ¶ˆå…ƒä¸çº¿æ€§åŸºæ„Ÿè§‰å°±æ˜¯çº¿ä»£é‡Œé¢çš„çŸ©é˜µï¼Œè¿˜æœ‰çº¿æ€§ç›¸å…³ï¼Œè¿™ä¸¤éƒ¨åˆ†ã€‚ ä»Šæ—¥æˆ˜å†µ ä»Šæ—¥æ€»ç»“Aé¢˜å¿«è¦å†™åäº†ï¼Œä½†æ˜¯åœ¨å†™Aé¢˜çš„æ—¶å€™æŠŠé«˜æ–¯æ¶ˆå…ƒç†è§£äº†ä¸å°‘ã€‚ç”šè‡³å¿«æŠŠçŸ©é˜µç±»(ç»“æ„ä½“)ç»™å°è£…å¥½äº†(bushi)ã€‚ æŠŠå·®ä¸å¤šå†™å¥½çš„æµ®ç‚¹æ•°çš„çŸ©é˜µç»“æ„ä½“ä»£ç æ”¾åˆ°è¿™é‡Œã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081struct Matrix&#123; vector&lt;vector&lt;double&gt; &gt; c; int nn,mm; Matrix()&#123; nn=0;mm=0; &#125; Matrix(int nnn,int mmm)&#123; nn=nnn;mm=mmm; c.resize(nnn+1); for(int i=1;i&lt;=nn;++i) c[i].resize(mm+1); &#125; friend Matrix operator*(const Matrix&amp; x,const Matrix&amp; y)&#123; Matrix re(x.nn,y.mm); for(int i=1;i&lt;=x.nn;++i)&#123; for(int j=1;j&lt;=y.mm;++j)&#123; for(int k=1;k&lt;=x.mm;++k)&#123; re.c[i][j]+=(double)((LL)(x.c[i][k]*y.c[k][j])%MOD)+x.c[i][k]*y.c[k][j]-(LL)(x.c[i][k]*y.c[k][j]); re.c[i][j]=(double)((LL)(re.c[i][j])%MOD)+re.c[i][j]-(LL)(re.c[i][j]); &#125; &#125; &#125; return re; &#125; void elimination()&#123; int nm=min(nn,mm); for(int cc=1,r=1;cc&lt;=nm;++cc)&#123; int t=r; for(int i=r+1;i&lt;=nn;++i) if(fabs(c[i][cc])&gt;fabs(c[t][cc])) t=i; if(fabs(c[t][cc])&lt;eps) continue; if(t!=r)&#123; for(int j=cc;j&lt;=mm;++j) swap(c[t][j],c[r][j]); &#125; for(int j=mm;j&gt;=cc;--j) c[r][j]/=c[r][cc]; for(int i=1;i&lt;=nn;++i)&#123; if(i==r) continue; if(fabs(c[i][cc])&gt;eps) for(int j=mm;j&gt;=cc;--j) c[i][j]=c[i][j]-c[i][cc]*c[r][j]; &#125; ++r; &#125; &#125; Matrix inverse() const&#123; Matrix re(this-&gt;nn,this-&gt;mm),temp=*this; temp.mm*=2; for(int i=1;i&lt;=temp.nn;++i)&#123; temp.c[i].resize(temp.mm+1,0); &#125; for(int i=1;i&lt;=temp.nn;++i)&#123; temp.c[i][temp.nn+i]=1; &#125; temp.elimination(); for(int i=1;i&lt;=re.nn;++i) for(int j=1;j&lt;=re.mm;++j)&#123; re.c[i][j]=temp.c[i][re.nn+j]; &#125; return re; &#125; void output()&#123; for(int i=1;i&lt;=nn;++i)&#123; for(int j=1;j&lt;mm;++j)&#123; printf(&quot;%lf &quot;,c[i][j]); &#125; printf(&quot;%lf\\n&quot;,c[i][mm]); &#125; &#125;&#125;; åœ¨åé¢çº¿æ€§åŸºçš„å­¦ä¹ ä¸­ï¼Œåœ¨ç½‘ä¸ŠæŸ¥äº†ä¸å°‘ï¼Œä¹Ÿç†è§£çš„å·®ä¸å¤šäº†ï¼Œæ„Ÿè§‰å°±è·Ÿçº¿ä»£é‡Œé¢çš„æœ€å¤§çº¿æ€§ä¸ç›¸å…³å‘é‡ç»„(å¥½åƒå«è¿™å)å¾ˆåƒï¼Œåªä¸è¿‡æ˜¯å˜æˆäº†äºŒè¿›åˆ¶çš„å½¢å¼ã€‚ ç„¶åGé¢˜é‡Œæœ‰ä¸€ä¸ªå‘(å¯èƒ½å¹¶ä¸ç®—å‘)ï¼Œå½“çº¿æ€§åŸºçš„å…ƒç´ ä¸ªæ•°ç­‰äºnçš„æ—¶å€™ï¼Œä»–ä»¬å¼‚æˆ–å¾—ä¸åˆ°0è¿™ä¸ªç»“æœã€‚ è¿™éƒ¨åˆ†æ„Ÿè§‰ä¸»è¦å°±æ˜¯ç†Ÿæ‚‰ç†è§£æ¨¡æ¿ã€‚ä½†æ˜¯Cé¢˜å®åœ¨æ˜¯çœ‹ä¸å‡ºæ¥å’Œé«˜æ–¯æ¶ˆå…ƒæœ‰ä»€ä¹ˆå…³ç³»ï¼ŒAé¢˜ä¹Ÿæ˜¯ä¸€ç›´WAï¼Œç”¨äº†ä¸¤ç§æ–¹æ³•ï¼Œéƒ½æ˜¯WAã€‚ç°åœ¨ä¹Ÿæ²¡æƒ³å‡ºæ¯”è¾ƒå¥½çš„è§£å†³æ–¹æ³•ã€‚","categories":[],"tags":[{"name":"2021ACMå¯’å‡é›†è®­","slug":"2021ACMå¯’å‡é›†è®­","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-01-08T14:04:51.654Z","updated":"2022-01-08T14:04:51.654Z","comments":true,"path":"2022/01/08/hello-world/","link":"","permalink":"http://example.com/2022/01/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"2021ACMå¯’å‡é›†è®­","slug":"2021ACMå¯’å‡é›†è®­","permalink":"http://example.com/tags/2021ACM%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD/"},{"name":"codeforces-practice","slug":"codeforces-practice","permalink":"http://example.com/tags/codeforces-practice/"}]}